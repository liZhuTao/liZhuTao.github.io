<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>封装queryURLParams函数</title>
    <url>/2019/11/26/2019-11-26-queryURLParams-md/</url>
    <content><![CDATA[<h2 id="封装queryURLParams函数"><a href="#封装queryURLParams函数" class="headerlink" title="封装queryURLParams函数"></a>封装queryURLParams函数</h2><a id="more"></a>
<h3 id="方法一：基于数组的方法"><a href="#方法一：基于数组的方法" class="headerlink" title="方法一：基于数组的方法"></a>方法一：基于数组的方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let url = &apos;http://www.lizhutao.github.io/index.html?id=1&amp;name=lzt&amp;age=20#box&apos;;</span><br><span class="line"></span><br><span class="line">function queryURLParams(url) &#123;</span><br><span class="line">	//1.获取？后面的信息</span><br><span class="line">	let askIn = url.indexOf(&apos;?&apos;),</span><br><span class="line">		wellIn = url.lastIndexOf(&apos;#&apos;),</span><br><span class="line">		askText = &apos;&apos;,</span><br><span class="line">		wellText = &apos;&apos;;</span><br><span class="line">	//#号不存在</span><br><span class="line">	wellIn === -1 ? wellText = url.length : null;</span><br><span class="line">	//?号存在</span><br><span class="line">	askIn !== -1 ? askText = url.substring(askIn + 1, wellIn) : null;</span><br><span class="line">	wellText = url.substring(wellIn + 1);</span><br><span class="line"></span><br><span class="line">	//2.获取每一部分的信息</span><br><span class="line">	let result = &#123;&#125;;</span><br><span class="line">	//获取 HASH 值</span><br><span class="line">	wellText !== &apos;&apos; ? result[&apos;HASH&apos;] = wellText : null;</span><br><span class="line">	if (askText !== &apos;&apos;) &#123;</span><br><span class="line">		let ary = askText.split(&apos;&amp;&apos;);</span><br><span class="line">		ary.forEach(item =&gt; &#123;</span><br><span class="line">			let itemAry = item.split(&apos;=&apos;);</span><br><span class="line">			result[itemAry[0]] = itemAry[1];</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let paramObj = queryURLParams(url);</span><br><span class="line">console.log(paramObj);</span><br></pre></td></tr></table></figure>


<h3 id="方法二：基于正则表达式实现"><a href="#方法二：基于正则表达式实现" class="headerlink" title="方法二：基于正则表达式实现"></a>方法二：基于正则表达式实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let url = &apos;http://www.lizhutao.github.io/index.html?id=1&amp;name=lzt&amp;age=20#box&apos;;</span><br><span class="line"></span><br><span class="line">function queryURLParams(url) &#123;</span><br><span class="line">	let result = &#123;&#125;,</span><br><span class="line">		reg1 = /([^?#&amp;=]+)=([^?#&amp;=]+)/g,</span><br><span class="line">		reg2 = /#([^?#&amp;=]+)/g;</span><br><span class="line">	url.replace(reg1, (n, x, y) =&gt; result[x] = y);</span><br><span class="line">	url.replace(reg2, (n, x ) =&gt; result[&apos;HASH&apos;] = x);</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let paramObj = queryURLParams(url);</span><br><span class="line">console.log(paramObj);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重</title>
    <url>/2019/11/26/2019-11-26-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D-md/</url>
    <content><![CDATA[<h2 id="数组去重的方法"><a href="#数组去重的方法" class="headerlink" title="数组去重的方法"></a>数组去重的方法</h2><a id="more"></a>
<h3 id="方法一：创建新数组"><a href="#方法一：创建新数组" class="headerlink" title="方法一：创建新数组"></a>方法一：创建新数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let newAry = [];</span><br><span class="line">for (let i = 0; i &lt; ary.length; i++)&#123;</span><br><span class="line">	let item = ary[i];</span><br><span class="line">	if(newAry.includes(item))&#123;</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	newAry.push(item);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary,newAry);</span><br><span class="line"></span><br><span class="line">//代码优化</span><br><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let newAry = [];</span><br><span class="line">ary.forEach(item=&gt;&#123;</span><br><span class="line">	if(newAry.includes(item))	return;</span><br><span class="line">	newAry.push(item);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(ary,newAry);</span><br></pre></td></tr></table></figure>

<h3 id="方法二：嵌套for循环操作原有数组"><a href="#方法二：嵌套for循环操作原有数组" class="headerlink" title="方法二：嵌套for循环操作原有数组"></a>方法二：嵌套for循环操作原有数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">for (let i = 0; i &lt; ary.length; i++) &#123;</span><br><span class="line">	let item = ary[i];</span><br><span class="line">	for (let j = i + 1; j &lt; ary.length; j++) &#123;</span><br><span class="line">		let item2 = ary[j];</span><br><span class="line">		if (item === item2)&#123;</span><br><span class="line">			ary.splice(j,1);  //数组塌陷</span><br><span class="line">			j--;          //解决数组塌陷问题</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary);  =&gt;//[1, 2, 3]</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 数组的splice方法在操作数组的时候会导致数组塌陷问题</p>
</blockquote>
<h3 id="方法三：新建对象比较"><a href="#方法三：新建对象比较" class="headerlink" title="方法三：新建对象比较"></a>方法三：新建对象比较</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">for (let i = 0; i &lt; ary.length; i++) &#123;</span><br><span class="line">	let item = ary[i];</span><br><span class="line">	if (obj[item] === item) &#123;   //或  obj[item] !== undefined</span><br><span class="line">		ary.splice(i, 1);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	obj[item] = item;</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>操作数据大时，性能不好</p>
</blockquote>
<h3 id="方法四-遇到重复项将最后一项赋值给当前项，并删除最后一项"><a href="#方法四-遇到重复项将最后一项赋值给当前项，并删除最后一项" class="headerlink" title="方法四:遇到重复项将最后一项赋值给当前项，并删除最后一项"></a>方法四:遇到重复项将最后一项赋值给当前项，并删除最后一项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">for (let i = 0; i &lt; ary.length; i++) &#123;</span><br><span class="line">	let item = ary[i];</span><br><span class="line">	if (obj[item] !== undefined) &#123;  //obj中有这一项</span><br><span class="line">		ary[i] == ary[ary.length-1];</span><br><span class="line">		ary.length--;</span><br><span class="line">		i--;</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	obj[item] = item;</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>操作数据比较大的时候，性能比较好；</p>
</blockquote>
<h3 id="方法五：ES6数据结构–set-方法"><a href="#方法五：ES6数据结构–set-方法" class="headerlink" title="方法五：ES6数据结构–set()方法"></a>方法五：ES6数据结构–set()方法</h3><blockquote>
<p>ES6新增的一种新的数据结构，类似于数组，但成员是唯一的且无序的，没有重复值。Set本身是一种构造函数，用来生成Set数据结构。Set对象允许你存储任何类型的唯一值，无论是原始值还是对象引用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let ary1 = [...new Set(ary)];  //使用剩余参数转数组</span><br><span class="line">console.log(ary1);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现冒泡、插入、快速排序</title>
    <url>/2019/12/06/2019-12-6-%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-md/</url>
    <content><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote>
<p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubble(ary)&#123;</span><br><span class="line">    let temp = null;</span><br><span class="line">    for(let i = 0; i &lt; ary.length-1; i++)&#123;</span><br><span class="line">        for(let j = 0; j &lt; ary.length-1-i; j++)&#123;</span><br><span class="line">            if(ary[j] &gt; ary[j+1])&#123;</span><br><span class="line">                temp = ary[j];</span><br><span class="line">                ary[j] = ary[j+1];</span><br><span class="line">                ary[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote>
<p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function insert(ary)&#123;</span><br><span class="line">    let newAry = [];</span><br><span class="line">    newAry.push(ary[0]);</span><br><span class="line">    for(let i = 1; i &lt; ary.length; i++)&#123;</span><br><span class="line">        let A = ary[i];</span><br><span class="line">        for(let j =newAry.length-1; j &gt;=0; j--)&#123;</span><br><span class="line">            let B = newAry[j];</span><br><span class="line">            if(A&gt;B)&#123;</span><br><span class="line">                newAry.splice(j+1,0,A);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j===0)&#123;</span><br><span class="line">                newAry.unshift(A);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newAry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote>
<p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quick(ary)&#123;</span><br><span class="line">    if(ary.length&lt;=1)&#123;</span><br><span class="line">        return ary;</span><br><span class="line">    &#125;</span><br><span class="line">    let middleIndex = Math.floor(ary.length/2);</span><br><span class="line">    let middleValue = ary.splice(middleIndex,1)[0];</span><br><span class="line">    let aryLeft = [];</span><br><span class="line">    let aryRight = [];</span><br><span class="line">    for(let i = 0;i&lt;ary.length;i++)&#123;</span><br><span class="line">        let item = ary[i];</span><br><span class="line">        item &lt; middleValue ? aryLeft.push(item):aryRight.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    return quick(aryLeft).concat(middleValue,quick(aryRight));</span><br><span class="line">&#125;</span><br><span class="line">var ary = [1,25,23,2,61,22,35,99];</span><br><span class="line">console.log(ary);</span><br><span class="line">var result = quick(ary);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery源码解读（二）</title>
    <url>/2020/02/04/2020-02-04-jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89-md/</url>
    <content><![CDATA[<h3 id="jQuery实例对象"><a href="#jQuery实例对象" class="headerlink" title="jQuery实例对象"></a>jQuery实例对象</h3><blockquote>
<p>基于JQ选择器创建出来的是JQ类的一个实例，可以调取jQuery.prototype上的方法。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var version =  &quot;3.4.1&quot;,</span><br><span class="line">        jQuery = function (selector,context)&#123;</span><br><span class="line">            return new jQuery.fn.init(selector,context);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">var init = jQuery.fn.init = function(selector, context, root)&#123;</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init.prototype = jQuery.fn;</span><br><span class="line">//</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.创建出来的JQ实例是一个类数组（JQ对象）  基于 makeArray 创建出来的</p>
</blockquote>
<blockquote>
<p>2.selector 支持三种数据格式</p>
</blockquote>
<pre><code>1. [string]
    选择器      $(&apos;.box&apos;)
    创建元素    $(&apos;&lt;div&gt;...&lt;/div&gt;&apos;)
2.[元素对象：JS原生对象]
    把原生JS对象转化为JQ对象（只有这样才能调取JQ中的方法）
        var box = document.getElementById(&quot;box&quot;);
        $(&apos;box&apos;)
    把JQ对象转化为原生JS对象，直接基于索引获取即可，例如：$A[0]
        在项目中建议使用JQ中自带的get方法实现，因为它更完善，支持负数索引$A.get(0)
        eq方法也是根据索引集合中的某一项（也支持负数），只不过返回的结果不是原生JS而是JQ的实例
3.[function]
    $(function(){})     等待页面中的DOM结构加载完毕再执行函数，等价于$(document).ready(function(){})</code></pre><h4 id="makeArray"><a href="#makeArray" class="headerlink" title="makeArray"></a>makeArray</h4><blockquote>
<p>创建一个类数组的方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">makeArray:function(arr, results)&#123;</span><br><span class="line">    var ret = results || [];</span><br><span class="line">    </span><br><span class="line">    if(arr != null)&#123;</span><br><span class="line">        if(isArrayLike(object(arr)))&#123;</span><br><span class="line">            jQuery.merge(ret,typeof arr === &quot;string&quot; ? [arr] : arr);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            push.call(ret, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote>
<p>$(“.box”) === $(“.box”) =&gt;false 这是两个实例,引用地址不相同</p>
</blockquote>
<pre><code>所以操作的时候不要：
    $(&quot;box&quot;).css();
    $(&quot;box&quot;).attr();
    $(&quot;box&quot;).click();
正确的操作是：
    let $box = $(&quot;box&quot;);
    $box.css();
    $box.attr();
    $box.click();</code></pre>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>formatTime</title>
    <url>/2019/11/28/2019-11-28-formatTime-md/</url>
    <content><![CDATA[<h2 id="格式化时间字符串"><a href="#格式化时间字符串" class="headerlink" title="格式化时间字符串"></a>格式化时间字符串</h2><a id="more"></a>
<h3 id="实现一个不足两位补零函数"><a href="#实现一个不足两位补零函数" class="headerlink" title="实现一个不足两位补零函数"></a>实现一个不足两位补零函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let addZero = val =&gt; &#123;</span><br><span class="line">	val = Number(val);</span><br><span class="line">	return val &lt; 10 ? &apos;0&apos; + val : val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法一：基于String方法实现"><a href="#方法一：基于String方法实现" class="headerlink" title="方法一：基于String方法实现"></a>方法一：基于String方法实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let time = &apos;2019-11-28 12:0:0&apos;;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> *formatTime:格式化时间字符串</span><br><span class="line"> *  @params:time</span><br><span class="line"> *      未处理的时间字符串</span><br><span class="line"> *  @return:result</span><br><span class="line"> *      格式化处理的时间字符串</span><br><span class="line"> */</span><br><span class="line">function formatTime(time) &#123;</span><br><span class="line">	//1.获取年月日等信息</span><br><span class="line">	let ary = time.split(&apos; &apos;),</span><br><span class="line">		aryLeft = ary[0].split(&apos;-&apos;),</span><br><span class="line">		aryRight = ary[1].split(&apos;:&apos;);</span><br><span class="line">	ary = aryLeft.concat(aryRight);</span><br><span class="line">	//2.拼接字符串格式</span><br><span class="line">	let result = ary[0] + &apos;年&apos; + addZero(ary[1]) + &apos;月&apos; + addZero(ary[2]) + &apos;日&apos;;</span><br><span class="line">	result += &apos; &apos; + addZero(ary[3]) + &apos;:&apos; + addZero(ary[4]) + &apos;:&apos; + addZero(ary[5]);</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">let newTime = formatTime(time);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>容错性不好，当未处理的日期传入不完整时，会报错</p>
</blockquote>
<h3 id="方法二-基于时间对象处理"><a href="#方法二-基于时间对象处理" class="headerlink" title="方法二:基于时间对象处理"></a>方法二:基于时间对象处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function formatTime(time) &#123;</span><br><span class="line">	//1.把时间字符串转化为标准日期对象</span><br><span class="line">	time = time.replace(/-/g, &apos;/&apos;);</span><br><span class="line">	time = new Date(time);</span><br><span class="line">	//基于日期对象分别获取时间信息</span><br><span class="line">	let year = time.getFullYear(),</span><br><span class="line">		month = addZero(time.getMonth() + 1),</span><br><span class="line">		day = addZero(time.getDate()),</span><br><span class="line">		hours = addZero(time.getHours()),</span><br><span class="line">		minutes = addZero(time.getMinutes()),</span><br><span class="line">		second = addZero(time.getSeconds());</span><br><span class="line">	//格式化字符串</span><br><span class="line">	return year+&apos;年&apos;+month+&apos;月&apos;+day+&apos;日&apos;+&apos; &apos;+hours+&apos;:&apos;+minutes+&apos;:&apos;+second;</span><br><span class="line">&#125;</span><br><span class="line">let newTime = formatTime(time);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>容错性好，但是输出格式固定</p>
</blockquote>
<h3 id="方法三：公用时间字符串处理"><a href="#方法三：公用时间字符串处理" class="headerlink" title="方法三：公用时间字符串处理"></a>方法三：公用时间字符串处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.formatTime = function formatTime(template) &#123;</span><br><span class="line">	//初始化模板</span><br><span class="line">	typeof template === &apos;undefined&apos; ? template = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;:&#123;4&#125;:&#123;5&#125;&quot; : null;</span><br><span class="line">	//this:要处理的字符串</span><br><span class="line">	//获取日期字符串中的数字信息</span><br><span class="line">	let matchAry = this.match(/\d+/g);</span><br><span class="line">	//模板和数据的渲染</span><br><span class="line">	template = template.replace(/\&#123;(\d+)\&#125;/g, (x, y) =&gt; &#123;</span><br><span class="line">		let val = matchAry[y] || &apos;00&apos;;</span><br><span class="line">		val.length &lt; 2 ? val = &apos;0&apos; + val : null;</span><br><span class="line">		return val;</span><br><span class="line">	&#125;);</span><br><span class="line">	return template;</span><br><span class="line">&#125;</span><br><span class="line">console.log(time.formatTime());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基于模板和数据的渲染，能够按理想格式输出</p>
</blockquote>
]]></content>
      <categories>
        <category>JS函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>湖工二手go项目笔记</title>
    <url>/2020/03/29/2020-03-29-%E6%B9%96%E5%B7%A5%E4%BA%8C%E6%89%8Bgo%E9%A1%B9%E7%9B%AE-md/</url>
    <content><![CDATA[<h2 id="项目成果展示"><a href="#项目成果展示" class="headerlink" title="项目成果展示"></a>项目成果展示</h2><blockquote>
<p>项目说明：该项目用于毕业设计，未经同意不得转载</p>
</blockquote>
<a id="more"></a>

<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/df805e70-7191-11ea-b94e-47f67ecf8268.png" >
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/e5f7f290-7191-11ea-9e8b-05a3242b26f2.png" >

<h2 id="uni-app简介"><a href="#uni-app简介" class="headerlink" title="uni-app简介"></a>uni-app简介</h2><blockquote>
<p>uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台</p>
</blockquote>
<p><strong>uni-app的优势</strong></p>
<ul>
<li>开发者/案例数量多，跨端完善度高</li>
<li>平台能力不受限制<br>  在跨端的同时，通过条件编译+平台特有API调用，可以优雅的为某平台写个性化代码，调用专有能力而不影响其他平台</li>
<li>性能体验优秀<ul>
<li>体验更好的Hybrid框架，加载新页面速度更快</li>
<li>App端支持weex原生渲染，可支撑更流畅的用户体验</li>
<li>小程序端的性能优于市场其他框架</li>
</ul>
</li>
<li>周边生态丰富<ul>
<li>插件市场数千款插件</li>
<li>支持NPM、支持小程序组件和SDK、兼容mpvue组件和项目、兼容weex组件</li>
<li>微信生态的各种sdk可直接用于跨平台App</li>
</ul>
</li>
<li>学习成本低<br>  基于通用的前端技术栈，采用vue语法+微信小程序api，无额外学习成本</li>
<li>开发成本低<br>  不止开发成本，招聘、管理、测试各方面成本都大幅下降。</li>
</ul>
<p><strong>功能框架</strong></p>
<blockquote>
<p>uni-app在跨平台的过程中，不牺牲平台特色，可优雅的调用平台专有能力</p>
</blockquote>
<img src="https://img.cdn.aliyun.dcloud.net.cn/uni-app/doc/uni-app-frame-0310.png" >

<p><strong>选用uni-app做小程序的理由</strong></p>
<ul>
<li>性能测试：微信原生开发手工优化&gt;uni-app&gt;微信原生开发未手工优化&gt;taro &gt; wepy &gt; mpvue</li>
</ul>
<img src="http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/test-frame-13.png" >

<ul>
<li>微信那个IDE和专业编辑器相比实在不好用</li>
<li>vue生态里有太多周边工具，可以提高开发效率</li>
<li>原生开发对Node、预编译器、webpack支持不好，影响开发效率和工程构建流程</li>
</ul>
<p><strong>参考文献</strong><br>–<a href="https://uniapp.dcloud.io/README" target="_blank" rel="noopener">uni-app开发文档</a><br>–<a href="https://ask.dcloud.net.cn/article/35947" target="_blank" rel="noopener">小程序开发</a></p>
<h2 id="uniCloud简介"><a href="#uniCloud简介" class="headerlink" title="uniCloud简介"></a>uniCloud简介</h2><blockquote>
<p>uniCloud 是 DCloud 联合阿里云、腾讯云，为 uni-app 的开发者提供的基于 serverless 模式和 js 编程的云开发平台。uniCloud，在腾讯云、阿里云的 serverless 基础能力之上，实现了真正的跨端。让 uni-app 的开发者使用js开发一云多端的整套业务。并对云开发的功能扩展、开发体验做了很多强化，是下一代开发技术的典型代表。</p>
</blockquote>
<p><strong>开发和运行流程</strong></p>
<blockquote>
<p>开发过程，连接DCloud服务器；运行过程是手机端直连阿里云或腾讯云 serverless 环境，不通过DCloud服务器中转。</p>
</blockquote>
<ul>
<li>开发者在HBuilderX里为项目新建 uniCloud 云环境（可选择阿里云或腾讯云），在云函数目录下编写js代码，上传部署云函数到阿里云或腾讯云的 serverless 环境中。</li>
<li>前端代码通过<strong>uniCloud.callFunction()</strong>方法调用云函数。</li>
<li>云函数中可执行js运算、读写云化数据库（NoSQL）、读写存储和CDN、操作网络，给前端返回数据</li>
</ul>
<p><strong>云开发基础</strong></p>
<ul>
<li>云函数：在云端运行的js代码。运行在定制过的node环境中，有良好的性能和强大的功能。serverless环境无需自行加购服务器处理增容，云函数按量付费，不管多大的并发都扛得住</li>
<li>数据库：可在云函数中读写的、基于 NoSQL 的 JSON 数据库。这种数据库对于前端工程师更自然，不需要学习SQL、不需要理解关系型和设计主键。</li>
<li>存储和CDN：不管在前端还是云函数中，都可以操作存储和CDN。在uniCloud提供的安全机制下，可以实现应用前端直传CDN，避免服务器中转的耗时和带宽占用，且不会发生盗传。</li>
</ul>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/a6899f70-719e-11ea-8a36-ebb87efcf8c0.png" >

<p><strong>参考文献</strong><br>–<a href="https://uniapp.dcloud.io/uniCloud/README?id=unicloud-%e7%9a%84%e4%bb%b7%e5%80%bc" target="_blank" rel="noopener">uniCloud帮助文档</a></p>
<h2 id="前端环境搭建"><a href="#前端环境搭建" class="headerlink" title="前端环境搭建"></a>前端环境搭建</h2><blockquote>
<p>该项目采用的是 uni-app 加 uniCloud 的开发模式，也就是前端通过云函数调取云数据库中提供的JSON接口，让代码没有耦合。开发之前需要下载<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">微信开发者工具</a>进行调试</p>
</blockquote>
<ol>
<li><p>创建带uniCloud的uni-app项目（目前只支持使用HBuilder X创建uniCloud项目）</p>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/5ae43f90-71a2-11ea-9e8b-05a3242b26f2.png" >
</li>
<li><p>在 mainfest.json 微信小程序配置，微信小程序APPID（在微信开发者工具中申请获得），同时勾选 ES6转ES5 、 上传代码时样式自动补全 以及 上传代码时自动压缩。</p>
</li>
<li><p>在pages页面下创建目录index、community以及my文件夹同时分别在文件夹下创建同名vue文件、components组件文件夹。</p>
</li>
<li><p><a href="https://unicloud.dcloud.net.cn/login" target="_blank" rel="noopener">申请uniCloud</a>云开发账号（需要一天审核时间），审核通过即可创建uniCloud服务空间</p>
</li>
</ol>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/2f987000-71b5-11ea-b94e-47f67ecf8268.png" >

<ol start="5">
<li>创建完uniCloud服务空间，即可在项目中的 cloudfunctions目录中绑定uniCloud的服务空间</li>
</ol>
<h2 id="首页实现"><a href="#首页实现" class="headerlink" title="首页实现"></a>首页实现</h2><h3 id="搜索框-轮播图（search）组件"><a href="#搜索框-轮播图（search）组件" class="headerlink" title="搜索框+轮播图（search）组件"></a>搜索框+轮播图（search）组件</h3><p><strong>组件注册</strong></p>
<blockquote>
<p>创建 search.vue 并在 index.vue 中引入并注册 search组件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Search from &apos;./components/search&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    components:&#123; Search &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>搜索框</strong></p>
<blockquote>
<p>这里的 input 要设置 disabled 属性禁止input的默认点击事件，为后期制作一个单独的搜索页做准备。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 搜索框 --&gt;</span><br><span class="line">&lt;view class=&quot;search&quot;&gt;</span><br><span class="line">	&lt;view class=&quot;search-input&quot;&gt;</span><br><span class="line">		&lt;img src=&quot;../../../static/tab/sousuo.svg&quot; mode=&quot;widthFix&quot;&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; placeholder=&quot;请输入文字&quot; disabled /&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<p><strong>轮播组件</strong></p>
<blockquote>
<p>uni-app提供了swiper组件，这里列举几个常用的属性</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="right">类型</th>
<th align="right">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">indicator-dots</td>
<td align="right">Boolean</td>
<td align="right">false</td>
<td align="center">是否显示面板指示点</td>
</tr>
<tr>
<td align="left">indicator-color</td>
<td align="right">Color</td>
<td align="right">rgba(0, 0, 0, .3)</td>
<td align="center">指示点颜色</td>
</tr>
<tr>
<td align="left">indicator-active-color</td>
<td align="right">Color</td>
<td align="right">#000000</td>
<td align="center">当前选中的指示点颜色</td>
</tr>
<tr>
<td align="left">autoplay</td>
<td align="right">Boolean</td>
<td align="right">false</td>
<td align="center">是否自动切换</td>
</tr>
<tr>
<td align="left">interval</td>
<td align="right">Number</td>
<td align="right">5000</td>
<td align="center">自动切换时间间隔</td>
</tr>
<tr>
<td align="left">duration</td>
<td align="right">Number</td>
<td align="right">500</td>
<td align="center">滑动动画时长</td>
</tr>
<tr>
<td align="left">circular</td>
<td align="right">Boolean</td>
<td align="right">false</td>
<td align="center">是否采用衔接滑动</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 轮播组件 --&gt;</span><br><span class="line">&lt;swiper</span><br><span class="line">:indicator-dots=&quot;true&quot;</span><br><span class="line">:autoplay=&quot;true&quot;</span><br><span class="line">:interval=&quot;3000&quot;</span><br><span class="line">:duration=&quot;1000&quot;</span><br><span class="line">:circular=&quot;true&quot;</span><br><span class="line">indicator-color=&quot;rgba(255,255,255)&quot;</span><br><span class="line">indicator-active-color=&quot;#00ff00&quot;</span><br><span class="line">&gt;</span><br><span class="line">	&lt;swiper-item v-for=&quot;(item,index) in banner&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">		&lt;view class=&quot;swiper-item&quot; id=&quot;swiper-item&quot;&gt;</span><br><span class="line">			&lt;img :src=&quot;item.image&quot; class=&quot;img-url&quot; mode=&quot;aspectFill&quot;&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">	&lt;/swiper-item&gt;</span><br><span class="line">&lt;/swiper&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/liZhuTao/uniCloud/blob/master/pages/index/components/search.vue" target="_blank" rel="noopener">search组件完整代码</a></p>
<h3 id="轮播组件的数据上传到uniCloud"><a href="#轮播组件的数据上传到uniCloud" class="headerlink" title="轮播组件的数据上传到uniCloud"></a>轮播组件的数据上传到uniCloud</h3><p><strong>将数据上传至uniCloud云数据库</strong></p>
<blockquote>
<p>先将轮播的图片存储到云存储中,云存储会操作生成图片的地址</p>
</blockquote>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/229c9200-71bf-11ea-b997-9918a5dda011.png" >

<blockquote>
<p>创建banner集合，并上传数据（上传数据需要按照JSON的格式上传）</p>
</blockquote>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/76d99f80-71be-11ea-8bd0-2998ac5bbf7e.png" >

<h3 id="云函数操作数据库"><a href="#云函数操作数据库" class="headerlink" title="云函数操作数据库"></a>云函数操作数据库</h3><blockquote>
<p>uniCloud中不允许前端直接调用云数据库中的数据，必须通过云函数来调用并返回给前端，前端用<a href="https://uniapp.dcloud.io/uniCloud/cf-functions?id=%e5%ae%a2%e6%88%b7%e7%ab%af%e8%b0%83%e7%94%a8%e4%ba%91%e5%87%bd%e6%95%b0" target="_blank" rel="noopener">uniCloud.callFunction</a>调用云函数，并接收返回结果</p>
</blockquote>
<p><strong>创建云函数</strong></p>
<blockquote>
<p>右键cloudfunction文件夹，选择新建云函数getData</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">//获取数据库</span><br><span class="line">const db = uniCloud.database();</span><br><span class="line"></span><br><span class="line">exports.main = async (event, context) =&gt; &#123;</span><br><span class="line">  //event为客户端上传的参数(用户要以对象的形式上传数据)</span><br><span class="line">  let list = event.list                     //list为前端传来的要操作的集合名称</span><br><span class="line">  const banner = db.collection(list)		// 获取集合的引用</span><br><span class="line">  const res = await banner.get()</span><br><span class="line">  //返回数据给客户端</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建完云函数后，右键getData文件夹，选择上传并运行 就可以将云函数上传并部署到uniCloud服务空间上（注意在IDE中运行，云函数可能会报错或者event返回空对象，先将项目运行到微信小程序上，再到<a href="https://unicloud.dcloud.net.cn/" target="_blank" rel="noopener">uniCloud</a>中找到对应的云函数，打开日志，在前端触发一下云函数，在看是否会报错或者event为空）</p>
</blockquote>
<p><strong>前端操作云函数</strong></p>
<blockquote>
<p>在项目根目录中创建 common公共组件目录，并在其中创建一个的公共组件cloudFun，用于获取与函数返回的数据库信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let getData = function(list) &#123;</span><br><span class="line">	let mylist = list</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		uniCloud.callFunction(&#123;</span><br><span class="line">				name: &apos;getData&apos;,</span><br><span class="line">				data: &#123;</span><br><span class="line">					&quot;list&quot;: mylist		//前端通过data对象将数据传给云函数</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">			.then(res =&gt; &#123;</span><br><span class="line">				resolve(res)</span><br><span class="line">			&#125;)</span><br><span class="line">			.catch(err =&gt; &#123;</span><br><span class="line">				reject(err)</span><br><span class="line">			&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; getData &#125;		//将函数导出</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/liZhuTao/uniCloud/blob/master/common/cloudFun.js" target="_blank" rel="noopener">cloudFun源码</a></p>
<blockquote>
<p>在index.vue中的 created 生命周期中<strong>获取数据</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;getData&#125; from &apos;../../common/cloudFun.js&apos;		//操作数据库组件</span><br><span class="line">export default&#123;</span><br><span class="line">	data()&#123;</span><br><span class="line">   		return &#123; banner:[] &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	created()&#123;</span><br><span class="line">    	//请求数据</span><br><span class="line">    	let banner = &quot;banner&quot;</span><br><span class="line">    	getData(banner)</span><br><span class="line">    	.then(res=&gt;&#123;</span><br><span class="line">    	    this.banner = res.result.data</span><br><span class="line">    	&#125;)</span><br><span class="line">    	.catch(err=&gt;&#123;</span><br><span class="line">    	    console.log(err)</span><br><span class="line">    	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将数据传给search组件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Search :banner=&quot;banner&quot;&gt;&lt;/Search&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在search中接收数据,就可以直接将数据遍历到轮播图</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">	name:&apos;search&apos;,</span><br><span class="line">	props:&#123;</span><br><span class="line">		banner:Array</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分类导航（ticket）组件"><a href="#分类导航（ticket）组件" class="headerlink" title="分类导航（ticket）组件"></a>分类导航（ticket）组件</h3><blockquote>
<p>首先在根目录下创建一个<a href="https://github.com/liZhuTao/uniCloud/tree/master/static" target="_blank" rel="noopener">static</a>文件夹用于存储静态文件（同样也可以放在云存储中），在static文件夹下创建tab文件夹来存储首页需要的图片<br><strong>ticket.vue</strong><br>创建完成后再index.vue的components中注册才能使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">		&lt;!-- 分类导航 --&gt;</span><br><span class="line">		&lt;view class=&quot;sort&quot;&gt;</span><br><span class="line">			&lt;view class=&quot;sort-item&quot; v-for=&quot;(item,index) in sortList&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">				&lt;img :src=&quot;item.image&quot;&gt;</span><br><span class="line">				&lt;text&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default&#123;</span><br><span class="line">		name:&apos;ticket&apos;,</span><br><span class="line">		data()&#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				sortList:[</span><br><span class="line">					&#123;image:require(&quot;../../../static/tab/man.png&quot;),name:&quot;男装&quot;&#125;,</span><br><span class="line">					&#123;image:require(&quot;../../../static/tab/weman.png&quot;),name:&quot;女装&quot;&#125;,</span><br><span class="line">					&#123;image:require(&quot;../../../static/tab/book.png&quot;),name:&quot;书籍&quot;&#125;,</span><br><span class="line">					&#123;image:require(&quot;../../../static/tab/life.png&quot;),name:&quot;生活&quot;&#125;,</span><br><span class="line">					&#123;image:require(&quot;../../../static/tab/phone.png&quot;),name:&quot;电子&quot;&#125;</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">	.sort&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		flex-direction: row;</span><br><span class="line">		flex-wrap: nowrap;</span><br><span class="line">		justify-content: space-between;</span><br><span class="line">		align-items: center;</span><br><span class="line">		margin: 30upx 30upx;</span><br><span class="line">	&#125;</span><br><span class="line">	.sort-item&#123;&#125;</span><br><span class="line">	.sort-item img&#123;</span><br><span class="line">		width: 90upx;</span><br><span class="line">		height: 90upx;</span><br><span class="line">	&#125;</span><br><span class="line">	.sort text&#123;</span><br><span class="line">		font-size: 30upx;</span><br><span class="line">		display: block;</span><br><span class="line">		margin-left: 15upx;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="小分类（classify）组件"><a href="#小分类（classify）组件" class="headerlink" title="小分类（classify）组件"></a>小分类（classify）组件</h3><blockquote>
<p>创建完成后再index.vue的components中注册才能使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view style=&quot;margin: 0 20upx;&quot;&gt;</span><br><span class="line">		&lt;view class=&quot;notice&quot;&gt;</span><br><span class="line">			&lt;view v-for=&quot;(item,index) in noticeList&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">				&lt;text class=&quot;notice-title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt;</span><br><span class="line">				&lt;text class=&quot;notice-describe&quot;&gt;&#123;&#123;item.describe&#125;&#125;&lt;/text&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default&#123;</span><br><span class="line">		name:&apos;classify&apos;,</span><br><span class="line">		data()&#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				noticeList:[</span><br><span class="line">					&#123;title:&quot;标题1&quot;,describe:&quot;描述1&quot;&#125;,</span><br><span class="line">					&#123;title:&quot;标题2&quot;,describe:&quot;描述2&quot;&#125;,</span><br><span class="line">					&#123;title:&quot;标题3&quot;,describe:&quot;描述3&quot;&#125;,</span><br><span class="line">					&#123;title:&quot;标题4&quot;,describe:&quot;描述4&quot;&#125;,</span><br><span class="line">					&#123;title:&quot;标题5&quot;,describe:&quot;描述5&quot;&#125;,</span><br><span class="line">					&#123;title:&quot;标题6&quot;,describe:&quot;描述6&quot;&#125;,</span><br><span class="line">					&#123;title:&quot;标题7&quot;,describe:&quot;描述7&quot;&#125;,</span><br><span class="line">					&#123;title:&quot;标题8&quot;,describe:&quot;描述8&quot;&#125;,</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>–<a href="https://github.com/liZhuTao/uniCloud/blob/master/pages/index/components/classify.vue" target="_blank" rel="noopener">classify组件源码</a></p>
<h3 id="导航（content）组件"><a href="#导航（content）组件" class="headerlink" title="导航（content）组件"></a>导航（content）组件</h3><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/9e820e80-7238-11ea-b94e-47f67ecf8268.png">
**布局**
> [scroll-view](https://uniapp.dcloud.io/component/scroll-view?id=scroll-view)是uni-app中自带的滚动视图组件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">		&lt;scroll-view scroll-x=&quot;true&quot; class=&quot;scroll&quot; scroll-with-animation=&quot;true&quot;&gt;</span><br><span class="line">			&lt;view v-for=&quot;(item,index) in tab&quot; :key=&quot;index&quot; class=&quot;list-cont&quot; @click=&quot;clickTabs(index,item.nav)&quot;&gt;</span><br><span class="line">				&lt;view :class=&quot;&#123;active: index== num&#125;&quot;&gt;</span><br><span class="line">					&lt;view&gt;</span><br><span class="line">						&lt;text class=&quot;con-text-a&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt;</span><br><span class="line">					&lt;/view&gt;</span><br><span class="line">					&lt;view&gt;</span><br><span class="line">						&lt;text class=&quot;con-text-b&quot; :class=&quot;&#123;activeb: index== num&#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt;</span><br><span class="line">					&lt;/view&gt;</span><br><span class="line">				&lt;/view&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">		&lt;/scroll-view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
> click点击事件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">	name:&quot;content&quot;,</span><br><span class="line">	data()&#123;</span><br><span class="line">			return&#123;</span><br><span class="line">				num: 0,</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		clickTabs(index,nav)&#123;</span><br><span class="line">			this.num = index;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="商品（article）组件"><a href="#商品（article）组件" class="headerlink" title="商品（article）组件"></a>商品（article）组件</h3><p><strong>布局</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view class=&quot;active&quot;&gt;</span><br><span class="line">			&lt;view class=&quot;conteng&quot;&gt;</span><br><span class="line">				&lt;block v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">				&lt;view class=&quot;conteng-article&quot;&gt;</span><br><span class="line">					&lt;view  class=&quot;conteng-img&quot;&gt;</span><br><span class="line">					&lt;image :src=&quot;item.image&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt;	</span><br><span class="line">					&lt;/view&gt;</span><br><span class="line">					&lt;!-- 文字介绍 --&gt;</span><br><span class="line">					&lt;view class=&quot;active-introduce&quot;&gt;</span><br><span class="line">						&lt;view class=&quot;active-name&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class="line">						&lt;view class=&quot;active-title&quot;&gt;&#123;&#123;item.list&#125;&#125;&lt;/view&gt;</span><br><span class="line">						&lt;view class=&quot;active-label&quot;&gt;&#123;&#123;item.label&#125;&#125;&lt;/view&gt;</span><br><span class="line">						&lt;view class=&quot;purchase&quot;&gt;</span><br><span class="line">							&lt;text class=&quot;active-price&quot;&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/text&gt;</span><br><span class="line">							&lt;text class=&quot;active-purchase&quot;&gt;&#123;&#123;item.buy&#125;&#125;人想买&lt;/text&gt;</span><br><span class="line">						&lt;/view&gt;</span><br><span class="line">					&lt;/view&gt;</span><br><span class="line">				&lt;/view&gt;</span><br><span class="line">				&lt;/block&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">		&lt;/view&gt; </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="导航-商品获取数据"><a href="#导航-商品获取数据" class="headerlink" title="导航+商品获取数据"></a>导航+商品获取数据</h3><p><strong>上传数据</strong></p>
<blockquote>
<p>在<a href="https://unicloud.dcloud.net.cn/" target="_blank" rel="noopener">uniCloud</a>云数据库中创建tab和recommend集合并将导航栏信息和商品信息上传上去（详细操作请参照 5.2.轮播组件的数据上传到uniCloud ）</p>
</blockquote>
<p><strong>导航获取数据</strong></p>
<blockquote>
<p>导航通过 getData()获取相应数据（详细操作请参照 5.3.云函数操作数据库 ）</p>
</blockquote>
<p><strong>商品获取数据</strong></p>
<blockquote>
<ol>
<li>在cloudfunction中新建云函数getGoods，在getGoods下的index.js中编写以下代码</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">//获取数据库</span><br><span class="line">const db = uniCloud.database();</span><br><span class="line"></span><br><span class="line">exports.main = async (event, context) =&gt; &#123;</span><br><span class="line">  //event为客户端上传的参数</span><br><span class="line">  let list = event.list</span><br><span class="line">  let pageid = event.pageid</span><br><span class="line">  const banner = db.collection(list)		// 获取集合的引用</span><br><span class="line">  .limit(6)  		//开始拉取数据的数量</span><br><span class="line">  .skip(pageid*6)   //拉取数据的索引(每次下拉加载6条数据)</span><br><span class="line">  const res = await banner.get()</span><br><span class="line">  //返回数据给客户端</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>在common中的cloudFun中添加以下代码</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let getGoods = function(list,pageid) &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		uniCloud.callFunction(&#123;</span><br><span class="line">				name: &apos;getGoods&apos;,</span><br><span class="line">				data: &#123;</span><br><span class="line">					&quot;list&quot;: list,		//list用于指定操作的集合名称</span><br><span class="line">					&quot;pageid&quot;:pageid		//pageid用于获取数据数量的标识</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">			.then(res =&gt; &#123;</span><br><span class="line">				resolve(res)</span><br><span class="line">			&#125;)</span><br><span class="line">			.catch(err =&gt; &#123;</span><br><span class="line">				reject(err)</span><br><span class="line">			&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; getGoods &#125;		//将函数导出</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="3">
<li>改写index.vue中created()生命周期函数中的代码，使用Promise.all同时获取轮播图、导航栏、商品信息</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">	//请求数据</span><br><span class="line">	let banner = &quot;banner&quot;</span><br><span class="line">	let tab = &quot;tab&quot;</span><br><span class="line">	let lising = &quot;recommend&quot;</span><br><span class="line">	//基于promise.all 批量接受多个接口，同时得到多个数据</span><br><span class="line">	Promise.all([getData(banner),getData(tab),getGoods(lising,this.pageid)])</span><br><span class="line">	.then(res=&gt;&#123;</span><br><span class="line">		this.banner = res[0].result.data		//轮播数据</span><br><span class="line">		this.tab = res[1].result.data			//tab数据</span><br><span class="line">		this.list = res[2].result.data			//推荐数据</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(err=&gt;&#123;</span><br><span class="line">		console.log(err)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="4">
<li>组件接收数据</li>
</ol>
<p>– index.vue</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Content id=&quot;boxFixed&quot; :class=&quot;&#123;is_fixed:isFixed&#125;&quot; :tab=&quot;tab&quot;&gt;&lt;/Content&gt;</span><br><span class="line">&lt;view style=&quot;height: 140upx;&quot;&gt;&lt;/view&gt;		//防止导航组件飘在商品组件上</span><br><span class="line">&lt;Article :list=&quot;list&quot; v-if=&quot;!loadinglist&quot;&gt;&lt;/Article&gt;</span><br></pre></td></tr></table></figure>
<p>– 组件中使用props接收数据，上面操作过这里不在过多赘述</p>
<h3 id="增加用户体验的自定义组件"><a href="#增加用户体验的自定义组件" class="headerlink" title="增加用户体验的自定义组件"></a>增加用户体验的自定义组件</h3><blockquote>
<p>首先在项目根目录下创建element文件夹用于存放自定义的组件</p>
</blockquote>
<ol>
<li><strong>tab切换的loading组件</strong><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/4350e4b0-724b-11ea-8bd0-2998ac5bbf7e.gif">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view class=&quot;loading&quot;&gt;</span><br><span class="line">		&lt;view class=&quot;loader&quot;&gt;&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">	.loading&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		justify-content: center;</span><br><span class="line">		padding: 20upx 0;</span><br><span class="line">	&#125;</span><br><span class="line">	.loader&#123;</span><br><span class="line">		display: inline-block;</span><br><span class="line">		width: 40upx;</span><br><span class="line">		height: 40upx;</span><br><span class="line">		color: inherit;</span><br><span class="line">		border: 7upx solid greenyellow;</span><br><span class="line">		border-bottom-color: transparent;</span><br><span class="line">		border-radius: 50%;</span><br><span class="line">		animation: 1s loader linear infinite;</span><br><span class="line">	&#125;</span><br><span class="line">	/* 360度旋转 */</span><br><span class="line">	@keyframes loader&#123;</span><br><span class="line">		0%&#123;</span><br><span class="line">			transform: rotate(0deg);</span><br><span class="line">		&#125;</span><br><span class="line">		100%&#123;</span><br><span class="line">			transform: rotate(360deg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>没有数据时的提示</strong><blockquote>
<p>图片是从飞猪旅游的手机端复制过来的</p>
</blockquote>
</li>
</ol>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/29ec6d30-724d-11ea-8a36-ebb87efcf8c0.png">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view class=&quot;nonedata&quot;&gt;</span><br><span class="line">		&lt;img src=&quot;../static/tab/noimage.png&quot; mode=&quot;widthFix&quot;&gt;</span><br><span class="line">		&lt;text&gt;主人，这里什么都没有&lt;/text&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">	.nonedata&#123;</span><br><span class="line">		text-align: center;</span><br><span class="line">	&#125;</span><br><span class="line">	.nonedata img&#123;</span><br><span class="line">		width: 200upx;</span><br><span class="line">		height: 200upx;</span><br><span class="line">	&#125;</span><br><span class="line">	.nonedata text&#123;</span><br><span class="line">		display: block;</span><br><span class="line">		font-size: 30upx;</span><br><span class="line">		color: rgb(153,153,153);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>进入小程序时loading加载</strong></li>
</ol>
<blockquote>
<p>页面还未完全获取数据时显示进入页面的loading加载</p>
</blockquote>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/ee8f2bf0-724d-11ea-b244-a9f5e5565f30.png" >

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view class=&quot;loadmin&quot;&gt;</span><br><span class="line">		&lt;view class=&quot;home-load&quot;&gt;</span><br><span class="line">			&lt;image src=&quot;../static/tab/homeload.svg&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">	.home-load&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		align-items: center;</span><br><span class="line">		justify-content: center;</span><br><span class="line">		width: 100%;</span><br><span class="line">		height: 100%;</span><br><span class="line">	&#125;</span><br><span class="line">	.home-load image&#123;</span><br><span class="line">		width: 200upx;</span><br><span class="line">		height: 200upx;</span><br><span class="line">		background: rgba(0,0,0,0.2);</span><br><span class="line">		border-radius: 10upx;</span><br><span class="line">	&#125;</span><br><span class="line">	.loadmin&#123;</span><br><span class="line">		position: fixed;</span><br><span class="line">		top: 0;</span><br><span class="line">		bottom: 0;</span><br><span class="line">		left: 0;</span><br><span class="line">		right: 0;</span><br><span class="line">		z-index: 9999;</span><br><span class="line">		overflow: hidden;</span><br><span class="line">		background: rgba(242,243,244,0.6);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>全局引入自定义组件</strong></li>
</ol>
<blockquote>
<p>在项目根目录中的<a href="https://github.com/liZhuTao/uniCloud/blob/master/main.js" target="_blank" rel="noopener">main.js</a>中添加以下代码,就可以在项目中使用组件了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import App from &apos;./App&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">//引用tab切换的loading</span><br><span class="line">import loader from &apos;./element/loading.vue&apos;</span><br><span class="line">Vue.component(&apos;load-list&apos;,loader)</span><br><span class="line"></span><br><span class="line">//引入没有数据的提示</span><br><span class="line">import nonedata from &apos;./element/none.vue&apos;</span><br><span class="line">Vue.component(&apos;none-data&apos;,nonedata)</span><br><span class="line"></span><br><span class="line">//进入页面的loading加载</span><br><span class="line">import homeload from &apos;./element/homeload.vue&apos;</span><br><span class="line">Vue.component(&apos;home-load&apos;,homeload)</span><br><span class="line"></span><br><span class="line">App.mpType = &apos;app&apos;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    ...App</span><br><span class="line">&#125;)</span><br><span class="line">app.$mount()</span><br></pre></td></tr></table></figure>
<p>– index.vue的template，loadinglist、homeload、nonedata用于管理组件状态，为后面的vuex使用做准备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;load-list v-if=&quot;loadinglist&quot;&gt;&lt;/load-list&gt;</span><br><span class="line">&lt;Article :list=&quot;list&quot; v-if=&quot;!loadinglist&quot;&gt;&lt;/Article&gt;</span><br><span class="line">&lt;!-- 进入页面的loading加载 --&gt;</span><br><span class="line">&lt;home-load v-if=&quot;homeload&quot;&gt;&lt;/home-load&gt;</span><br><span class="line">&lt;!-- 没有数据的提示 --&gt;</span><br><span class="line">&lt;none-data v-if=&quot;nonedata&quot;&gt;&lt;/none-data&gt;</span><br></pre></td></tr></table></figure>

<h3 id="vuex状态管理"><a href="#vuex状态管理" class="headerlink" title="vuex状态管理"></a>vuex状态管理</h3><blockquote>
<p><a href="https://lizhutao.github.io/2020/03/30/2020-03-30-vuex-md/" target="_blank" rel="noopener">Vuex</a>是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>
<ol>
<li><p>首先在在pages中创建一个store文件夹，并在其中创建一个同名的js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//导入vuex</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>store.js</code>创建中state</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//首页tab切换传输的值</span><br><span class="line">const alist=&#123;</span><br><span class="line">	listing:[]</span><br><span class="line">&#125;</span><br><span class="line">//tab切换状态</span><br><span class="line">const load = &#123;</span><br><span class="line">	loading:&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const navmin=&#123;</span><br><span class="line">	loading:&apos;&apos;,</span><br><span class="line">	naving:&apos;recomment&apos;,</span><br><span class="line">	pageid:0,</span><br><span class="line">	uniload:&apos;&apos;,</span><br><span class="line">	nonedata:&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const state = &#123;</span><br><span class="line">	alist,</span><br><span class="line">	load,</span><br><span class="line">	navmin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>store.js</code>创建中mutation</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">	state,</span><br><span class="line">	//同步操作</span><br><span class="line">	mutations:&#123;</span><br><span class="line">		listmuta(state,listdata)&#123;</span><br><span class="line">			state.alist = &#123;</span><br><span class="line">				listing:listdata</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		//tab切换的loading状态</span><br><span class="line">		loadmuat(state,loading)&#123;</span><br><span class="line">			state.load = &#123;</span><br><span class="line">				loading:loading</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		//以对象传过来的参数</span><br><span class="line">		navmuta(state,pullobj)&#123;</span><br><span class="line">			state.navmin = &#123;</span><br><span class="line">				loading:pullobj.loading,</span><br><span class="line">				naving:pullobj.nav,</span><br><span class="line">				pageid:pullobj.pageid,</span><br><span class="line">				uniload:pullobj.uniload,</span><br><span class="line">				nonedata:pullobj.nonedata</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		//tab切换没有数据的提示</span><br><span class="line">		nonemuta(state,noneion)&#123;</span><br><span class="line">			console.log(noneion)</span><br><span class="line">			state.nonemin = &#123;</span><br><span class="line">				nonedata:noneion</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>index.vue</code>中的computed属性中使用<code>...mapState</code>取出vuex数据仓库中的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">	//取出vuex数据仓库的数据</span><br><span class="line">	...mapState([&apos;alist&apos;,&apos;load&apos;,&apos;navmin&apos;,&apos;nonemin&apos;])</span><br><span class="line"></span><br><span class="line">	//code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取到vuex数据仓库中的数据之后，将数据复制到对应的data数据中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//tab切换传值</span><br><span class="line">count()&#123;</span><br><span class="line">	this.list = this.alist.listing</span><br><span class="line">&#125;,</span><br><span class="line">//tab切换时load的状态</span><br><span class="line">countload()&#123;</span><br><span class="line">	this.loadinglist = this.load.loading</span><br><span class="line">&#125;,</span><br><span class="line">//以对象传值</span><br><span class="line">navdata()&#123;</span><br><span class="line">	this.loadinglist = this.navmin.loading</span><br><span class="line">	this.nav = this.navmin.naving</span><br><span class="line">	this.pageid = this.navmin.pageid</span><br><span class="line">	this.loadmore = this.navmin.uniload</span><br><span class="line">	this.nonedata = this.navmin.nonedata</span><br><span class="line">&#125;,</span><br><span class="line">//当tab没有数据的状态</span><br><span class="line">noneted()&#123;</span><br><span class="line">	this.nonedata = this.nonemin.nonedata</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将状态动态的绑定到组件上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;load-list v-if=&quot;loadinglist&quot;&gt;&lt;/load-list&gt;</span><br><span class="line">&lt;Article :list=&quot;list&quot; v-if=&quot;!loadinglist&quot;&gt;&lt;/Article&gt;</span><br><span class="line">&lt;!-- 进入页面的loading加载 --&gt;</span><br><span class="line">&lt;home-load v-if=&quot;homeload&quot;&gt;&lt;/home-load&gt;</span><br><span class="line">&lt;!-- 没有数据的提示 --&gt;</span><br><span class="line">&lt;none-data v-if=&quot;nonedata&quot;&gt;&lt;/none-data&gt;</span><br><span class="line">&lt;!-- 上拉加载组件 --&gt;</span><br><span class="line">&lt;view class=&quot;load-more&quot; v-if=&quot;loadmore&quot;&gt;</span><br><span class="line">	&lt;uni-load-more :status=&quot;uniload&quot; color=&quot;#ffcc99&quot;&gt;&lt;/uni-load-more&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="社区页"><a href="#社区页" class="headerlink" title="社区页"></a>社区页</h2><p>社区页是大部分用户活动的重要场所，普通用户可以在社区中发布自己的商品或者动态，就避免了需要商家认证之后才可以上传商品，不过在社区之中的交易模式不通过平台，用户可以在选定商品之后，私下联系商家进行交易，这样设定有利于校园之间的文化交流。</p>
<p>社区页我们在设计的时候将它分为三个模块来进行开发，分别是是顶部的定位栏加上搜索栏，中间导航加上商品展示，以及底部的发布栏这三个组件。</p>
<p>在根目录中的pages文件夹中新建一个页面名为strategy它会默认在里面创建一个同名的vue文件。</p>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>我们在进入社区页之前要进行实时的定位，在定位完成之后就会展现出对应地区上的数据，当然这里我们也可以选择拒绝定位，这个时候默认定位会显示在湖南工程学院上，并将湖南工程学院中的数据加载出来。在这里我们使用的定位功能是腾讯地图开放平台。首先我们需要在浏览器中打开腾讯地图开放平台的官网（<a href="https://lbs.qq.com/），然后在开发文档中找到微信小程序JavaScript" target="_blank" rel="noopener">https://lbs.qq.com/），然后在开发文档中找到微信小程序JavaScript</a> SDK点击进入之后，我们需要按照以下步骤来在小程序中使用位置服务。</p>
<ol>
<li>申请开发者密钥（key）</li>
<li>开通webserviceAPI服务：控制台 -&gt; key管理 -&gt; 设置（使用该功能的key）-&gt; 勾选webserviceAPI -&gt; 保存 (小程序SDK需要用到webserviceAPI的部分服务，所以使用该功能的KEY需要具备相应的权限)</li>
<li>下载微信小程序JavaScriptSDK</li>
<li>安全域名设置，在“设置” -&gt; “开发设置”中设置request合法域名，添加<a href="https://apis.map.qq.com" target="_blank" rel="noopener">https://apis.map.qq.com</a></li>
<li>最后我们就可以根据文档使用腾讯位置服务了</li>
</ol>
<blockquote>
<p>首先我们需要将下载下来的微信小程序JavaScriptSDK复制到根目录下的common文件夹下，然后在strategy.vue中引入腾讯地图SDK核心类。这样我们就可以直接在前端中使用腾讯地图为我们提供的位置服务了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var QQMapWX = require(&apos;../../common/qqmap-wx-jssdk.js&apos;);</span><br><span class="line">var qqmapsdk;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再次之前我们需要在uni-app中配置一下获取位置信息的环境，可以在根目录下的pages.json配置文件的最后加上以下代码进行配置。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;permission&quot;: &#123;</span><br><span class="line">	&quot;scope.userLocation&quot;: &#123;</span><br><span class="line">		&quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在配置好环境之后，我们就可以对客户端中的定位组件进行代码编写以及样式布局了，首先我们需要在strategy文件夹下新建一个components文件夹来存放组件，并在里面新建address.vue组件，并编写代码，template模板以及样式布局的代码如下。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">		&lt;view class=&quot;address&quot;&gt;</span><br><span class="line">			&lt;view class=&quot;address-img&quot;&gt;</span><br><span class="line">				&lt;image src=&quot;https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3628832208,3170804138&amp;fm=26&amp;gp=0.jpg&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">			&lt;view class=&quot;address-list&quot;&gt;</span><br><span class="line">				&lt;view class=&quot;address-text&quot; @click=&quot;chooseCity()&quot;&gt;</span><br><span class="line">					&lt;text class=&quot;words&quot;&gt;&#123;&#123;address&#125;&#125;&lt;/text&gt;</span><br><span class="line">					&lt;image src=&quot;../../../static/tab/jiantouxia.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;</span><br><span class="line">				&lt;/view&gt;</span><br><span class="line">				&lt;text class=&quot;words-eng&quot;&gt;welcome&lt;/text&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">			&lt;!-- 搜索框 --&gt;</span><br><span class="line">			&lt;view class=&quot;search&quot;&gt;</span><br><span class="line">				&lt;view class=&quot;search-input&quot; @click=&quot;searchPage()&quot;&gt;</span><br><span class="line">					&lt;img src=&quot;../../../static/tab/sousuo.svg&quot; mode=&quot;widthFix&quot;&gt;</span><br><span class="line">					&lt;input type=&quot;text&quot; placeholder=&quot;请输入文字&quot; disabled /&gt;</span><br><span class="line">				&lt;/view&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">			&lt;!-- 阴影 --&gt;</span><br><span class="line">			&lt;view class=&quot;back&quot;&gt;&lt;/view&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.address-text &#123;display: flex; align-items: center;&#125;</span><br><span class="line">.address-text image &#123;width: 33upx;height: 33upx;padding-left: 30upx;&#125;</span><br><span class="line">.address &#123;position: relative;height: 400upx;&#125;</span><br><span class="line">.address-list &#123;position: absolute;left: 50upx;top: 100upx;z-index: 999;&#125;</span><br><span class="line">.address-img &#123;width: 100%;height: 400upx;&#125;</span><br><span class="line">.address-img image &#123;width: 750rpx !important; height: 400upx;&#125;</span><br><span class="line">.words &#123;font-size: 50upx;	color: #ffffff;font-weight: bold;&#125;</span><br><span class="line">.words-eng &#123; font-size: 30upx; color: #ffffff;&#125;</span><br><span class="line">.back &#123;background: rgba(0, 51, 0, 0.3); position:  absolute; top: 0; left: 0; height: 400upx; width: 100%;&#125;</span><br><span class="line">/* 搜索 */</span><br><span class="line">.search&#123; position:  absolute ;left: 0upx; right: 0; bottom: 15upx; padding: 30upx 0;</span><br><span class="line">		z-index: 999;&#125;</span><br><span class="line">.search-input&#123;height: 70upx;	line-height: 70upx;width: 650upx;	margin: 0 50upx;</span><br><span class="line">display: flex;border-radius: 50upx;flex-direction: row;background-color: #FFFFFF;&#125;</span><br><span class="line">	.search-input img&#123;width: 40upx;height: 40upx;margin: auto 0 auto 20upx;	&#125;</span><br><span class="line">	.search-input input&#123;width: 100%;height: 70upx;	line-height: 70upx;font-size: 30upx;</span><br><span class="line">		color: #666666;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/d6c1fc50-95e8-11ea-9e8b-05a3242b26f2.jpg">

<blockquote>
<p>当我们点击点定位的地址或者箭头的时候，会跳转到选择位置的页面，在这里我们给它绑定一个点击事件触发chooseCity()方法，实现当我们点击文字的时候会跳转到定位页面，来进行地址选择。在这里我们可以使用uni-app给我们提供的跳转页面的方法uni.navigateTo()来实现。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//选择城市</span><br><span class="line">chooseCity()&#123;</span><br><span class="line">	uni.navigateTo(&#123;</span><br><span class="line">		url:&apos;../city/city&apos;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来我们就可以在pages文件夹下新建一个页面并命名为city,这样我们就可以在city下的同名vue文件中编写代码，对选择地区页面进行布局。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">		&lt;!--搜索城市 --&gt;</span><br><span class="line">		&lt;view class=&quot;margin-search&quot;&gt;</span><br><span class="line">			&lt;view class=&quot;search-cont&quot;&gt;</span><br><span class="line">				&lt;view class=&quot;city-search&quot;&gt;</span><br><span class="line">					&lt;image src=&quot;../../static/tab/sousuo.svg&quot; mode=&quot;widthFix&quot; class=&quot;search-img&quot;&gt;&lt;/image&gt;</span><br><span class="line">					&lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot; placeholder=&quot;发现你感兴趣的目的地&quot; @focus=&quot;searchCity&quot; @input=&quot;searchInput&quot;/&gt;</span><br><span class="line">				&lt;/view&gt;</span><br><span class="line">				&lt;view class=&quot;search-code&quot; v-if=&quot;!citynone&quot; @click=&quot;canCal&quot;&gt;&lt;image src=&quot;../../static/tab/chaa.svg&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;&lt;/view&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">		&lt;!-- 点击搜索隐藏 --&gt;</span><br><span class="line">		&lt;view v-if=&quot;citynone&quot;&gt;</span><br><span class="line">			&lt;!-- 定位城市 --&gt;</span><br><span class="line">			&lt;view class=&quot;city-view&quot;&gt;</span><br><span class="line">				&lt;view class=&quot;city-text&quot;&gt;当前定位&lt;/view&gt;</span><br><span class="line">				&lt;view class=&quot;posit-city&quot;&gt;</span><br><span class="line">					&lt;image src=&quot;../../static/tab/gonglveb.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;</span><br><span class="line">					&lt;text class=&quot;city-text&quot; @click=&quot;clickCity&quot;&gt;&#123;&#123;address&#125;&#125;&lt;/text&gt;</span><br><span class="line">				&lt;/view&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">			&lt;!-- 热门城市 --&gt;</span><br><span class="line">			&lt;view class=&quot;hot-city&quot;&gt;热门搜索&lt;/view&gt;</span><br><span class="line">			&lt;view class=&quot;menu-block&quot;&gt;</span><br><span class="line">				&lt;block v-for=&quot;(item, index) in city&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">					&lt;view @click=&quot;hotCity(item.name)&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/view&gt;</span><br><span class="line">				&lt;/block&gt;</span><br><span class="line">			&lt;/view&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">		&lt;!-- 显示搜索的城市 --&gt;</span><br><span class="line">		&lt;view class=&quot;results&quot; v-if=&quot;!citynone&quot;&gt;</span><br><span class="line">			&lt;block v-for=&quot;(item, index) in citydata&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">				&lt;view class=&quot;results-city&quot; @click=&quot;seekCity(item)&quot;&gt;</span><br><span class="line">					&lt;image src=&quot;../../static/tab/gonglveb.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;</span><br><span class="line">					&lt;text&gt;&#123;&#123; item &#125;&#125;&lt;/text&gt;</span><br><span class="line">				&lt;/view&gt;</span><br><span class="line">			&lt;/block&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/92e32620-95e9-11ea-a30b-e311646dfaf2.jpg">

<p>我们在编辑完布局之后，就可以对选择地区页进行业务逻辑的编写了，首先我们要在data()中返回定义的citynone、inputValue、address、citydata、keywoeds、pageroute以及city用来存储用户数据和一些共享的状态。然后就可以在methods中定义以下业务逻辑了。</p>
<blockquote>
<p>在触发搜索状态的时候，我们需要将当前定位，以及热门搜索等一系列布局给隐藏起来，这里我们使用citynone来做组件样式状态的管理。当我们点击搜索的时候，就将不需要的布局隐藏进入搜索状态。点击黑色的叉叉，关闭搜索状态，恢复隐藏的样式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">searchCity(e)&#123;</span><br><span class="line">	console.log(e)</span><br><span class="line">	this.citynone = false</span><br><span class="line">&#125;,</span><br><span class="line">canCal()&#123;</span><br><span class="line">	this.citynone = true</span><br><span class="line">	this.inputValue = &apos;&apos;</span><br><span class="line">	this.citydata = &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 不管我们点击当前位置、热门搜索还是我们检索出来的地区，我们都要通过点击将数据记录下来，点击定位到城市名称就将数据存储到address中，到时候就可以将定位传值为社区页了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clickCity()&#123;</span><br><span class="line">	let cityion = this.address</span><br><span class="line">	this.backRoutes(cityion)</span><br><span class="line">&#125;,</span><br><span class="line">//取到热门景点</span><br><span class="line">hotCity(city)&#123;</span><br><span class="line">	this.backRoutes(city)</span><br><span class="line">&#125;,</span><br><span class="line">//搜索城市</span><br><span class="line">seekCity(city)&#123;</span><br><span class="line">	console.log(city)</span><br><span class="line">	this.backRoutes(city)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们选定定位地区的时候，点击之后就可以实现直接跳转回社区页，这样的话通过vuex来管理共享的地区数据，社区页就可以根据我们传过去的值来检索对应地区的数据呈现出来。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">backRoutes(cityion)&#123;</span><br><span class="line">	//vuex传值</span><br><span class="line">	if(this.pageroute == &apos;pages/travels/travels&apos;)&#123;</span><br><span class="line">		//传给发表页面</span><br><span class="line">		console.log(cityion)</span><br><span class="line">		this.$store.commit(&apos;travemuta&apos;,cityion)</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		//传给tab攻略页面</span><br><span class="line">		console.log(cityion)</span><br><span class="line">		this.$store.commit(&apos;citymuta&apos;,cityion)</span><br><span class="line">	&#125;</span><br><span class="line">	uni.navigateBack(&#123;</span><br><span class="line">		delta:1</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实时搜索城市的功能我们是借助的腾讯地图开放功能来实现的，JavaScript SDK会根据定位给我们返回定位的经纬度信息，我们需要处理这些信息来得到准企鹅的位置信息。在这里JavaScript SDK为我们提供了getSuggestion()方法来对地址进行逆解析操作，然后返回对应地址的信息。通过filter属性来限定我们解析出来的结果满足大学这个条件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">searchInput(e)&#123;</span><br><span class="line">	qqmapsdk.getSuggestion(&#123;</span><br><span class="line">		keyword:e.detail.value ,</span><br><span class="line">		policy:1,</span><br><span class="line">		// filter:&apos;category=大学&apos;,</span><br><span class="line">		// region:&quot;湘潭市&quot;,</span><br><span class="line">		success:(res)=&gt;&#123;</span><br><span class="line">			let city = res.data</span><br><span class="line">			this.citydata = city.map((item)=&gt;&#123;</span><br><span class="line">				return item.title</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		fail:(err)=&gt;&#123;</span><br><span class="line">			console.log(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/a699e1d0-95ea-11ea-b94e-47f67ecf8268.jpg">

]]></content>
      <categories>
        <category>项目笔记</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery源码解读（三）</title>
    <url>/2020/02/06/2020-02-06-jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89-md/</url>
    <content><![CDATA[<h3 id="jQuery中的extend"><a href="#jQuery中的extend" class="headerlink" title="jQuery中的extend"></a>jQuery中的extend</h3><a id="more"></a>

<blockquote>
<p>extend:向JQ中继续拓展方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.extend = function()&#123;</span><br><span class="line">    //......</span><br><span class="line">&#125;;</span><br><span class="line">//调用extend</span><br><span class="line">$.extend(&#123;&#125;);       //拓展到JQ对象上：一般是为了完善类库，提供更多的工具方法。</span><br><span class="line">$.extend(true,&#123;&#125;)</span><br><span class="line"></span><br><span class="line">$.fn.extend();      //拓展到JQ原型上：一般是为了写插件，让JQ实例调用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>转移$的使用权：当$与其他类库产生了冲突，执行这个方法可以转移使用权。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var _jQuery = window.jQuery,</span><br><span class="line">    _$ = window.$;</span><br><span class="line">    </span><br><span class="line">jQuery.noConflict = function(deep)&#123;</span><br><span class="line">    if(window.$ === jQuery)&#123;</span><br><span class="line">        window.$ === _$;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(deep &amp;&amp; window.jQuery === jQuery)&#123;</span><br><span class="line">        window.jQuery = _jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return jQuery;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//转移使用权的调用方法</span><br><span class="line">let j = jQuery.noConflict();    //noConflict(true)可以转移jQuery的使用权</span><br><span class="line">jQuery();</span><br><span class="line">j();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2020/03/29/2020-03-29-%E9%97%AD%E5%8C%85-md/</url>
    <content><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>一般来说闭包就是能够读取其他函数内部变量的函数</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>从内存的角度来说函数执行形成不能被释放的私有栈内存，就是闭包</p>
</blockquote>
<blockquote>
<p>从机制的角度来说函数执行形成私有栈内存，保护私有作用域中的变量不与外界产生联系，这种保护机制就是闭包</p>
</blockquote>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><ul>
<li><strong>保护（私有变量与外界没有必然联系）</strong></li>
<li><strong>保存（形成不销毁的栈内存，里面的私有变量就保存下来了）</strong></li>
</ul>
<h3 id="闭包作用域"><a href="#闭包作用域" class="headerlink" title="闭包作用域"></a>闭包作用域</h3><ol>
<li>创建函数<ul>
<li>开辟一个堆内存</li>
<li>把函数体中的代码以字符串的形式存储进去</li>
<li>把堆内存的地址赋值给函数名或变量名</li>
<li>函数在哪创建，那么它执行时的上级作用域就是谁</li>
</ul>
</li>
<li>函数执行<ul>
<li>形成一个全新的私有作用域、执行上下文、私有栈内存（执行一次形成一个，多个之间不会产生影响）</li>
<li>形参赋值&amp;变量提升</li>
<li>代码执行（把所属堆内存中的代码字符串拿出来一行一行执行）</li>
<li>遇到一个变量，首先看他是否为私有变量（形参和在私有作用域中声明的变量属于私有变量），私有变量就操作自己的变量即可，不是私有的则向上级作用域中查找，一直找到全局作用域为止=&gt;<strong>作用域链查找机制</strong></li>
<li>私有变量被私有栈内存保护起来了，所以与外界变量没有必然的联系，这就是闭包的保护机制<h3 id="堆栈内存释放问题（以webkit为例）"><a href="#堆栈内存释放问题（以webkit为例）" class="headerlink" title="堆栈内存释放问题（以webkit为例）"></a>堆栈内存释放问题（以webkit为例）</h3><h4 id="堆内存释放"><a href="#堆内存释放" class="headerlink" title="堆内存释放"></a>堆内存释放</h4><blockquote>
<p>创建一个引用类型值就会产生一个堆内存</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>如果当前创建的堆内存不被占用，则会释放（浏览器会在会在空闲的时候查找每一个内存引用状况，不被占用的会被回收释放掉）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">  name:&apos;堆内存&apos;</span><br><span class="line">&#125;</span><br><span class="line">let oop=obj；</span><br><span class="line">//此时obj和oop都占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关联(null：空对象指针)</span><br><span class="line">obj=null;</span><br><span class="line">oop=null;</span><br></pre></td></tr></table></figure>

<h4 id="栈内存释放问题"><a href="#栈内存释放问题" class="headerlink" title="栈内存释放问题"></a>栈内存释放问题</h4><blockquote>
<p>栈内存形成的条件</p>
</blockquote>
<ul>
<li>运行浏览器时形成的全局作用域</li>
<li>手动执行函数形成的私有作用域</li>
<li>let和const形成的块级作用域</li>
</ul>
<blockquote>
<p>栈内存的销毁</p>
</blockquote>
<ul>
<li><p>全局栈内存：关闭的时候才会销毁（刷新页面时，销毁旧的栈内存，再生成新的栈内存）</p>
</li>
<li><p>私有栈内存：</p>
<blockquote>
<p>一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉（排除出现无限递归或死循环的情况）</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">fn()    //函数执行形成栈内存、执行完成栈内存被销毁</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是栈内存中的某些东西（如堆地址）被私有作用域以外的事物占用时，则当前栈内存不能立即被释放销毁（导致私有作用域外的私有变量等信息也保留下来了）</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let f = fn()    //f占用了fn执行时形成的栈内存中返回函数对应的堆，使得x执行形成的栈内存不能被释放</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参考文献：</p>
<blockquote>
<p> –<a href="https://www.bilibili.com/video/BV1J4411B7Pa" target="_blank" rel="noopener">珠峰前端公开课</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>垂直居中布局</title>
    <url>/2020/04/01/2020-04-01-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80-md/</url>
    <content><![CDATA[<h3 id="margin-绝对定位"><a href="#margin-绝对定位" class="headerlink" title="margin+绝对定位"></a>margin+绝对定位</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  margin: auto;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>

<h3 id="绝度定位"><a href="#绝度定位" class="headerlink" title="绝度定位"></a>绝度定位</h3><blockquote>
<p>确定容器的宽高,设置div的负外边距</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">position:absolute;/*绝对定位*/</span><br><span class="line">width:500px;</span><br><span class="line">height:300px;</span><br><span class="line">top:50%;</span><br><span class="line">left:50%;</span><br><span class="line">margin:-150px -250px;/*外边距为自身宽高的一半*/</span><br><span class="line">background-color:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><blockquote>
<p>未知容器的宽高，利用<code>transform</code>属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  position: relative; /*相对定位或绝对定位均可*/</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">  background-color: pink; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h3><blockquote>
<p>利用flex布局实际使用时应考虑兼容性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center; /*垂直居中*/</span><br><span class="line">  justify-content: center; /*水平居中*/</span><br><span class="line">&#125;</span><br><span class="line">.container div &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background-color: pink; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="text-align和vertical-align"><a href="#text-align和vertical-align" class="headerlink" title="text-align和vertical-align"></a>text-align和vertical-align</h3><blockquote>
<p>利用text-align:center和vertical-align:middle属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">container &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  background: rgba(0, 0, 0, 0.5);</span><br><span class="line">  text-align: center;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">  overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container::after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  height: 100%;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 400px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  white-space: normal;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般常见的几种居中的方法有：</p>
<p>对于宽高固定的元素</p>
<p>（1）我们可以利用margin:0auto来实现元素的水平居中。</p>
<p>（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水<br>平和垂直方向上的居中。</p>
<p>（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素<br>的中心点到页面的中心。</p>
<p>（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素<br>的中心点到页面的中心。</p>
<p>（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对<br>齐，然后它的子元素也可以实现垂直和水平的居中。</p>
<p>对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>new操作符</title>
    <url>/2020/04/12/2020-04-12-new%E6%93%8D%E4%BD%9C%E7%AC%A6-md/</url>
    <content><![CDATA[<h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><blockquote>
<p><strong>语法</strong></p>
</blockquote><pre><code>new constructor[([arguments])]</code></pre><p><strong>constructor</strong></p><p>  一个指定对象实例的类型的类或函数。</p><p><strong>arguments</strong></p><p>  一个用于被 constructor 调用的参数列表。</p><a id="more"></a>




<blockquote>
<p>创建一个用户自定义的对象一般有两个步骤：</p>
</blockquote>
<ol>
<li>通过编写函数来定义对象类型</li>
<li>通过 new 来创建对象实例。</li>
</ol>
<p><strong>如果你没有使用 new 运算符， 构造函数会像其他的常规函数一样被调用， 并不会创建一个对象。在这种情况下， this 的指向也是不一样的。</strong></p>
<h2 id="new-操作符具体干了什么？"><a href="#new-操作符具体干了什么？" class="headerlink" title="new 操作符具体干了什么？"></a>new 操作符具体干了什么？</h2><blockquote>
<p>new 共经历了四个过程</p>
</blockquote>
<ol>
<li>首先创建了一个空对象</li>
<li>设置原型、将对象的原型设置为函数的prototype对象</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码，为这个新对象添加属性</li>
<li>判断函数的返回值，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function objectFactory()&#123;</span><br><span class="line">    let newObject = null,</span><br><span class="line">    constructor = Array.prototype.shift.call(arguments),</span><br><span class="line">    result = null;</span><br><span class="line">    </span><br><span class="line">    //参数判断</span><br><span class="line">    if(typeof constructor !== &quot;function&quot;)&#123;</span><br><span class="line">        console.error(&quot;type error&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br><span class="line">    newObject = Object.create(constructor.prototype);</span><br><span class="line">    </span><br><span class="line">    //将this指向新建对象，并执行函数</span><br><span class="line">    result = constructor.apply(newObject,arguments);</span><br><span class="line">    </span><br><span class="line">    //判断返回对象</span><br><span class="line">    let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);</span><br><span class="line">    </span><br><span class="line">    //判断返回结果</span><br><span class="line">    return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用方法</span><br><span class="line">// objectFactory(构造函数,初始化参数)</span><br></pre></td></tr></table></figure>






<p><strong>参考文献</strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">new 运算符</a></p>
<p><a href="https://segmentfault.com/a/1190000008576048" target="_blank" rel="noopener">new 操作符具体干了什么？</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的防抖和节流</title>
    <url>/2020/04/13/2020-04-13-%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81-md/</url>
    <content><![CDATA[<blockquote>
<p>函数的防抖和节流都是为了限制函数的执行次数，以解决函数触发频率过高导致浏览器的响应速度跟不上造成的卡顿和延迟现象，也就是前端所谓的性能优化。</p>
</blockquote>
<a id="more"></a>
<h2 id="函数的防抖"><a href="#函数的防抖" class="headerlink" title="函数的防抖"></a>函数的防抖</h2><blockquote>
<p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//函数防抖的实现</span><br><span class="line">function(fn,wait)&#123;</span><br><span class="line">    var timer = null;</span><br><span class="line">    </span><br><span class="line">    return function()&#123;</span><br><span class="line">        var context = this,</span><br><span class="line">            args = arguments;</span><br><span class="line">        //如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">         if (timer) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数的节流"><a href="#函数的节流" class="headerlink" title="函数的节流"></a>函数的节流</h2><blockquote>
<p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。(游戏里的技能冷却)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 函数节流的实现;</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">    var preTime = Date.now();</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        var context = this,</span><br><span class="line">            args = arguments,</span><br><span class="line">            nowTime = Date.now();</span><br><span class="line"></span><br><span class="line">        // 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">        if (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">            preTime = Date.now();</span><br><span class="line">            return fn.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考文献</strong></p>
<p><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" target="_blank" rel="noopener">轻松理解JS函数节流和函数防抖</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化开发</title>
    <url>/2020/04/13/2020-04-13-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91-md/</url>
    <content><![CDATA[<h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2><blockquote>
<p>现在的前端开发，不仅仅是完成浏览器的基本需求。并且通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程会加载越来越多的JavaScript代码。如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器快速、优雅的加载和更新，就需要一个模块化系统</p>
</blockquote>
<a id="more"></a>
<h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><blockquote>
<p>模块化是实现一组特定功能的一组方法</p>
</blockquote>
<p>最开始由于函数具有独立作用域的特点，所以使用<strong>函数</strong>来作为模块，但是这种方法容易造成全局变量污染，并且模块之间没有联系。后面提出了<strong>对象写法</strong>，通过函数作为一个对象的方法来实现，遮掩虽然解决了直接使用函数模块的缺点，但是这种方法会暴露所有的模块成员，从而导致外部代码可以修改内部代码。所以现在常用的时使用立即执行函数的写法，通过<strong>闭包</strong>来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</p>
<h3 id="JS常见的模块规范"><a href="#JS常见的模块规范" class="headerlink" title="JS常见的模块规范"></a>JS常见的模块规范</h3><h4 id="高级单例模式"><a href="#高级单例模式" class="headerlink" title="高级单例模式"></a>高级单例模式</h4><blockquote>
<p>高级单例模式：创建一个命名空间（模块名），接收一个闭包中返回的相关信息，实现把比保重的某些信息暴露出来，供其他闭包调用。（可以参考jQuery源码）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let module1 = (function()&#123;</span><br><span class="line">    let name = &quot;小明&quot;;</span><br><span class="line">    </span><br><span class="line">    function query()&#123;</span><br><span class="line">        console.log(&quot;query&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123; query:query &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">let module2 = (function()&#123;</span><br><span class="line">    function fn()&#123;</span><br><span class="line">        console.log(&quot;fn&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //调用module1中的query方法</span><br><span class="line">    module.query();</span><br><span class="line">    </span><br><span class="line">    return &#123; fn:fn &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>


<h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><blockquote>
<p>Node.js 是 CommonJS 规范的主要实践者，在node.js中每个js文件就是一个模块，他有四个重要的环境变量：==module==、==exports==、==require==、==global==。实际使用时，使用==module.exports==定义当前模块对外输出的接口（不推荐直接使用==exports==），用==require==加载模块。</p>
</blockquote>
<p><strong>定义模块math.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var basicNum = 0;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在这里写上需要向外暴露的函数、变量</span><br><span class="line">module.exports = &#123; </span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line">//ES6中对象的key和value相等可以简写为</span><br><span class="line">// module.exports = &#123; add,basicNum &#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用自定义的模块时，参数包含路径，可省略.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var math = require(&apos;./math&apos;);</span><br><span class="line">math.add(2, 5);</span><br></pre></td></tr></table></figure>

<p><strong>引用核心模块时，不需要带路径</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createService(...).listen(3000);</span><br></pre></td></tr></table></figure>
<p>CommonJS 用同步的方法加载模块。在服务端，模块组件都存在本地磁盘，读取非常快。但是在浏览器端，由于网络的限制，所以使用异步加载更加合理。</p>
<h4 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h4><blockquote>
<p>AMD规范采用异步加载模块，模块的加载不影响它后面语句的执行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个会掉函数再执行。AMD规范的模块化是由==require.js==实现的。用==require.config==()指定应用路径、用define()定义模块、用==require==()加载模块。</p>
</blockquote>
<p><strong>网页中引入 require.js 及 main.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>main.js 入口文件/主模块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">    baseUrl:&quot;js/lib&quot;,</span><br><span class="line">    paths:&#123;</span><br><span class="line">        &quot;jquery&quot;:&quot;jquery.min&quot;,  //实际路径 js/lib/jquery.min.js</span><br><span class="line">        &quot;underscore&quot;:&quot;underscore.min&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//执行基本操作</span><br><span class="line">require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;</span><br><span class="line">    //code</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义math.js模块</span><br><span class="line">define(function()&#123;</span><br><span class="line">    var basicNum = 0;</span><br><span class="line">    var add = function(x,y)&#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        add:add,</span><br><span class="line">        basicNum:basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//定义提个依赖underscroe.js模块</span><br><span class="line">define([&apos;underscore&apos;],function()&#123;</span><br><span class="line">    var classify = function(list)&#123;</span><br><span class="line">    _.countBy(list,function(num)&#123;</span><br><span class="line">      return num &gt; 30 ? &apos;old&apos; : &apos;young&apos;;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 引用模块，将模块放在[]内</span><br><span class="line">require([&apos;jquery&apos;, &apos;math&apos;],function($, math)&#123;</span><br><span class="line">  var sum = math.add(10,20);</span><br><span class="line">  $(&quot;#sum&quot;).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h4><blockquote>
<p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** AMD写法 **/</span><br><span class="line">define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) &#123; </span><br><span class="line">     // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    a.doSomething();</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** CMD写法 **/</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var a = require(&apos;./a&apos;); //在需要时申明</span><br><span class="line">    a.doSomething();</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        var b = require(&apos;./b&apos;);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** sea.js **/</span><br><span class="line">// 定义模块 math.js</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var $ = require(&apos;jquery.js&apos;);</span><br><span class="line">    var add = function(a,b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    exports.add = add;</span><br><span class="line">&#125;);</span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([&apos;math.js&apos;], function(math)&#123;</span><br><span class="line">    var sum = math.add(1+2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h4><blockquote>
<p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：==export==和==import==。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from &apos;./math&apos;;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** export default **/</span><br><span class="line">//定义输出</span><br><span class="line">export default &#123; basicNum, add &#125;;</span><br><span class="line">//引入</span><br><span class="line">import math from &apos;./math&apos;;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = math.add(99 + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>
<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><p><strong>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></p>
<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p>
<p><strong>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</strong></p>
<p>CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p><strong>参考文献</strong></p>
<p><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f" target="_blank" rel="noopener">浅谈模块化开发</a></p>
<p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">前端模块化</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS盒子模型</title>
    <url>/2020/04/01/2020-04-01-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B-md/</url>
    <content><![CDATA[<h2 id="CSS盒子模型简介"><a href="#CSS盒子模型简介" class="headerlink" title="CSS盒子模型简介"></a>CSS盒子模型简介</h2><blockquote>
<p>当我们对文档进行布局的时候，浏览器的渲染引擎会根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener"> CSS 基础框盒模型（CSS basic box model）</a>标准，将所有元素渲染成一个个矩形的盒子，且通过CSS决定盒子的大小、位置以及属性等属性。</p>
</blockquote>
<a id="more"></a>
<p><strong>每个盒子有四个部分组成</strong></p>
<ul>
<li>内容边界 Content edge</li>
<li>内边距边界 Padding Edge</li>
<li>框边界 Border Edge</li>
<li>外边框边界 Margin Edge</li>
</ul>
<p>MDN 官网图片<br><img src="https://mdn.mozillademos.org/files/8685/boxmodel-(3).png" ></p>
<h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><blockquote>
<p>CSS 中的 box-sizing 属性定义了 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent" target="_blank" rel="noopener">user agent</a> 应该如何计算一个元素的总宽度和总高度。</p>
</blockquote>
<h3 id="W3C标准盒模型（content-box）"><a href="#W3C标准盒模型（content-box）" class="headerlink" title="W3C标准盒模型（content-box）"></a>W3C标准盒模型（content-box）</h3><blockquote>
<p>默认值，标准盒子模型。 width 与 height 只包括内容的宽和高，不包括边框（border），内边距（padding），外边距（margin）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    background-color:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://user-gold-cdn.xitu.io/2017/10/25/9cb491d4bd5d326aeb16632280411283?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" >

<h3 id="IE盒模型（border-box）"><a href="#IE盒模型（border-box）" class="headerlink" title="IE盒模型（border-box）"></a>IE盒模型（border-box）</h3><blockquote>
<p>width 和 height 属性包括内容，内边距和边框，但<strong>不包括外边距(margin)</strong>。</p>
</blockquote>
<p><strong>尺寸计算公式</strong>：</p>
<p>width = border + padding + 内容的宽度</p>
<p>height = border + padding + 内容的高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    background-color:blue;</span><br><span class="line">    padding:20px;</span><br><span class="line">    border:10px solid orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://user-gold-cdn.xitu.io/2017/10/25/cfff88aff482f7dd89d60d7498695450?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" >

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>我们在编写页面代码时应尽量使用标准的W3C模型(需在页面中声明DOCTYPE类型)，这样可以避免多个浏览器对同一页面的不兼容。因为若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型，FireFox等会将其解释为W3C盒子模型；若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</p>
</blockquote>
<p><strong>参考文献</strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener">CSS 基础框盒模型介绍</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" target="_blank" rel="noopener">box-sizing</a></p>
<p><a href="https://juejin.im/post/59ef72f5f265da4320026f76" target="_blank" rel="noopener">CSS盒模型详解</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>this</title>
    <url>/2020/08/24/2020-08-24-this-md/</url>
    <content><![CDATA[<h3 id="THIS"><a href="#THIS" class="headerlink" title="THIS"></a>THIS</h3><blockquote>
<p>this:函数的执行主体，和执行上下文不是一个概念</p>
</blockquote>
<ul>
<li>全局的this是window，我们研究的都是函数中的this</li>
<li>this是谁和函数在哪里执行，以及在哪定义都没有必然联系</li>
</ul>
<a id="more"></a>
<p><strong>判断执行主体的方式：</strong></p>
<ol>
<li>给当前元素的某个<code>事件行为绑定方法</code>，<code>事件绑定</code>，<code>执行对应方法</code>，方法中的this是当前元素本身（排除：IE6~8基于attachEvent实现的DOM2事件绑定，绑定的方法中的this不是操作的元素，而是window）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.body.onclik = function()&#123;</span><br><span class="line">    //this:body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数执行，首先看函数名之前是否有‘点’，有‘点’，‘点’前面是谁this就是谁，没有‘点’this就是window（在JS的严格模式下，没有‘点’，方法中的this是undefined）<ul>
<li>自执行函数中的this一般都是window/undefined</li>
<li>回调函数中的this一般都是window/undefined（除非特殊处理）</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&apos;xxx&apos;,</span><br><span class="line">    fn:fn</span><br><span class="line">&#125;</span><br><span class="line">fn();       //this:window</span><br><span class="line">obj.fn();   //this:obj</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构造函数中的this是当前实例</li>
<li>箭头函数没有自己的this，用到的this都是上下文中的this</li>
<li>基于call、apple、bind可以强制改变this的指向</li>
</ol>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    num: 20</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn = (function (num) &#123;</span><br><span class="line">    this.num = num * 3;</span><br><span class="line">    num++;</span><br><span class="line">    return function (n) &#123;</span><br><span class="line">        this.num += n;</span><br><span class="line">        num++;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(obj.num);</span><br><span class="line">var fn = obj.fn;</span><br><span class="line">fn(5);                          //22</span><br><span class="line">obj.fn(10);                     //23</span><br><span class="line">console.log(num, obj.num);      //65  30</span><br></pre></td></tr></table></figure>

<p>画图分析</p>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/f1f356c0-e5d6-11ea-b244-a9f5e5565f30.png">
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex</title>
    <url>/2020/03/30/2020-03-30-vuex-md/</url>
    <content><![CDATA[<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><blockquote>
<p>官网上介绍，Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>
<a id="more"></a>
<h3 id="状态管理模式"><a href="#状态管理模式" class="headerlink" title="状态管理模式"></a>状态管理模式</h3><blockquote>
<p>如果你熟悉vue.js开发，那么你一定对各组件之间传值的问题倍感头疼，而vuex就是用来解决各个组件之间共用值得传递问题</p>
</blockquote>
<p>– 1. 在你的项目中安装vuex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure>

<p>– 2. 在src文件目录中新建store文件夹，再在这个文件夹下创建一个index.js文件并输入以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex from &apos;vuex&apos;;</span><br><span class="line">//使用vuex</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">//创建Vuex.Store实例保存到变量store中</span><br><span class="line">const store = new Vuex.Store();</span><br><span class="line"> </span><br><span class="line">export default store;       //导出store</span><br></pre></td></tr></table></figure>
<p>– 3. 在main.js文件中引用该对象,这样就可以在任何一个组件里面使用this.$store了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,//使用store</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="vuex核心"><a href="#vuex核心" class="headerlink" title="vuex核心"></a>vuex核心</h2><blockquote>
<p>官网图片</p>
</blockquote>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/9ba18300-7268-11ea-b94e-47f67ecf8268.jpg" >

<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote>
<p>store相当于一个商店，不同的组件可以来商店来获取自己想要的商品，而state就相当于商店的货架，组件可以通多store.state.XXX获取需要的状态</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建一个 Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>– 每当 store.state.count变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。然而，这种模式导致组件依赖全局状态单例。Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：</p>
<p>– 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter = &#123;</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h4><blockquote>
<p>当组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。mapState辅助函数帮助我们生成计算属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在单独构建的版本中辅助函数为 Vuex.mapState</span><br><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    // 箭头函数可使代码更简练</span><br><span class="line">    count: state =&gt; state.count,</span><br><span class="line"></span><br><span class="line">    // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count`</span><br><span class="line">    countAlias: &apos;count&apos;,</span><br><span class="line"></span><br><span class="line">    // 为了能够使用 `this` 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h4><blockquote>
<p>mapState函数返回的是一个对象。通常，我们可以在<strong>computed</strong>使用<strong><a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">对象展开运算符</a></strong>，将多个对象合并成一个</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; </span><br><span class="line">    // ... </span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><blockquote>
<p>如果我们将state看做store的data属性，那么getter就可以被看做store的computed属性（getter的返回值根据他的依赖被缓存起来，当依赖改变时会被重新计算）。</p>
</blockquote>
<p>– getter 接受 state 作为其第一个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.getters.doneTodos // -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;]</span><br></pre></td></tr></table></figure>
<p>– Getter 也可以接受其他 getter 作为第二个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  // ...</span><br><span class="line">  doneTodosCount: (state, getters) =&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.getters.doneTodosCount // -&gt; 1</span><br></pre></td></tr></table></figure>
<h4 id="mapGetter辅助函数"><a href="#mapGetter辅助函数" class="headerlink" title="mapGetter辅助函数"></a>mapGetter辅助函数</h4><blockquote>
<p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">  // 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class="line">    ...mapGetters([&apos;doneTodosCount&apos;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><blockquote>
<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      // 变更状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>– 调用此函数,需要以相应的 type 调用 store.commit 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="载荷（Payload）"><a href="#载荷（Payload）" class="headerlink" title="载荷（Payload）"></a>载荷（Payload）</h4><p>– store&gt;store.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;, 10)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>
</blockquote>
<p>– xxx.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;, &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h4><blockquote>
<p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>
</blockquote>
<p>– mutation-types.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const SOME_MUTATION = &apos;SOME_MUTATION&apos;</span><br></pre></td></tr></table></figure>
<p>– store.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import &#123; SOME_MUTATION &#125; from &apos;./mutation-types&apos;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      // mutate state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h4><blockquote>
<p>可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line"></span><br><span class="line">      // `mapMutations` 也支持载荷：</span><br><span class="line">      &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意一条重要的原则就是要记住 mutation 必须是同步函数,在 mutation 中混合异步调用会导致你的程序很难调试。</strong></p>
</blockquote>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote>
<p>Action 类似于 mutation，不同在于：</p>
</blockquote>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (&#123; commit &#125;) &#123;    //参数解构来简化代码</span><br><span class="line">        commit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h4><blockquote>
<p>Action 通过store.dispatch方法触发：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.dispatch(&apos;increment&apos;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>action 内部可以执行异步操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      commit(&apos;increment&apos;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mapActions辅助函数"><a href="#mapActions辅助函数" class="headerlink" title="mapActions辅助函数"></a>mapActions辅助函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class="line"></span><br><span class="line">      // `mapActions` 也支持载荷：</span><br><span class="line">      &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vuex中mutation和action的详细区别"><a href="#vuex中mutation和action的详细区别" class="headerlink" title="vuex中mutation和action的详细区别"></a>vuex中mutation和action的详细区别</h4></li>
</ul>
<ol>
<li>流程顺序</li>
</ol>
<p>“相应视图—&gt;修改State”拆分成两部分，视图触发Action，Action再触发Mutation。</p>
<ol start="2">
<li>角色定位</li>
</ol>
<p>基于流程顺序，二者扮演不同的角色。</p>
<pre><code>Mutation：专注于修改State，理论上是修改State的唯一途径。

Action：业务代码、异步请求。</code></pre><ol start="3">
<li>限制</li>
</ol>
<p>角色不同，二者有不同的限制。</p>
<pre><code>Mutation：必须同步执行。

Action：可以异步，但不能直接操作State。</code></pre><blockquote>
<p>他两者之间不是功能的不同，而是编程思想的不同，按照官方规定书写代码高效、易维护、逻辑清晰</p>
</blockquote>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><blockquote>
<p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>





<p><strong>参考文献</strong></p>
<p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex是什么</a></p>
<p><a href="https://segmentfault.com/a/1190000015782272" target="_blank" rel="noopener">VueJS中学习使用Vuex详解</a></p>
<p><a href="https://blog.csdn.net/weixin_38483133/article/details/89327362" target="_blank" rel="noopener">vuex中mutation和action的详细区别</a></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Ajax</title>
    <url>/2020/04/14/2020-04-14-Ajax-md/</url>
    <content><![CDATA[<h2 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX"></a>什么是AJAX</h2><blockquote>
<p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
</blockquote>
<a id="more"></a>
<h2 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h2><blockquote>
<p>创建Ajax包括以下步骤：</p>
</blockquote>
<ol>
<li>实例化一个XMLHttpRequest对象</li>
<li>使用open方法创建一个http请求， <strong>open([请求方法],[请求地址],[是否异步和用户的认证信息])</strong></li>
<li>设置监听HTTP请求状态变化的函数</li>
<li>发送HTTP请求</li>
<li>获取异步调用返回的数据</li>
<li>使用JavaScript和DOM实现局部刷新</li>
</ol>
<p><strong>回调函数实现的方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const SERVER_URL = &quot;/server&quot;;</span><br><span class="line"></span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 创建 Http 请求</span><br><span class="line">xhr.open(&quot;GET&quot;, SERVER_URL, true);</span><br><span class="line"></span><br><span class="line">// 设置状态监听函数</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (this.readyState !== 4) return;</span><br><span class="line"></span><br><span class="line">  // 当请求成功时</span><br><span class="line">  if (this.status === 200) &#123;</span><br><span class="line">    handle(this.response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error(this.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 设置请求失败时的监听函数</span><br><span class="line">xhr.onerror = function() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 设置请求头信息</span><br><span class="line">xhr.responseType = &quot;json&quot;;</span><br><span class="line">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line"></span><br><span class="line">// 发送 Http 请求</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<p><strong>基于promise封装实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line"></span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line"></span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line"></span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line"></span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h3><ol>
<li><code>get</code></li>
<li><code>post</code> </li>
<li><code>head</code></li>
<li><code>put</code></li>
<li><code>delete</code></li>
<li><code>connect</code></li>
<li><code>options</code></li>
<li><code>trace</code></li>
</ol>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul>
<li><code>200</code> <strong>服务器正常</strong></li>
<li><code>301</code> <strong>永久移动</strong></li>
<li><code>302</code> <strong>暂时移动</strong></li>
<li><code>304</code> <strong>未修改</strong></li>
<li><code>307</code> <strong>暂时重定向</strong></li>
<li><code>401</code> <strong>未授权</strong></li>
<li><code>403</code> <strong>禁止访问</strong></li>
<li><code>404</code> <strong>未发现指定网址</strong></li>
<li><code>500</code> <strong>服务器错误</strong></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包的高阶应用</title>
    <url>/2020/08/29/2020-08-29-%E9%97%AD%E5%8C%85%E7%9A%84%E9%AB%98%E9%98%B6%E5%BA%94%E7%94%A8-md/</url>
    <content><![CDATA[<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><blockquote>
<p>在没有对象和函数情况下，编写代码，会出现<code>全局变量污染</code>,为了防止全局变量污染，我们可以使用以下方法来处理。</p>
</blockquote><p><strong>方案一： 闭包</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//利用闭包的保护机制</span><br><span class="line">(function()&#123;</span><br><span class="line">    let name = &quot;张三&quot;；</span><br><span class="line">    let age = 21;</span><br><span class="line">    let sex = &quot;男&quot;；</span><br><span class="line">&#125;)()；</span><br></pre></td></tr></table></figure><a id="more"></a>



<p><strong>方案二： 对象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//利用对象的分组功能，把描述同一事物的属性和方法放置在相同的堆内存空间中</span><br><span class="line">let person1 = &#123;</span><br><span class="line">    name:&quot;李四&quot;，</span><br><span class="line">    age:22,</span><br><span class="line">    sex:&quot;男&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单例设计模式</strong></p>
<blockquote>
<p>在实际开发过程中，我们通常结合<code>闭包保护机制</code>和<code>对象的分组机制</code>，来实现闭包中方法的调用，而这种模式就是我们常说的单例设计模式。单例模式也是最早的模块规范。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let AModule = (function()&#123;</span><br><span class="line">    let name = &quot;张三&quot;；</span><br><span class="line">    function fn()&#123;console.log(1)&#125;;</span><br><span class="line">    function query()&#123;console.log(2)&#125;</span><br><span class="line">    </span><br><span class="line">    // 当我们想把私有的东西暴露给外界使用</span><br><span class="line">    //1. window.xxx = xxx  缺点：当方法暴露过多时，还是会引发全局变量污染</span><br><span class="line">    </span><br><span class="line">    //2. 基于对象分组的特性，把需要暴露的API，都放置在同一堆内存空间下。</span><br><span class="line">    return &#123;</span><br><span class="line">        fn,</span><br><span class="line">        query,</span><br><span class="line">        init()&#123;</span><br><span class="line">            //控制业务逻辑的执行顺序的“控制命令”</span><br><span class="line">            fn();</span><br><span class="line">            query();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)()；</span><br><span class="line"></span><br><span class="line">Amodule.query()     //2</span><br><span class="line">Amodule.fn()        //1</span><br><span class="line">Amodule.init()      //1  2</span><br></pre></td></tr></table></figure>

<h3 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h3><blockquote>
<p>能执行一次的，绝对不执行第二次。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getCss(element,attr)&#123;</span><br><span class="line">    if(window.getComputedStyle)&#123;</span><br><span class="line">        return window.getComputedStyle(element)[attr];</span><br><span class="line">    &#125;</span><br><span class="line">    //IE6~8</span><br><span class="line">    return element.currentStyle[attr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getCss(document.body,&apos;width&apos;));</span><br><span class="line">console.log(getCss(document.body,&apos;padding&apos;));</span><br><span class="line">console.log(getCss(document.body,&apos;margin&apos;));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述函数在第一次执行时，会判断是否兼容，而后的每一次执行方法都会处理兼容。其实，这个操作在第二次执行时就已经没有必要了。</p>
</blockquote>
<p><strong>方案一</strong></p>
<blockquote>
<p>页面加载时，就把兼容处理了。后期基于变量的返回值即可直接判断</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isCompatible = &apos;getComputStyle&apos; in window;</span><br><span class="line">function getCss(element,attr)&#123;</span><br><span class="line">    if(isCompatible)&#123;</span><br><span class="line">        return window.getComputedStyle(element)[attr];</span><br><span class="line">    &#125;</span><br><span class="line">    //IE6~8</span><br><span class="line">    return element.currentStyle[attr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方案二</strong></p>
<blockquote>
<p>惰性思想解决：函数重构</p>
</blockquote>
<ul>
<li>getCss是全局函数</li>
<li>第一次执行会产生<code>闭包</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getCss(element,attr)&#123;</span><br><span class="line">    if(window.getComputedStlye)&#123;</span><br><span class="line">        //将全局的getCss重构</span><br><span class="line">        getCss = function(element,attr)&#123;</span><br><span class="line">            return window.getComputedStyle(element)[attr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        getCss = function(element,attr)&#123;</span><br><span class="line">            return element.currentStyle[attr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将会重构后的函数执行，确保第一次执行能够获得结果</span><br><span class="line">    return getCss(element,attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getCss(document.body,&apos;width&apos;));</span><br><span class="line">console.log(getCss(document.body,&apos;padding&apos;));      //函数第二次执行，执行重构后的函数，不需要做兼容判断</span><br><span class="line">console.log(getCss(document.body,&apos;margin&apos;));</span><br></pre></td></tr></table></figure>

<h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><blockquote>
<p>柯里化函数使用的是<code>预处理思想</code>，应用的也是<code>闭包的机制</code>。在第一次执行大函数，形成一个闭包，把一些信息存储在闭包中（传递的实参或者当前闭包中的声明的一些私有变量等信息），等到后面需要执行内部的匿名函数，在遇到非自己私有变量时，则向上级上下文中查找（也就是把之前存储在闭包中的信息获取）；</p>
</blockquote>
<p><strong>例题：</strong> 实现以下函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let res = fn(1,2)(3);</span><br><span class="line">console.log(res);  //=&gt; 6   1+2+3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn(...outerArgs)&#123;</span><br><span class="line">    //outerArgs 用于存储外层函数传入的值</span><br><span class="line">    return function(...innerArgs)&#123;</span><br><span class="line">        //innerArgs 用于存储内层函数传入的值</span><br><span class="line">        let arr = [...outerArgs,...innerArgs];</span><br><span class="line">        return arr.reduce(function(total,item)&#123;</span><br><span class="line">            return total + item;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="compose组合函数"><a href="#compose组合函数" class="headerlink" title="compose组合函数"></a>compose组合函数</h3><p><strong>例题：</strong> 实现以下函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">    在函数式编程当中有一个很重要的概念就是函数组合， 实际上就是把处理数据的函数像管道一样连接起来， 然后让数据穿过管道得到最终的结果。 例如：</span><br><span class="line">    const add1 = (x) =&gt; x + 1;</span><br><span class="line">    const mul3 = (x) =&gt; x * 3;</span><br><span class="line">    const div2 = (x) =&gt; x / 2;</span><br><span class="line">    div2(mul3(add1(add1(0)))); //=&gt;3</span><br><span class="line"></span><br><span class="line">    而这样的写法可读性明显太差了，我们可以构建一个compose函数，它接受任意多个函数作为参数（这些函数都只接受一个参数），然后compose返回的也是一个函数，达到以下的效果：</span><br><span class="line">    const operate = compose(div2, mul3, add1, add1)</span><br><span class="line">    operate(0) //=&gt;相当于div2(mul3(add1(add1(0)))) </span><br><span class="line">    operate(2) //=&gt;相当于div2(mul3(add1(add1(2))))</span><br><span class="line"></span><br><span class="line">    简而言之：compose可以把类似于f(g(h(x)))这种写法简化成compose(f, g, h)(x)，请你完成 compose函数的编写 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>借用柯里化函数的思想，先将函数集合以数组的形式存储在外层函数的执行上下文中，再在内层函数中接收参数，并在内层函数中循环执行需要操作的函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function compose(...args)&#123;</span><br><span class="line">    //args中存储的是需要操作的函数集合，存储在外层函数的上下文中</span><br><span class="line">    return function(val)&#123;</span><br><span class="line">        if(args.lenght === 0) return val;       //没有传函数参数</span><br><span class="line">        if(args.lenght === 1) return args[0](val);       //只传了一个函数参数</span><br><span class="line">        let arr = args.reverse();       //将数组翻转，便于后续操作</span><br><span class="line">        return arr.reduce((N,item)=&gt;&#123;</span><br><span class="line">            return item(N)</span><br><span class="line">        &#125;,val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redux源码中compose的实现方式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function compose(...funcs)&#123;</span><br><span class="line">    if(funcs.lenght === 0)&#123;</span><br><span class="line">        return arg =&gt; arg</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(funcs.lenght === 1)&#123;</span><br><span class="line">        return funcs[0]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return funcs.reduce((a,b)=&gt;(...args)=&gt;a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><blockquote>
<p>防止用户在短时间内多次触发，导致函数执行多次，函数防抖是指短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func,wait = 300,immediate = false)&#123;</span><br><span class="line">    let timer = null;</span><br><span class="line">    return function(...params)&#123;</span><br><span class="line">        let new = immediate &amp;&amp; !time;</span><br><span class="line">        clearTimeout(timer);            //触发函数清除定时器</span><br><span class="line">        timer = setTimeout(()=&gt;&#123;        //重新设置一个定时器，监听wait时间内是否发生二次触发</span><br><span class="line">            timer = null;       //手动回归到初始状态</span><br><span class="line">            !new? func.call(this,...params):null;</span><br><span class="line">        &#125;,wait)</span><br><span class="line">        </span><br><span class="line">        //immediate=true 执行第一次触发时返回的结果</span><br><span class="line">        new ? func.call(this,...params):null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><blockquote>
<p>函数节流可以想象成函数的冷却时间，指单位时间内只能执行一次，超过<code>冷却时间</code>才可以再一次执行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(func,wait = 300)&#123;</span><br><span class="line">    let timer = null,</span><br><span class="line">        previous = 0;       //记录上一次的操作时间</span><br><span class="line">    return function(...params)&#123;</span><br><span class="line">        let now = new Date(),</span><br><span class="line">            remaining = wait - (now - previous);     //记录还差多少时间触发函数</span><br><span class="line">        if(remaining &lt;= 0)&#123;     //两次操作时间间隔超过wait</span><br><span class="line">            window.clearTimeout(timer);</span><br><span class="line">            timer = null;</span><br><span class="line">            previous = new;</span><br><span class="line">            func.call(this,...params);</span><br><span class="line">        &#125;else if(!timer)&#123;       //!timer设置防止重复设置定时器</span><br><span class="line">            //两次操作时间间隔未超过wait,设置定时器，并传入剩余时间remaining</span><br><span class="line">            timer = setTimeout(()=&gt;&#123;</span><br><span class="line">                timer = null;</span><br><span class="line">                previous = new Date();</span><br><span class="line">                func.call(this,...params);</span><br><span class="line">            &#125;,remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/04/14/2020-04-14-Promise-md/</url>
    <content><![CDATA[<h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><blockquote>
<p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</p>
</blockquote><a id="more"></a>
<p><code>Promise</code> 是一个<strong>构造函数</strong>，接收一个函数作为参数，返回一个 <strong>Promise 实例</strong>。一个 Promise 实例有三种状态，分别是 <code>pending</code>、<code>fulfilled</code> 和 <code>rejected</code>，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 fulfilled 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 <code>then</code> 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。<strong>这个回调函数属于微任务</strong>，会在本轮事件循环的末尾执行。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><code>promise</code> 是一个包含了兼容promise规范then方法的对象或函数</p>
<p><code>thenable</code> 是一个包含then方法的对象或函数</p>
<p><code>value</code> 是任何的JavaScript值。（包括undefined、thenable、promise等）</p>
<p><code>exception</code> 是由<code>throw</code>表达式抛出来的值</p>
<p><code>reason</code> 是一个用于描述Promise被拒绝原因的一个值</p>
<h2 id="手写一个Promise"><a href="#手写一个Promise" class="headerlink" title="手写一个Promise"></a>手写一个Promise</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PENDING = &quot;pending&quot;;</span><br><span class="line">const RESOLVED = &quot;resolved&quot;;</span><br><span class="line">const REJECTED = &quot;rejected&quot;;</span><br><span class="line"></span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  // 保存初始化状态</span><br><span class="line">  var self = this;</span><br><span class="line"></span><br><span class="line">  // 初始化状态</span><br><span class="line">  this.state = PENDING;</span><br><span class="line"></span><br><span class="line">  // 用于保存 resolve 或者 rejected 传入的值</span><br><span class="line">  this.value = null;</span><br><span class="line"></span><br><span class="line">  // 用于保存 resolve 的回调函数</span><br><span class="line">  this.resolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 用于保存 reject 的回调函数</span><br><span class="line">  this.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 状态转变为 resolved 方法</span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br><span class="line">    if (value instanceof MyPromise) &#123;</span><br><span class="line">      return value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变，</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = RESOLVED;</span><br><span class="line"></span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.resolvedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 状态转变为 rejected 方法</span><br><span class="line">  function reject(value) &#123;</span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = REJECTED;</span><br><span class="line"></span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.rejectedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将两个方法传入函数执行</span><br><span class="line">  try &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // 遇到错误时，捕获错误，执行 reject 函数</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line">  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br><span class="line">  onResolved =</span><br><span class="line">    typeof onResolved === &quot;function&quot;</span><br><span class="line">      ? onResolved</span><br><span class="line">      : function(value) &#123;</span><br><span class="line">          return value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  onRejected =</span><br><span class="line">    typeof onRejected === &quot;function&quot;</span><br><span class="line">      ? onRejected</span><br><span class="line">      : function(error) &#123;</span><br><span class="line">          throw error;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  // 如果是等待状态，则将函数加入对应列表中</span><br><span class="line">  if (this.state === PENDING) &#123;</span><br><span class="line">    this.resolvedCallbacks.push(onResolved);</span><br><span class="line">    this.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果状态已经凝固，则直接执行对应状态的函数</span><br><span class="line"></span><br><span class="line">  if (this.state === RESOLVED) &#123;</span><br><span class="line">    onResolved(this.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (this.state === REJECTED) &#123;</span><br><span class="line">    onRejected(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>变量提升</title>
    <url>/2020/08/13/2020-08-13-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-md/</url>
    <content><![CDATA[<h3 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h3><blockquote>
<p>变量提升是指，在当前上下文中（全局/私有/块级作用域），JS代码自上而下执行之前，浏览器会预处理一些代码（可以理解为此法解析的一个环节，此法解析一定发生在代码执行之前）,是 JavaScript 将所有声明提升到当前作用域顶部的默认行为。</p>
</blockquote><a id="more"></a>
<p>变量提升阶段，会将当前上下文中的所有带var和function关键字的语句进行提前的声明或者定义。</p>
<ul>
<li>带var关键字的语句只会提前声明</li>
<li>带function关键字的语句会提前声明加定义</li>
</ul>
<blockquote>
<p>在这里声明（declare）和定义（defined）的区别在于是否对提升的变量进行赋值操作。例如：“var a；”这个操作只是声明，而“var a = 1;”这个操作是指声明加定义。</p>
</blockquote>
<p><strong>通过几个实例来展示变量提升的常见场景</strong></p>
<h5 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h5><blockquote>
<p>带var关键字的语句提前声明</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代码执行之前：全局上下文中的变量提升</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">var a = 12;</span><br><span class="line">a = 13;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">/* 上述代码在进行变量提升之后变成以下形式</span><br><span class="line"> *</span><br><span class="line"> *  var a;</span><br><span class="line"> *  console.log(a);  =&gt; undefined</span><br><span class="line"> *  a = 12;          //将a赋值为12</span><br><span class="line"> *  a = 13;          //将a赋值为13</span><br><span class="line"> *  console.log(a);  =&gt; 13</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h5 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h5><blockquote>
<p>带function关键字的语句提前声明加定义</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代码执行之前：全局上下文中的变量提升</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line">function func()&#123;</span><br><span class="line">    var a = 12;</span><br><span class="line">    console.log(&quot;OK&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 上述代码在进行变量提升之后变成以下形式</span><br><span class="line"> *</span><br><span class="line"> *  function func()&#123;</span><br><span class="line"> *      var a;      //私有作用域中的变量提升</span><br><span class="line"> *      a = 12;</span><br><span class="line"> *      console.log(&quot;OK&quot;);</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  func();   =&gt;  OK</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在正式项目中，为了防止function提前定义，可以使用” var func = function(){ } “ 这种函数表达式的方式来创建函数。</p>
</blockquote>
<h5 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h5><blockquote>
<p>let和const声明的变量不会被提前</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a)  //=&gt;Uncaught ReferenceError:Cannot access &apos;a&apos; before initialization  不能在let声明之前使用变量</span><br><span class="line">let a = 12;</span><br><span class="line">a = 13;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>

<h5 id="实例4"><a href="#实例4" class="headerlink" title="实例4"></a>实例4</h5><blockquote>
<p>基于var或者function在全局上下文中声明的变量（全局变量）会“映射“到全局对象window上。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 12;</span><br><span class="line">console.log(a);   //=&gt;12</span><br><span class="line">console.log(window.a);  //=&gt;12</span><br><span class="line"></span><br><span class="line">window.a = 13</span><br><span class="line">console.log(a);   //=&gt;13</span><br></pre></td></tr></table></figure>

<h5 id="实例5"><a href="#实例5" class="headerlink" title="实例5"></a>实例5</h5><blockquote>
<p>存在条件判断时，无论条件是否成立，都要进行变量提升，==新版本在条件体中的function提升的时候值声明不定义==</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func();     //=&gt; 新版本浏览器  undefined</span><br><span class="line">            //=&gt; 旧版本浏览器(ie10以下)  ok</span><br><span class="line">if(!(&quot;a&quot; in window))&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    function func()&#123;</span><br><span class="line">        console.log(&quot;ok&quot;)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">console.log(a);    //=&gt;undefined</span><br></pre></td></tr></table></figure>

<h5 id="实例6"><a href="#实例6" class="headerlink" title="实例6"></a>实例6</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fn();</span><br><span class="line">function fn()&#123; console.log(1); &#125;</span><br><span class="line">fn();</span><br><span class="line">function fn()&#123; console.log(2); &#125;</span><br><span class="line">fn();</span><br><span class="line">var fn = function&#123; console.log(3); &#125;    //=&gt;执行上下文时，fn重新赋值</span><br><span class="line">fn();</span><br><span class="line">function fn()&#123; console.log(4); &#125;</span><br><span class="line">fn();</span><br><span class="line">function fn()&#123; console.log(5); &#125;</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line">//=&gt; 555333</span><br></pre></td></tr></table></figure>

<h5 id="实例7"><a href="#实例7" class="headerlink" title="实例7"></a>实例7</h5><blockquote>
<p>私有作用域下的变量提升</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line"></span><br><span class="line">function bar()&#123;</span><br><span class="line">    if(!foo)&#123;</span><br><span class="line">        var foo = 10;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();    //=&gt;10 </span><br><span class="line"></span><br><span class="line">/* 上述代码在进行变量提升之后变成以下形式</span><br><span class="line"> *  var foo;</span><br><span class="line"> *  function bar()&#123;</span><br><span class="line"> *      var foo;      //undefined</span><br><span class="line"> *      if(!foo)&#123;     //ture</span><br><span class="line"> *         foo = 10;</span><br><span class="line"> *      &#125;</span><br><span class="line"> *      console.log(foo);</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  foo = 1;</span><br><span class="line"> *  bar();    //=&gt;10</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p><strong>参考文献</strong></p>
<ul>
<li><a href="https://ke.qq.com/course/list/%E7%8F%A0%E5%B3%B0" target="_blank" rel="noopener">珠峰教育公开课</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>parseInt的第二个参数</title>
    <url>/2020/08/19/2020-08-19-parseInt%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0-md/</url>
    <content><![CDATA[<blockquote>
<p>parseInt([value],[radix])</p>
</blockquote>
<ul>
<li>[value]会被解析成字符串</li>
<li>[radix]表示要解析的数字的基数。该值介于2~36之间。如果radix省略或者传0，则将以10为基数来解析；如果以“0x”开头，以16为基数；如果redix小于2或者大于36，则parseInt()返回NaN。</li>
</ul>
<a id="more"></a>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [10.18,0,10,25,23]</span><br><span class="line">arr = arr.map(parseInt);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * arr = arr.map((item,index)=&gt;&#123;</span><br><span class="line">     //循环遍历数组中的每一项，触发回调函数</span><br><span class="line">     //每一次传递当前项和当前项的索引</span><br><span class="line"> &#125;)</span><br><span class="line"> =&gt;</span><br><span class="line"> parseInt(&apos;10.18&apos;,0)    =&gt;10</span><br><span class="line"> parseInt(&apos;0&apos;,1)        =&gt;NaN</span><br><span class="line"> parseInt(&apos;10&apos;,2)       =&gt;2</span><br><span class="line"> parseInt(&apos;25&apos;,3)       =&gt;2</span><br><span class="line"> parseInt(&apos;23&apos;,4)       =&gt;11</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<blockquote>
<p>parseFloat不接受第二个参数</p>
</blockquote>
<p><strong>参考文献</strong></p>
<p><a href="https://www.w3school.com.cn/jsref/jsref_parseInt.asp" target="_blank" rel="noopener">W3school</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的底层运行机制（堆栈内存）</title>
    <url>/2020/08/20/2020-08-20-JS%E7%9A%84%E5%BA%95%E5%B1%82%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%88%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%89-md/</url>
    <content><![CDATA[<h3 id="JS的底层运行机制"><a href="#JS的底层运行机制" class="headerlink" title="JS的底层运行机制"></a>JS的底层运行机制</h3><h4 id="JS的运行环境"><a href="#JS的运行环境" class="headerlink" title="JS的运行环境"></a>JS的运行环境</h4><ol>
<li>浏览器(引擎)</li>
<li>node(V8引擎)</li>
<li>webview(V8引擎)</li>
</ol>
<a id="more"></a>
<h4 id="代码执行的环境–ECStack"><a href="#代码执行的环境–ECStack" class="headerlink" title="代码执行的环境–ECStack"></a>代码执行的环境–ECStack</h4><ul>
<li>ECStack(Execution Context Stack)</li>
</ul>
<blockquote>
<p>ECStack(Execution Context Stack)执行环境栈=&gt;栈内存（从内存条中分配出来的一块内存）</p>
</blockquote>
<ul>
<li><p>EC(Execution context)</p>
<blockquote>
<p>在编程语言中，代码执行时，为了区分全局和函数所执行所处的不同的作用域（目的是为了区分每个词法作用域下代码的独立性），浏览器会创建EC(Execution context)执行上下文（代码所在的词法作用域，或代码执行的范围）</p>
</blockquote>
</li>
<li><p>GO(Global Object)</p>
<blockquote>
<p>浏览器会将供JS调用的属性和方法存放在GO中（内置对象），浏览器会创建一个名为window的变量指向这个对象。</p>
</blockquote>
</li>
<li><p>VO(Variable Object)</p>
<blockquote>
<p>代码执行时，会创建变量，VO就是用来存储这些变量的空间。VO通常用来存储全局变量(因为全局变量一般不释放)，而私有上下文中的变量存储在AO(active object)中，AO是VO的一种(AO活动对象，通常是指的进栈出栈创建比较频繁的对象)。</p>
</blockquote>
</li>
</ul>
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/525fa4c0-e1ed-11ea-8bd0-2998ac5bbf7e.png">

<h4 id="函数的创建和执行"><a href="#函数的创建和执行" class="headerlink" title="函数的创建和执行"></a>函数的创建和执行</h4><blockquote>
<p>函数创建时，会新建一个堆内存来存储代码块。在函数执行时，会取出存放在堆中的代码，同时创建一个EC（函数的执行上下文）来供代码执行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x =[12,23]</span><br><span class="line">function fn(y)&#123;</span><br><span class="line">    y[0] = 100;</span><br><span class="line">    y = [100];</span><br><span class="line">    y[1] = 200;</span><br><span class="line">    console.log(y);</span><br><span class="line">&#125;</span><br><span class="line">fn(x);</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure>

<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/aa97b860-e212-11ea-8ff1-d5dcf8779628.png">

<p><strong>创建函数</strong></p>
<ol>
<li>开辟堆内存（16进制得到内存地址）</li>
<li>声明当前函数的作用域（函数创建的上下文才是他的作用域，和在那执行的无关）</li>
<li>把函数的代码以字符串的形式存储在堆内存中（函数再不执行的情况下，只是存储在堆内存中的字符串）</li>
<li>将函数堆的地址，放在栈中供变量调用（函数名）</li>
</ol>
<p><strong>执行函数</strong></p>
<ol>
<li>会形成一个全新的执行上下文EC(xx)（目的是供函数体中的代码执行），然后进栈（ECStack执行环境栈）执行</li>
<li>在私有上下文中有一个存放变量的变量对象AO(xx)</li>
<li>代码执行之前需要做的事<ul>
<li>初始化作用域链&lt;自己的上下文，函数的作用域&gt;</li>
<li>初始化this（箭头函数没有this）</li>
<li>初始化arguments实参集合（箭头函数没有arguments）</li>
<li>形参赋值（形参变量是函数的私有变量，需要存储在AO中）（<a href="">新版浏览器形参赋值的坑</a>）</li>
<li>变量提升（在私有上下文中声明的变量都是私有变量）</li>
<li>……</li>
</ul>
</li>
<li>代码执行（把之前在函数堆中存储的字符串拿过来在当前上下文中执行）</li>
</ol>
<blockquote>
<p>作用域链的查找机制，在代码执行过程中，遇到一个变量，首先查看是否是自己的私有变量，如果是自己的私有变量，就直接操作私有变量，如果不是自己的私有变量，则按照<code>scope-chain</code>,向上级上下文查找，如果上级有则拿过来操作，没有则一直向上查找，直到EC(G)</p>
</blockquote>
<ol start="5">
<li>根据实际情况判断当前上下文是否出栈释放</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型转换</title>
    <url>/2020/08/15/2020-08-15-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-md/</url>
    <content><![CDATA[<h3 id="数据类型转换的核心"><a href="#数据类型转换的核心" class="headerlink" title="数据类型转换的核心"></a>数据类型转换的核心</h3><a id="more"></a>

<h4 id="把其他数据类型转换成-Number-类型"><a href="#把其他数据类型转换成-Number-类型" class="headerlink" title="把其他数据类型转换成 Number 类型"></a>把其他数据类型转换成 Number 类型</h4><p><strong>1. 特定需要转换为Number的</strong> </p>
<ul>
<li>Number([val])</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Number(&apos;&apos;));            // 0</span><br><span class="line">console.log(Number(&apos;10&apos;));          // 10</span><br><span class="line">console.log(Number(&apos;10px&apos;));        // NaN</span><br><span class="line">console.log(Number(true));          // 1</span><br><span class="line">console.log(Number(false));         // 0</span><br><span class="line">console.log(Number(null));          // 0</span><br><span class="line">console.log(Number(undefined));     // NaN</span><br><span class="line">console.log(Number(Symbol(10));     // 报错</span><br><span class="line">console.log(Number(BigInt(10)));    // 10</span><br><span class="line">// 对象变为数字，应该先valueOf,没有原始值再toString变为字符串，最后把字符串转换为数字</span><br></pre></td></tr></table></figure>
<ul>
<li>parseInt/parseFloat([val])</li>
</ul>
<blockquote>
<p>parseInt机制：从字符串左侧第一个字符开始，查找有效字符（遇到非有效字符停止查找，不论后面是否还有数字字符），把找到的数字字符转化为数字，如果一个都没找到结果就是NaN（parseFloat多识别一个字符串）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(&quot;&quot;)    //NaN</span><br><span class="line">Number(&quot;&quot;)      // 0</span><br><span class="line">isNaN(&quot;&quot;)       //false</span><br><span class="line">parseInt(&quot;null&quot;)        //NaN</span><br><span class="line">Number(&quot;null&quot;)          // 0</span><br><span class="line">isNaN(&quot;null&quot;)           //false</span><br><span class="line">parseInt(&quot;12px&quot;)        //12</span><br><span class="line">Number(&quot;12px&quot;)          //NaN</span><br><span class="line">isNaN(&quot;12px&quot;)           //true</span><br><span class="line">parseFloat(&quot;1.6px&quot;) + parseInt(&quot;1.2px&quot;) + typeof parseInt(null)       //2.6number</span><br><span class="line">isNaN(Number(!!Number(parseInt(&quot;0.8&quot;))))        //false</span><br><span class="line">typeof !parseInt(null) + !isNaN(null)       //booleantrue</span><br></pre></td></tr></table></figure>

<p><strong>2. 隐式转换（浏览器内部默认先转换为Number在进行计算的）</strong></p>
<ul>
<li>isNaN([val])</li>
<li>数学运算（特殊情况：+ 在出现字符串的情况下不是数学运算，是字符串拼接）</li>
<li>在 == 比较的时候，有些值需要转换为数字再进行比较</li>
<li>…</li>
</ul>
<h4 id="把其他数据类型转换成-String-类型"><a href="#把其他数据类型转换成-String-类型" class="headerlink" title="把其他数据类型转换成 String 类型"></a>把其他数据类型转换成 String 类型</h4><p><strong>1. 可以使用的转换方法</strong></p>
<ul>
<li>toString()</li>
</ul>
<blockquote>
<p>把其他类型转换为字符串，一般都是直接用“”包起来，只有 { } 普通对象调取toString是调取Object.prototype.toString()方法，对象原型上的toString方法不是用来转换字符串的，而是用来检测数据类型的，返回结果为”[object Object]”</p>
</blockquote>
<ul>
<li>String()</li>
</ul>
<p><strong>2. 隐式转换（一般都是调用其toString）</strong></p>
<ul>
<li>加号运算的时候，如果某一边出现了字符串，则是字符串拼接</li>
<li>把对象转化为数字，需要先toString（）转为字符串，再转为数字</li>
<li>基于alert/confirm/prompt/document.write…这些方式输出内容，把内容先转化为字符串，然后在输出</li>
<li>…</li>
</ul>
<h4 id="把其他数据类型转换成-Boolean-串类型"><a href="#把其他数据类型转换成-Boolean-串类型" class="headerlink" title="把其他数据类型转换成 Boolean 串类型"></a>把其他数据类型转换成 Boolean 串类型</h4><p><strong>1. 可以使用的转换方法</strong></p>
<ul>
<li>! 转换成布尔值之后再取反</li>
<li>!! 转换成布尔值</li>
<li>Boolean([val])</li>
</ul>
<p><strong>2. 隐式转换（一般都是调用其toString）</strong></p>
<ul>
<li>在循环或条件判断中，条件处理的结果就是布尔类型值</li>
<li>…</li>
</ul>
<blockquote>
<p>只有‘0、NaN、null、undefined、空字符串’这几个值会变成布尔的false,其余值都是true</p>
</blockquote>
<h4 id="在等号转换过程中，数据转换的规则"><a href="#在等号转换过程中，数据转换的规则" class="headerlink" title="在等号转换过程中，数据转换的规则"></a>在等号转换过程中，数据转换的规则</h4><p><strong>1. 类型一样的几个特殊点</strong></p>
<ul>
<li>{} == {}   false  对象比较的是堆内存引用地址</li>
<li>[] == []   false</li>
<li>NaN == NaN false </li>
</ul>
<p><strong>2. 类型不一样的转换规则</strong></p>
<ul>
<li>null == undefined 的结果为true，但是换成===的结果是false（因为类型不一致），剩下null、undefined和其他任何数据类型值都不相等</li>
<li>字符串 == 对象 ，要把对象转换成字符串</li>
<li>剩下如果两边数据类型不一致，都需要转换为数字在进行比较</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>实例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([] == false);</span><br><span class="line">console.log(![] == false);</span><br><span class="line"></span><br><span class="line">// =&gt;  true true</span><br><span class="line"></span><br><span class="line">/*  console.log([] == false)</span><br><span class="line"> *  对象 == 布尔  类型不一致，都转换成数字比较</span><br><span class="line"> *  []对象转换成数字之前需要使用toString（）转换成字符串</span><br><span class="line"> *  即  [] =&gt; &apos;&apos; =&gt; 0 ，  false  =&gt; 0</span><br><span class="line"> *  所以结果为true</span><br><span class="line"> *</span><br><span class="line"> *  console.log(![] == false)</span><br><span class="line"> *  先计算 ![] 的值,将[]转为boolean再取反  =&gt; false</span><br><span class="line"> *  即  false == false</span><br><span class="line"> *  所以结果为true</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p><strong>实例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let result = 10 + false +undefined + [] + &quot;Tencent&quot; + null + true + &#123;&#125;;</span><br><span class="line">console.log(result)</span><br><span class="line"></span><br><span class="line">// 10 + false =&gt; 10</span><br><span class="line">// 10 + undefined =&gt; NaN        任何数字加上NaN都是NaN</span><br><span class="line">// NaN + [] =&gt; &quot;NaN&quot;</span><br><span class="line">// &quot;NaN&quot; + &quot;Tencent&quot; =&gt; &quot;NaNTencent&quot;</span><br><span class="line">// 后面都是字符串拼接</span><br><span class="line">// &quot;NaNTencentnulltrue[object Object]&quot;</span><br></pre></td></tr></table></figure>

<p><strong>实例3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//加号即使笔辩出现字符串或者对象，也不一定是字符串拼接： ++i/i++/+i 这种情况下是数学运算</span><br><span class="line">let n = &quot;10&quot;;</span><br><span class="line">console.log(++n);   // 11</span><br><span class="line">console.log(+n);    // 10</span><br><span class="line"></span><br><span class="line">// &#123;&#125; + 0</span><br><span class="line">// 在这中情况下，左边的&#123;&#125;会被识别成一个代码块，不参与运算</span><br><span class="line">// 类似于function fn()&#123;&#125; + 0</span><br><span class="line">// 运算值处理 +0 =&gt; 0</span><br><span class="line"></span><br><span class="line">// (&#123;&#125; + 0)参与到数学运算中 &quot;[object Object]0&quot;</span><br><span class="line"></span><br><span class="line">// 0+&#123;&#125; 是数学运算中 &quot;0[object Object]&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2020/01/31/2020-1-31-git-md/</url>
    <content><![CDATA[<h3 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h3><blockquote>
<p>git是一款开源的分布式版本控制系统，能够有效、高速的处理从小到大的项目版本管理。</p>
</blockquote>
<a id="more"></a>
<p>市面上常见的版本控制器有两种：</p>
<ul>
<li>分布式的 Git</li>
<li>集中式的 SVN</li>
</ul>
<h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><h4 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h4><p>创建仓库</p>
<pre><code>1.进入需要创建代码仓库的文件夹      cd [文件路径]
2.初始化代码仓库                    git init
3.远程拉去仓库到本地                git clone</code></pre><p>添加文件到仓库</p>
<pre><code>1.添加文件到暂存区
    + 添加单个文件到暂存区          git add [文件名]
    + 添加所用文件到暂存区          git add ./-A
2.把暂存区文件提交到历史区
    + git commit -m&apos;描述信息&apos;
    + 建议使用  git commit 再填写 git message
3.查看工作区状态
    + git status
4.对比工作区变化
    + git diff</code></pre><p>仓库配置</p>
<pre><code>1.配置全局用户名和邮箱
    + git config --global user.name &quot;[name]&quot;
    + git config --global user,email &quot;[email address]&quot;
2.配置当前仓库用户名和密码
    + git config user.name &quot;[name]&quot;
    + git config user.email &quot;[email address]&quot;</code></pre><p>将本地仓库信息提交到远程仓库</p>
<pre><code>1.建立本地仓库与远程仓库的连接
    + 查看建立连接      git remote -v
    + 建立连接          git remote add origin [仓库地址]
    + 删除连接          git remote rm origin 
2.先拉取在提交
    + 拉取              git pull origin master
    + 提交              git push origin master</code></pre><p>克隆远程仓库</p>
<pre><code>git clone [本地仓库] [别名（可省略）]
1.初始化本地仓库
2.关联远程仓库
3.默认内容拉取到本地</code></pre><h4 id="代码版本"><a href="#代码版本" class="headerlink" title="代码版本"></a>代码版本</h4><pre><code>1.查看历史版本信息
    + git log                       提交详情
    + git log --pretty=oneline      提交简介
2.回退版本提交
    + git reset --hard HEAD         回退到当前最新提交
    + git reset --hard HEAD^        回退到上次提交
    + git reset --hard HEAD~n       回退到上n次提交
    + git reset --hard commitid     回退到某次提交
3.重返未来版本
    + git reflog    查看历史提交以及被回退的提交（该记录有时限，且只在本地）
    + git reset --herd commitid     回到未来版本
4.撤销修改
    + 文件去撤销文件（没有提交到暂存区/没有git add）撤销修改    git checkout [文件名]
    + 暂存区撤销文件
        -将暂存区文件撤销到工作区   git reset HEAD 文件不带--hard
        -撤销修改                   git checkout [文件名]
5.删除文件
    + 从版本库中删除文件（修改后需要提交）  git rm [文件名]
    + 恢复删除      参考撤销修改
    + 从版本库中删除文件，本地不删除        git rm --cached [文件名]</code></pre><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>创建和合并分支</p>
<pre><code>1.创建分支
    - 仅创建        git branch [分支名]
    - 创建并切换    git checkout -b [分支名]
2.切换分支          git checkout [分支名]
3.合并分支
        - 合并某分支到当前分支       git merge
        - git rebase   无特殊需求不建议使用
4.删除分支
    - 删除本地未合并分支    git branch -D
    - 删除温蒂已合并分支    git branch -d
    - 删除远程分支          git push origin -d
                            git push [远程仓库名] -d [分支名]
5.查看分支
    - 查看当前分支          git branch
    - 查看所有分支信息      git branch -a
6.合并分支，解决分支冲突
    - 将要合并的分支更新到最新
    - 切换到主分支
    - 合并分支
    - 解决合并时的conflict
    - 提交到版本库
    - 合并成功
    - 查看分支状态  git log --graph
                    git log --graph --pretty=oneline --abbrey-commit
7.开发完成需要提交PR/MR</code></pre><p>暂存修改</p>
<pre><code>1.暂存工作现场      git stash
2.恢复工作现场
    - 恢复          git stash apply
    - 删除          git stash drop
    - 恢复+删除     git stash pop</code></pre><p>多人协作</p>
<pre><code>1.查看远程库信息
    - 详细      git remote -v
    - 不详细    git remote
2.更新推出远程库
    - 更新远程库信息                git fetch
    - 将远程库最新更新到本地库       git pull
    - 将本地修改推送到远程库         git push
                                   git push origin [分支名]
3.本地分支与远程分支交互
    - 使用远程分支A创建本地分支     git checkout -b origin/A
    - 将本地分支与远程分支关联      git branch --set-upstream A origin/A</code></pre><h4 id="代码版本tag"><a href="#代码版本tag" class="headerlink" title="代码版本tag"></a>代码版本tag</h4><pre><code>1.查看tag
    - 本地tag       git tag
    - 远程tag       git tag -r
2.操作tag
    - 添加tag       
        + 给当前版本添加tag     git tag [标签名]
        + 给历史版本添加tag     git tag [标签名] commitid
    - 删除tag
        + 删除本地标签          git tag -d [标签名]
        + 删除远程标签          git push origin -d
    - 推送到远端仓库            git push origin [标签名]
        + 推送所有未提交tag     git push origin --tags
    - 更新到本地        git pull origin --tags
tag与branch的操作基本一致，因为tag就是一个仅可读的branch</code></pre><blockquote>
<p>可以使用 git help 查看常用的命令，使用 git help -a 可以查看所有的git命令</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery源码解读（一）</title>
    <url>/2020/02/03/2020-2-3-jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89-md/</url>
    <content><![CDATA[<h3 id="jQuery源码解读（一）"><a href="#jQuery源码解读（一）" class="headerlink" title="jQuery源码解读（一）"></a>jQuery源码解读（一）</h3><a id="more"></a>
<h4 id="JQ的基本概括"><a href="#JQ的基本概括" class="headerlink" title="JQ的基本概括"></a>JQ的基本概括</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    &quot;use strict&quot;</span><br><span class="line">    if(typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;)&#123;</span><br><span class="line">        //......</span><br><span class="line">        //支持CommonJS模块规范的执行</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //可以理解为浏览器环境或者（Web-view）环境</span><br><span class="line">        //浏览器环境中 global===window</span><br><span class="line">        // factory === function(window,noGlobal)&#123;&#125;</span><br><span class="line">        factory(global);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(typeof window !== &quot;undefind&quot; ? window :this, function (window,noGlobal)&#123;</span><br><span class="line">    //window === window</span><br><span class="line">    //noGlobal === undefined</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    //......</span><br><span class="line">    </span><br><span class="line">    var version =  &quot;3.4.1&quot;,</span><br><span class="line">        jQuery = function (selector,context)&#123;</span><br><span class="line">            return new jQuery.fn.init(selector,context);</span><br><span class="line">        &#125;;</span><br><span class="line">    //jQuery 是一个类，jQuery是给原型设置一个别名</span><br><span class="line">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">        //公共属性和方法</span><br><span class="line">        jquery: version,</span><br><span class="line">        constructor: jQuery,    //保证类的完整性</span><br><span class="line">        length:0，</span><br><span class="line">        </span><br><span class="line">        //转化为数组的方法</span><br><span class="line">        toArray: function()&#123;</span><br><span class="line">            //this ：一般指向当前类的jQuery实例</span><br><span class="line">            return slice.call(this);</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        //把JQ对象转化为原生JS对象</span><br><span class="line">        get:function(num)&#123;</span><br><span class="line">            if(num == null)&#123;</span><br><span class="line">                return slice.call(this);</span><br><span class="line">            &#125;</span><br><span class="line">            return num &lt; 0 ? this[num + this.length]: this[num];</span><br><span class="line">        &#125;,</span><br><span class="line">        //jQ中的遍历方法</span><br><span class="line">         each:function()&#123;</span><br><span class="line">            return jQuery.each(this,callback);</span><br><span class="line">        &#125;,</span><br><span class="line">        //eq方法</span><br><span class="line">        eq:function(i)&#123;</span><br><span class="line">            var len = this.length,</span><br><span class="line">                j = +i + ( i &lt; 0 ? len :0);</span><br><span class="line">                return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [this[j]] ; []);</span><br><span class="line">        &#125;,</span><br><span class="line">        //......</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    //jQuery是一个普通对象</span><br><span class="line">    jQuery.ajax = function(url,options)&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;；</span><br><span class="line">    </span><br><span class="line">    if(!noGlobal)&#123;</span><br><span class="line">        //把jQuery赋值给window下的jQuery和$</span><br><span class="line">        window.jQuery = window.$ = jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="jQuery上的方法"><a href="#jQuery上的方法" class="headerlink" title="jQuery上的方法"></a>jQuery上的方法</h4><blockquote>
<p>jQuery 的方法写在了两个位置上：一个将它当成类是写在它的原型上，一个是将它当成普通对象写在它的对象上，所以调用方法也不一样。对象上用 jQuery.或者$. 就可以调用，原型上要基于实例调用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.原型上 jQuery.prototype = &#123;...&#125;</span><br><span class="line">//      $().get()       只有jQuery实例才可以调用</span><br><span class="line">//2.对象上 jQuery.ajax = ...</span><br><span class="line">//      $.ajax()      直接调用</span><br><span class="line">// 所以实例不能调用ajax()方法</span><br></pre></td></tr></table></figure>

<h4 id="JQ的each方法"><a href="#JQ的each方法" class="headerlink" title="JQ的each方法"></a>JQ的each方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*JQ 中只有一个each 方法，用来遍历数组、对象、类数组的每一项</span><br><span class="line"> *  each:function()&#123;</span><br><span class="line"> *      return jQuery.each(this,callback);</span><br><span class="line"> *&#125;,</span><br><span class="line"> *</span><br><span class="line"> *  $a.each()最后还是会转化为 $.each($a) 这种模式</span><br><span class="line"> */</span><br><span class="line">$navList.each(function(index,item)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;)</span><br><span class="line">$.each($navList,function(index,item)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="each-源码"><a href="#each-源码" class="headerlink" title="each()源码"></a>each()源码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">each:function()&#123;</span><br><span class="line">    var length,i = 0;</span><br><span class="line">    </span><br><span class="line">    if(isArrayLike(obj))&#123;</span><br><span class="line">        length = obj.length;</span><br><span class="line">        for(;i &lt; length; i++)&#123;</span><br><span class="line">            if(callback.call(obj[i],i,obj[i] === false)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(i in obj)&#123;</span><br><span class="line">            if(callback.call(obj[i],i,obj[i] === false)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检测当前对象是数组还是类数组的方法"><a href="#检测当前对象是数组还是类数组的方法" class="headerlink" title="检测当前对象是数组还是类数组的方法"></a>检测当前对象是数组还是类数组的方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isArrayLike(obj)&#123;</span><br><span class="line">    var length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,</span><br><span class="line">        type = toType(obj);</span><br><span class="line">        </span><br><span class="line">    if(ifFunction(obj) || isWindow(obj))&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return type === &quot;array&quot; || length === 0 || typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
</search>

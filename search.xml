<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>封装一个常用工具方法类库</title>
      <link href="/2020/11/26/2020-11-26-%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95%E7%B1%BB%E5%BA%93-md/"/>
      <url>/2020/11/26/2020-11-26-%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95%E7%B1%BB%E5%BA%93-md/</url>
      
        <content type="html"><![CDATA[<h2 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h2><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/ffbdf6a0-27dc-11eb-899d-733ae62bed2f.png"><a id="more"></a><h3 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h3><h4 id="借用方法"><a href="#借用方法" class="headerlink" title="借用方法"></a>借用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let class2type = &#123;&#125;,</span><br><span class="line">    toString = class2type.toString,</span><br><span class="line">    hasOwn = class2type.hasOwnProperty,</span><br><span class="line">    getProto = Object.getPrototypeOf,</span><br><span class="line">    fnToString = hasOwn.toString,</span><br><span class="line">    ObjectFunctionString = fnToString.call(Object),</span><br><span class="line">    utils = &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="toType"><a href="#toType" class="headerlink" title="toType"></a>toType</h4><blockquote><p>检测数据类型的方法</p><ul><li><code>typeof</code></li><li>instanceof</li><li>constructor</li><li><code>Object.prototype.toString.call()</code></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 简历映射表</span><br><span class="line">let class2type = &#123;&#125;;</span><br><span class="line">[&apos;String&apos;,&apos;Boolean&apos;,&apos;Number&apos;,&apos;Array&apos;,&apos;Function&apos;,&apos;Object&apos;,&apos;Date&apos;,&apos;RegExp&apos;,&apos;GeneratorFunction&apos;,&apos;Symbol&apos;,&apos;Bigint&apos;,&apos;Error&apos;].forEach(item=&gt;&#123;</span><br><span class="line">    class2type[`[object $&#123;item&#125;]`] = item.toLowCase();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const toType = function toType(obj)&#123;</span><br><span class="line">    // null/undefined </span><br><span class="line">    if(obj == null) return obj + &quot;&quot;;</span><br><span class="line">    let type = typeof obj;</span><br><span class="line">    if(!/^(object|function)$/i.test(type)) return type;</span><br><span class="line">    return class2type[Object.prototype.toString.call(obj)] || &quot;object&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isFunction-amp-isWindow"><a href="#isFunction-amp-isWindow" class="headerlink" title="isFunction &amp; isWindow"></a>isFunction &amp; isWindow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const isFunction = function isFunction(obj)&#123;</span><br><span class="line">    return typeof obj === &apos;function&apos; &amp;&amp; typeof obj.nodeType !== &apos;number&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isWindow = function isWindow(obj)&#123;</span><br><span class="line">    return obj !== null &amp;&amp; obj === obj.window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isArrayLike"><a href="#isArrayLike" class="headerlink" title="isArrayLike"></a>isArrayLike</h4><blockquote><p>JQuery的类数组判断虽然有缺陷，但是至今没有更好的可替代方案，毕竟是划时代产品啊</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 核心思想：length存在，并存在length-1的索引</span><br><span class="line">const isArrayLike = function isArrayLike(obj)&#123;</span><br><span class="line">    let length = !!obj &amp;&amp; length in obj &amp;&amp; obj.length;</span><br><span class="line">    let type = typeof obj;</span><br><span class="line">    return type === &apos;array&apos; || length === 0 || </span><br><span class="line">        typeof length === &apos;number&apos; &amp;&amp; length&gt;0 &amp;&amp;(length-1) in obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isPlainObject"><a href="#isPlainObject" class="headerlink" title="isPlainObject"></a>isPlainObject</h4><blockquote><p>检测是否为纯粹（朴素）对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const isPlainObject = function isPlaintObject(obj)&#123;</span><br><span class="line">    let proto,Ctor;</span><br><span class="line">    if(!obj || typeof obj === &apos;[object Object]&apos;) return false;</span><br><span class="line">    proto = Object.getPrototypeOf(obj);</span><br><span class="line">    if(!proto) return true;</span><br><span class="line">    Ctor = Object.hasOwnProperty.call(proto,&apos;constructor&apos;) &amp;&amp; proto.constructor;</span><br><span class="line">    return typeof Ctor === &apos;function&apos; &amp;&amp; Ctor.toString() === Ctor.toString.call(Object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isEmptyObject"><a href="#isEmptyObject" class="headerlink" title="isEmptyObject"></a>isEmptyObject</h4><blockquote><p>检测是否为空对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const isEmptyObject = function isEmptyObject(obj)&#123;</span><br><span class="line">    let key = [</span><br><span class="line">        ...Object.keys(obj),</span><br><span class="line">        ...Object.getOwnPropertySmybols(obj)</span><br><span class="line">    ];</span><br><span class="line">    return key.length === 0 ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="each"><a href="#each" class="headerlink" title="each"></a>each</h4><blockquote><p>遍历数组、类数组、对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const each = function each(obj,callback)&#123;</span><br><span class="line">    callback = callback || Function.prototype;</span><br><span class="line">    if(isArrayLike(obj))&#123;</span><br><span class="line">        for(let i = 0; i &lt; obj.length; i++)&#123;</span><br><span class="line">            let item = obj[i];</span><br><span class="line">            let result = callback.call(item,item,i);</span><br><span class="line">            if(result === false) break;</span><br><span class="line">        &#125;</span><br><span class="line">        return obj</span><br><span class="line">    &#125;</span><br><span class="line">    for(let key in obj)&#123;</span><br><span class="line">        if(!obj.hasOwnProperty(key)) break;</span><br><span class="line">        let item = obj[key];</span><br><span class="line">        let result = callback(item,item,i);</span><br><span class="line">        if(result === false) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eachAll"><a href="#eachAll" class="headerlink" title="eachAll"></a>eachAll</h4><blockquote><p>支持Symbol属性的遍历</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const eachAll = function eachAll(obj,callback)&#123;</span><br><span class="line">    let keys = [</span><br><span class="line">        ...Object.keys(obj),</span><br><span class="line">        ...Object.hasOwnPropertySymbol(obj)</span><br><span class="line">    ];</span><br><span class="line">    for(let i = 0; i&lt;key.length;i++)&#123;</span><br><span class="line">        let key = keys[i];</span><br><span class="line">        let item = obj[key];</span><br><span class="line">        let result = callback.call(item,item,i);</span><br><span class="line">        if(result === false) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深浅克隆"><a href="#深浅克隆" class="headerlink" title="深浅克隆"></a>深浅克隆</h3><h4 id="shallowClone"><a href="#shallowClone" class="headerlink" title="shallowClone"></a>shallowClone</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 浅克隆</span><br><span class="line">const shallowClone = function shallowClone(obj)&#123;</span><br><span class="line">    let type = toType(obj);</span><br><span class="line">    let Ctor = obj.constructor;</span><br><span class="line">    if(/^(symbol|bigint)$/i.test(type)) return Object(obj);</span><br><span class="line">    if(/^(date|regexp)$/i.test(type)) return new Ctor(obj);</span><br><span class="line">    if(/^error$/i.test(type)) return new Ctor(obj.message);</span><br><span class="line">    if(/^function$/i.test(type))&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return obj.call(this,...args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(/^(object|array)$/i.test(type))&#123;</span><br><span class="line">        let result = new Ctor();</span><br><span class="line">        eachAll(obj,(_,key)=&gt;&#123;</span><br><span class="line">            result[key] = obj[key];</span><br><span class="line">        &#125;)</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deepClone"><a href="#deepClone" class="headerlink" title="deepClone"></a>deepClone</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const deepClone = function deepClone(obj,cache=new Set())&#123;</span><br><span class="line">    let type = toType(obj);</span><br><span class="line">    let Ctor = obj.constructor;</span><br><span class="line">    if(!/(object|array)/i.test(type)) return shallowClone();</span><br><span class="line">    if(cache.has(obj)) return obj;</span><br><span class="line">    cache.add(obj);</span><br><span class="line">    let result = new Ctor;</span><br><span class="line">    eachAll(obj,(item,key)=&gt;&#123;</span><br><span class="line">        result[key] = deepClone(item,chche);</span><br><span class="line">    &#125;)</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度合并"><a href="#深度合并" class="headerlink" title="深度合并"></a>深度合并</h3><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><blockquote><p>合并的几种情况的分析</p></blockquote><blockquote><p>A-&gt;options中的key值  B-&gt;params中的key值</p><ul><li>1.A&amp;B都是原始值类型:B替换A即可</li><li>2.A是对象&amp;B是原始值:抛出异常信息</li><li>3.A是原始值&amp;B是对象:B替换A即可</li><li>4.A&amp;B都是对象:依次遍历B中的每一项,替换A中的内容</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const merge = function merge(options,params = &#123;&#125;)&#123;</span><br><span class="line">    if(!isPlainObject(options) || !isPlainObject(params)) throw new TypeError(&apos;options and params must not be an plain object!&apos;);</span><br><span class="line">    options != null ? deepClone(options) : null;</span><br><span class="line">    params != null ? deepClone(params) : null;</span><br><span class="line">    eachAll(params,(_,key)=&gt;&#123;</span><br><span class="line">        let isA = isPlainObject(options[key]);</span><br><span class="line">        let isB = isPlainObject(params[key]);</span><br><span class="line">        if(isA &amp;&amp; !isB) throw new TypeError(`$&#123;key&#125; in params must be an object!`)</span><br><span class="line">        if(isA &amp;&amp; isB)&#123;</span><br><span class="line">            options[key] = merge(options[key],params[key]);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        options[key] = params[key];</span><br><span class="line">    &#125;);</span><br><span class="line">    return options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>axios的二次配置</title>
      <link href="/2020/11/24/2020-11-24-axios%E7%9A%84%E4%BA%8C%E6%AC%A1%E9%85%8D%E7%BD%AE-md/"/>
      <url>/2020/11/24/2020-11-24-axios%E7%9A%84%E4%BA%8C%E6%AC%A1%E9%85%8D%E7%BD%AE-md/</url>
      
        <content type="html"><![CDATA[<h2 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a>axios二次封装</h2><blockquote><p>axios配置优先级</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/c51bc1f0-2672-11eb-97b7-0dc4655d6e68.png"><a id="more"></a><blockquote><p>axios的配置项</p></blockquote><ul><li>url</li><li>method</li><li>baseURL * </li><li>transformRequest *</li><li>transformResponse *</li><li>headers *</li><li>params</li><li>data</li><li>timeout *</li><li>withCredentials *</li><li>responseType *</li><li>validateStatus *</li><li>…</li></ul><blockquote><p>后面带*的，是当前项目中绝大部分请求都公用的信息，偶尔有极个别的请求配置信息和它不一样，这类配置信息，我们应该统一设定，所有请求都用这些配置信息 =&gt; axios的二次封装/配置</p></blockquote><h3 id="axios-defaults"><a href="#axios-defaults" class="headerlink" title="axios.defaults"></a>axios.defaults</h3><blockquote><p>我们可以基于<code>axios.defaults</code>来配置项目的基本信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释的配置不是很常用--&gt;</span><br><span class="line"></span><br><span class="line">axios.defaults.baseURL = &apos;http://127.0.0.1:8888&apos;;   //服务器默认地址</span><br><span class="line"></span><br><span class="line">axios.defaults.timeout = 10000;     //设置超时时间</span><br><span class="line"></span><br><span class="line">axios.defaults.withCredential = true;   //允许携带资源凭证cookie</span><br><span class="line"></span><br><span class="line">&lt;!--axios.defaults.responseType = &apos;json&apos;;   //默认转化格式--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--axios.defaults.validateStatus = status =&gt;&#123;--&gt;</span><br><span class="line">&lt;!--    return status &gt;= 200 &amp;&amp; status &lt; 300;   //设置请求的成功范围--&gt;</span><br><span class="line">&lt;!--&#125;--&gt;</span><br><span class="line"></span><br><span class="line">// 真实项目中，大部分post请求，基于请求主体传递给服务器的格式，不期望是默认的json格式字符串，而是需要改为服务器要求的格式，例如：x-www-form-urlencoded，则需要我们统一基于transformRequest处理</span><br><span class="line">axios.defaults.transformRequest = [data =&gt;&#123;</span><br><span class="line">    // data是基于请求主体传递给服务器的信息，transformRequest只对post系列请求有用</span><br><span class="line">    return Qs.stringify(data);  // 返回的是啥，最后基于请求主体传递给服务器就是啥</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">&lt;!--axios.defaults.transformResponse = [data =&gt;&#123;    // =&gt; 一般不用这个属性，而是使用响应拦截器--&gt;</span><br><span class="line">&lt;!--    //这里可以处理返回的data(请求主体信息)，再将处理后的data返回除去--&gt;</span><br><span class="line">&lt;!--    return data;    //返回啥，以后拿到的就是啥--&gt;</span><br><span class="line">&lt;!--&#125;]--&gt;</span><br></pre></td></tr></table></figure><h3 id="基于webpack区分环境变量"><a href="#基于webpack区分环境变量" class="headerlink" title="基于webpack区分环境变量"></a>基于webpack区分环境变量</h3><ul><li>开发环境：测试服务器接口 <a href="http://168.1.12.8081" target="_blank" rel="noopener">http://168.1.12.8081</a></li><li>测试环境：模拟实际上线数据 =&gt; 测试人员测试 <a href="http://168.1.12.9000" target="_blank" rel="noopener">http://168.1.12.9000</a></li><li>生产环境：部署到真实的服务器上 <a href="http://api.BSmall.cn" target="_blank" rel="noopener">http://api.BSmall.cn</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//  基于webpack指定环境变量，在打包或运行时，实现自动切换地址</span><br><span class="line">let env = process.env.NODE_ENV;</span><br><span class="line">switch(env)&#123;</span><br><span class="line">    case &apos;development&apos;:</span><br><span class="line">        axios.defaults.baseURL = &apos;http://168.1.12.8081&apos;;</span><br><span class="line">        break;</span><br><span class="line">    case &apos;test&apos;:</span><br><span class="line">        axios.defaults.baseURL = &apos;http://168.1.12.9000&apos;;</span><br><span class="line">        break;</span><br><span class="line">    case &apos;production&apos;:</span><br><span class="line">        axios.defaults.baseURL = &apos;http://api.BSmall.cn&apos;;</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器axios-interceptors"><a href="#拦截器axios-interceptors" class="headerlink" title="拦截器axios.interceptors"></a>拦截器<code>axios.interceptors</code></h3><blockquote><p>请求拦截器:<code>axios.interceptors.request</code> 发生在axios整理完配置项之后，发送到飞速武器之前，请求拦截器一般是对配置项的进一步处理</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(config=&gt;&#123;    // config就是整理好的配置项</span><br><span class="line">    // 处理config，例如：在发送之前传递一个token到请求头中</span><br><span class="line">    let token = localStorage.getItem(&apos;token&apos;);</span><br><span class="line">    if(token)&#123;</span><br><span class="line">        // 按服务器要求的名称传递，常用X-Token或Authorzation</span><br><span class="line">        config.headers[X-Token] = token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return config;  // 返回处理后的config</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>响应拦截器:<code>axios.interceptors.response</code> 发生在拿到服务器信息之后，.then调用之前</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(response=&gt;&#123;</span><br><span class="line">    // 成功 （根据validateStatus处理的结果）</span><br><span class="line">    // 实际开发中，response中的信息太杂了，但是业务层往往用到的只有响应主体信息</span><br><span class="line">    return response.data;   // 之后 .then 拿到的信息只有响应主体信息了</span><br><span class="line">&#125;,reason=&gt;&#123;</span><br><span class="line">    // 失败 状态码不对或者是没有获取任何的数据</span><br><span class="line">    // 实际开发中，不论是哪一个请求失败，基本上的提示信息或者处理方案是一致的，此时我们就可以对错误进行统一的处理</span><br><span class="line">    let response = reason.response;</span><br><span class="line">    if(response)&#123;</span><br><span class="line">        // 获取到数据，只是状态码不对，根据状态码来做不同的提示</span><br><span class="line">        switch(response.status)&#123;</span><br><span class="line">            case 400:</span><br><span class="line">                break;</span><br><span class="line">            case 401:</span><br><span class="line">                break;</span><br><span class="line">            case 404:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        // 数据都没有获取到</span><br><span class="line">        if(!navigator.onLine)&#123;</span><br><span class="line">            // 断网了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.reject(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="axios-get-post的再次封装"><a href="#axios-get-post的再次封装" class="headerlink" title="axios.get/post的再次封装"></a>axios.get/post的再次封装</h3><blockquote><p>在一些项目中，会根据业务场景实现统一的get/post公共方法，方法中会夹杂着业务的一些统一逻辑，然后基于再次封装的方法发送请求</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function api_get(url,parmas)&#123;</span><br><span class="line">    // ... 根据业务逻辑实现统一处理</span><br><span class="line">    return axios.get(url,&#123;</span><br><span class="line">        parmas</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function api_post(url,data)&#123;</span><br><span class="line">    //...</span><br><span class="line">    return axios.post(url,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios基础知识</title>
      <link href="/2020/11/22/2020-11-22-axios%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-md/"/>
      <url>/2020/11/22/2020-11-22-axios%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前后端数据通信方案：</p></blockquote><ul><li>ajax XMLHttpRequest：同源 &amp; 跨域「cors &amp; proxy」<ul><li>JQ $.ajax</li><li>axios</li></ul></li><li>Fetch：同源 &amp; 跨域「cors &amp; proxy」</li><li>webscoket</li><li>jsonp</li><li>postMessage</li><li>iframe + document.domain/location.hash…</li></ul><a id="more"></a><blockquote><p>前后端数据通信的数据格式(POST-&gt;请求主体  GET-&gt;URL问号传递参数)：</p></blockquote><ul><li><code>form-data  MIME</code>:multipart/form-data<ul><li>表单提交</li><li>文件上传:文件流信息放置在formData中</li></ul></li><li><code>x-www-form-urlencoded  MIME</code>:application/x-www-form-urlencoded<ul><li>普通数据的传输一般都用这种方式（这样GET和POST传递给服务器的数据格式统一了）</li><li>‘xxx=xxx&amp;xxx=xxx’</li><li>GET系列请求，URL传递的参数信息其实就是这种格式</li></ul></li><li><code>raw</code> 原始格式<ul><li>json字符串  MIME:application/json  服务器返回给客户端的数据一般也都是json格式字符串</li><li>text普通字符串  MIME:text/plain</li><li>xml字符串 MIME:application/xml</li></ul></li><li><code>binary</code> 文件流<ul><li>根据上传的文件不同，传递的MIME也是不一样的  例如：image/jpeg 或者 application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</li></ul></li><li><code>GraphQL</code></li></ul><h2 id="axios应用"><a href="#axios应用" class="headerlink" title="axios应用"></a>axios应用</h2><blockquote><p>基于Promise封装和管理ajax库（核心XMLHTTPRequest）</p></blockquote><blockquote><p>语法：</p><ul><li>axios([config])</li><li>axios(url,[config])</li><li>axios.get/delete/head/options(url,[config])</li><li>axios.post/put/patch(url,[data],[config])</li><li>后三种都是第一种的快捷方式，制定了请求地址、请求主体、请求主体内容，这些东西config无需再配置</li></ul></blockquote><p>返回结果都是一个promise实例</p><ul><li>成功：服务器获取到结果，并且HTTP状态码是以2开头的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//[config]  通过validStatus配置项设置成功范围</span><br><span class="line">validStatus:function(status)&#123;</span><br><span class="line">    return status &gt;= 200 &amp;&amp; status &lt; 300;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>失败：<ul><li>从服务器获取到数据了，但是HTTP状态码不是以2开始</li><li>没有从服务器获取到数据</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;list&apos;,&#123;&#125;)</span><br><span class="line">.then(res=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.post(&apos;info&apos;,&#123;</span><br><span class="line">    name:BSmall,</span><br><span class="line">    age:11</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>基于asnyc/await</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function fn()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        let res = await axios.get(&apos;http://127.0.0.1:8888/user/login&apos;)</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;catch(err)&#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><ul><li>res-&gt;response 对象<ul><li>status:200</li><li>statusText:’OK’</li><li>request:基于new XMLHttpRequest创建的xhr对象</li><li>headers:响应头信息</li><li>data:响应主体信息</li><li>config:发送请求的时候传递的配置信息</li></ul></li></ul><p>==&gt;真实项目中我们最常用的还是响应主体中的信息</p><ul><li>err-&gt;reason 对象<ul><li>config:发送请求的时候传递的配置信息</li><li>request:基于new XMLHttpRequest创建的xhr对象</li><li>isAxiosError:true/false</li><li>response:等同于成功返回的response对象，如果没有从服务器获取任何的结果，response是不存在的</li></ul></li></ul><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><blockquote><ul><li>url:’’</li><li>method:’get’</li><li>baseURL:’<a href="http://127.0.0.1:8888&#39;" target="_blank" rel="noopener">http://127.0.0.1:8888&#39;</a> -&gt; 向服务器发送请求的地址是由baseURL+url完成的</li><li>transformRequest:[function(data,headers){ return data }] -&gt; 针对于post请求，请求主体传递的信息进行格式化处理</li><li>transformResponse:[function(data){ return data }] -&gt; 针对服务器响应主体中的信息，进行格式化处理，发生在.then/catch之前</li><li>headers:{} -&gt; 设置自定义请求头信息</li><li>params:{} -&gt; GET系列请求问号传参的信息（键值对的方式存储，也可以是URLSearchParmas对象），axios内部默认是基于parmasSerializer方法中的<code>Qs.stringify</code>方法把parmas对象变为xxx=xxx&amp;xxx=xxx格式</li><li>data:{} -&gt; 请求主体传递信息的对象</li><li>timeout:0 -&gt; 设置请求超时时间，在这么久的事件内还没有完成数据请求，则触发xml.ontimeout事件</li><li>withCredentials:false -&gt; 设置在跨域请求中是否携带资源凭证（例如：cookie）</li><li>responseType:’json’ -&gt; axios内部会将服务器返回的信息，转化为指定格式的数据（支持’arraybuffer’, ‘blob’, ‘document’, ‘json’, ‘text’, ‘stream’）</li><li>onUploadprogress/onDownloadProgress:function(progressEvent){ … } -&gt; 监听上传或者下载的进度，用的是xhr.upload.onprogress事件</li><li>validateStatus:function(status){ … } -&gt; 定义成功的范围</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;user/login&apos;,&#123;</span><br><span class="line">    account:&apos;BSmall&apos;,</span><br><span class="line">    password:&apos;xxxxxx&apos;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    basrURL:&apos;http://127.0.0.1:8888&apos;,</span><br><span class="line">    headers:&#123;</span><br><span class="line">        &apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    transformRequest:[function(data)&#123;</span><br><span class="line">        return Qs.stringify(data);</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP网络层前端性能优化</title>
      <link href="/2020/11/18/2020-11-18-HTTP%E7%BD%91%E7%BB%9C%E5%B1%82%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-md/"/>
      <url>/2020/11/18/2020-11-18-HTTP%E7%BD%91%E7%BB%9C%E5%B1%82%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-md/</url>
      
        <content type="html"><![CDATA[<h2 id="从输入URL地址到看到页面"><a href="#从输入URL地址到看到页面" class="headerlink" title="从输入URL地址到看到页面"></a>从输入URL地址到看到页面</h2><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/ff7f2580-2492-11eb-899d-733ae62bed2f.jpg"><a id="more"></a><h3 id="1-URL解析"><a href="#1-URL解析" class="headerlink" title="1.URL解析"></a>1.URL解析</h3><ul><li>地址解析<ul><li>默认端口号：我们不自己编写，浏览器发送请求的时候会自动加上<ul><li>http 80</li><li>https 443</li><li>ftp 21</li></ul></li><li>传输协议：用于客户端和服务器端数据传输的<ul><li>http 超文本传输协议</li><li>https 在http的基础上进行了安全设置(SSL/TSL) -&gt; 证书认证</li><li>ftp 主要用于客户端电脑与服务器之间的文件传输</li></ul></li></ul></li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/71b70940-2495-11eb-9dfb-6da8e309e0d8.png"><ul><li><p>URL编码：对于一些特殊字符，我们在客户端和服务器端传递的时候，需要进行编码和解码</p><ul><li><p><code>encodeURI</code> <code>decodeURI</code> ：主要是对地址中的空格和中文汉字进行编码解码</p></li><li><p><code>encodeURIComponent</code> <code>decodeURIComponent</code> ：在<code>encodeURI</code>的基础上，对地址中的<code>:</code>、<code>/</code>等也会进行编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 特殊符号编码</span><br><span class="line">let url = `http://www.lizhutao.cn/index.html?from=$&#123;encodeURIComponent(&apos;http://baidu.com/&apos;)&#125;&amp;lx=1`;</span><br></pre></td></tr></table></figure></li><li><p><code>escape</code> <code>unescape</code> ：主要用于客户端不同页面之间数据传输的时候，信息的编码和解码（例如：cookie）（部分后台语言没有unescape解码）</p></li></ul></li></ul><h3 id="2-缓存检查"><a href="#2-缓存检查" class="headerlink" title="2.缓存检查"></a>2.缓存检查</h3><blockquote><p>缓存位置： </p><ul><li>Memory Cache：内存缓存</li><li>Disk Cache:硬盘缓存</li></ul></blockquote><ul><li>打开页面：查找disk cache中是否有匹配，如果有则直接使用，如果没有则发送网络请求</li><li>普通刷新(F5)：因TAB没关闭，因此memory cache是可用的，会被优先使用，其次才是disk cache</li><li>强制刷新(Ctrl F5)：浏览器不使用缓存，因此发送的请求头，均带有Cache-control:no-cache(为了兼容，还带了Pragma:no-cache),服务器直接返回200和最新内容</li></ul><h4 id="强缓存-Expires-http1-0-Cache-Control-http1-1"><a href="#强缓存-Expires-http1-0-Cache-Control-http1-1" class="headerlink" title="强缓存 Expires(http1.0) / Cache-Control(http1.1)"></a>强缓存 Expires(http1.0) / Cache-Control(http1.1)</h4><blockquote><p>浏览器对于强缓存的处理：根据第一次发送请求资源的返回的响应头来确定</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/7d1b2080-249c-11eb-8a36-ebb87efcf8c0.jpg"><ul><li>Expires：缓存过期时间，用来指定资源到期时间(HTTP/1.0)</li><li>Cache-Control: cache-control:max-age=2592000第一次拿到资源后的2592000秒内(30天)，再次发送请求，读取缓存中的信息(HTTP/1.1)</li><li>两者同时存在的话，Cache-Control优先级高于Expires</li></ul><blockquote><p>服务器设定了一些“资源（静态资源 html/css/js/图片）”的<code>强缓存机制</code>，在浏览器缓存的有效期中，除非清除缓存刷新，否则正常加载页面，都是从缓存中获取数据，而不是从服务器中重新获取数据</p></blockquote><ul><li>优势：减少对服务器的请求，加载资源更快，页面渲染速度更快</li><li>弊端：当资源在服务器更新了，但是本地还有缓存，这样会导致客户端无法及时获取最新资源</li><li>弊端解决办法：<ul><li>页面不做缓存，每一次发布资源的时候，资源文件名字都是不一样的（基于webpack 设置文件指纹（hash））,只要资源文件有更改，页面每次请求的资源也就变了</li><li>文件名不变，我们可以在请求资源的时候在后面加上一个时间戳，这样获取的资源也是最新的，而不是走缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link src=&quot;css/index.css?20201112&quot;&gt;</span><br></pre></td></tr></table></figure></li><li>不做强缓存，基于协商缓存实现（真实项目中通常是两者同时设置）</li></ul></li></ul><h4 id="协商缓存-Last-Modified-ETag"><a href="#协商缓存-Last-Modified-ETag" class="headerlink" title="协商缓存 Last-Modified / ETag"></a>协商缓存 Last-Modified / ETag</h4><blockquote><p>协商缓存是对强缓存的一种辅助，强缓存生效的时候，走强缓存，强缓存失效或者没有，才需要看是否存在协商缓存;协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识决定是否使用缓存的过程</p></blockquote><ul><li>协商缓存生效，返回<code>304</code>和<code>Not Modified</code><ul><li>服务器响应报文中用<strong>Last-Modified</strong>存储资源文件的修改时间（Last-Modified:Tue, 10 Nov 2020 14:18:47 GMT）</li><li>客户端请求报文中用<strong>If-Modified-Since</strong>携带上一次资源的修改时间（If-Modified-Since:Tue, 10 Nov 2020 14:18:47 GMT）</li></ul></li></ul><blockquote><p>强缓存是本地有缓存则不向服务器发送请求，协商缓存不同，它是哪怕本地有缓存也需要向服务器发送请求（为了校验资源文件是否更改，有更改则从服务器拿最新的资源，缓存到本地，返回<code>状态码200</code>；没有更改，不从服务器拿资源，浏览器拿缓存资源,返回<code>状态码304</code>）</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/eb2f8790-24c5-11eb-b997-9918a5dda011.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Last-Modified和If-Modified-Since</span><br><span class="line">/*  + 第一次访问资源，服务器返回资源的同时，响应头中设置Last-Modified（服务器上的最后修改时间）, 浏览器接收后，缓存文件和响应头；</span><br><span class="line"> *  + 下一次请求这个资源，浏览器检测到有 Last-Modified，于是添加If-Modified-Since请求头，值就是Last-Modified中的值；</span><br><span class="line"> *  + 服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，</span><br><span class="line"> *  返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，</span><br><span class="line"> *  于是返回新的资源文件和200；</span><br><span class="line"> *  + 但是Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源；</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// ETag和If-None-Match</span><br><span class="line">/*  + Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成；</span><br><span class="line"> *  + 下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到请求头If-None-Match里，服务器只需要比较客户端传来的</span><br><span class="line"> *  If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。</span><br><span class="line"> *  + 如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；</span><br><span class="line"> *  + 如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="数据存储：LocalStorage本地存储"><a href="#数据存储：LocalStorage本地存储" class="headerlink" title="数据存储：LocalStorage本地存储"></a>数据存储：LocalStorage本地存储</h4><blockquote><p>对于<code>不经常更新的数据</code>，我们可以基于LocalStorage存储（数据以及有效期），当我们刷新时，都先检验本地是否有数据，以及是否在有效期，满足条件则直接从本地获取数据渲染，不满足条件则重新发送请求，同时将最新获取的数据在本地存储</p></blockquote><p>不用cookie是因为它存储的信息太小了，一个源只有4KB，LocalStorage有5MB</p><h3 id="3-DNS解析"><a href="#3-DNS解析" class="headerlink" title="3.DNS解析"></a>3.DNS解析</h3><blockquote><p>DNS服务器（域名解析服务器）：DNS解析就是根据浏览器识别出来的URL地址中的域名，到DNS服务器上，查找服务器外网IP的过程</p></blockquote><ul><li>部署服务器之后，服务器有一个外网IP地址，基于外网IP可以找到服务器</li><li><code>域名</code>就相当于IP地址的别称</li><li>DNS域名解析服务器：记录了域名主机地址（外网IP）相对应的记录信息</li></ul><blockquote><p>DNS解析也是有缓存的，浏览器解析过一次，一般就会在本地记录一下解析记录</p></blockquote><ul><li>所以每次DNS解析：本地DNS服务器解析（递归）、根/顶级/权威域名服务器解析（迭代）<ul><li>本地DNS服务器解析<img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/cdd53e30-255e-11eb-8a36-ebb87efcf8c0.png"></li><li>DNS域名解析<img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/a03d8800-255f-11eb-bd01-97bc1429a9ff.png"></li></ul></li></ul><blockquote><p>每一次DNS解析时间预计在20~120毫秒</p><ul><li>减少DNS请求次数：页面中尽可能少用过多域名（资源信息尽可能发布到相同服务器）<ul><li>但是这个优化不现实，多服务器有更大好处<ul><li>服务器合理化</li><li>HTTP有并发性，但是它的并发性是收到源的限制的，同一个源一次最多并发4~7个，如果我们分开部署，就会存在很多的源，同时可以并发的HTTP数量也会增多，所以大公司服务器基本上都是分开部署的（尤其是图片等富媒体资源服务器）</li></ul></li></ul></li><li>DNS预获取（DNS Prefetch）</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//misc.360buyimg.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img10.360buyimg.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//d.3.cn&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//d.jd.com&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="4-TCP三次握手"><a href="#4-TCP三次握手" class="headerlink" title="4.TCP三次握手"></a>4.TCP三次握手</h3><ul><li>seq序号，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li><li>ack确认序号，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1</li><li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<ul><li>URG：紧急指针（urgent pointer）有效</li><li><code>ACK</code>：确认序号有效</li><li>PSH：接收方应该尽快将这个报文交给应用层</li><li>RST：重置连接</li><li><code>SYN</code>：发起一个新连接</li><li><code>FIN</code>：释放一个连接</li></ul></li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/b4f2d080-2577-11eb-97b7-0dc4655d6e68.png" /><h3 id="5-数据传输"><a href="#5-数据传输" class="headerlink" title="5.数据传输"></a>5.数据传输</h3><ul><li>HTTP报文</li><li>响应状态码</li><li>并发性</li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/84875880-2586-11eb-97b7-0dc4655d6e68.png"><h3 id="6-TCP四次挥手"><a href="#6-TCP四次挥手" class="headerlink" title="6.TCP四次挥手"></a>6.TCP四次挥手</h3><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/bbcccff0-2577-11eb-8a36-ebb87efcf8c0.png"><blockquote><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><ul><li>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</li><li>但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”，只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四步握手。</li></ul></blockquote><h4 id="HTTP-keep-alive"><a href="#HTTP-keep-alive" class="headerlink" title="HTTP keep-alive"></a><code>HTTP keep-alive</code></h4><blockquote><p><code>Connection:keep-alive</code>字段：在第一次通信建立好连接通道之后（TCP三次握手），服务器端和客户端不会主动关闭通道，这样下一次再发送请求，就无须再次TCP三次握手，节省了网络通信时间</p></blockquote><ul><li>HTTP1.0中，默认<code>Connection</code>不是<code>keep-alive</code>，需要手动处理</li><li>HTTP1.1之后<code>Connection:keep-alive</code>已经被列为规范，现在基本上都是<code>长连接</code>(前提是同一个源，向不同源发送请求还是要重新建立连接)</li></ul><h3 id="7-页面渲染"><a href="#7-页面渲染" class="headerlink" title="7.页面渲染"></a>7.页面渲染</h3><blockquote><p><a href="https://lizhutao.github.io/2020/10/12/2020-10-12-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-md/" target="_blank" rel="noopener">浏览器渲染原理及性能优化</a></p></blockquote><h2 id="HTTP1-0-amp-HTTP1-1-amp-HTTP2-0"><a href="#HTTP1-0-amp-HTTP1-1-amp-HTTP2-0" class="headerlink" title="HTTP1.0 &amp; HTTP1.1 &amp; HTTP2.0"></a>HTTP1.0 &amp; HTTP1.1 &amp; HTTP2.0</h2><blockquote><p>HTTP1.0和HTTP1.1的一些区别</p></blockquote><ul><li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ul><blockquote><p>HTTP2.0和HTTP1.X相比的新特性</p></blockquote><ul><li><strong>新的二进制格式（Binary Format）</strong>，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用（MultiPlexing）</strong>，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送（server push）</strong>，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</li></ul><blockquote><p>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</p></blockquote><ul><li><strong>HTTP/1.0</strong> 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li><li><strong>HTTP/1.1</strong> 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li><li><strong>HTTP/2</strong>多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li><p>缓存机制：</p><ul><li>对于<code>静态资源文件</code>实现<code>强缓存和协商缓存</code>（保证文件更新，及时刷新）</li><li>对于不经常更新的接口数据采用<code>本地存储</code>做数据缓存（cookie/localStorage/sessionStorage以及vuex|redux区别）</li></ul></li><li><p>DNS优化</p><ul><li><code>分服务器部署</code>，增加HTTP并发性（导致DNS解析变慢）</li><li><code>DNS Prefetch</code></li></ul></li><li><p>TCP三次握手和四次挥手</p><ul><li><code>Connection: keep-alive</code></li></ul></li><li><p>数据传输</p><ul><li>减少数据传输的大小<ul><li><code>内容数据压缩</code>（webpack等）</li><li><code>服务器端开启gzip</code>（压缩效率非常高）</li><li>大批量数据<code>分批次请求</code>（下拉刷新，分页，保证首次刷新请求数据少）</li></ul></li><li>减少HTTP请求次数<ul><li><code>资源文件合并</code>处理</li><li>小图标使用<code>字体图标</code></li><li>雪碧图<code>CSS-Sprit</code></li></ul></li></ul></li></ol><p>5.CDN服务器地域分布式</p><p>6.采用HTTP2.0</p><h3 id="首屏加载"><a href="#首屏加载" class="headerlink" title="首屏加载"></a>首屏加载</h3><blockquote><p>网络优化是前端性能优化的重点内容，因为大部分的消耗都发生在网络层，尤其是第一次页面加载，如何减少等待时间非常重要”减少白屏的效果和时间”</p></blockquote><ul><li>Loading 人性化体验</li><li>骨架屏：客户端骨架屏 + 服务器骨架屏</li><li>图片延迟加载</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async源码分析</title>
      <link href="/2020/11/15/2020-11-15-async%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-md/"/>
      <url>/2020/11/15/2020-11-15-async%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-md/</url>
      
        <content type="html"><![CDATA[<h2 id="异步串行"><a href="#异步串行" class="headerlink" title="异步串行"></a>异步串行</h2><blockquote><p>不管是Promise还是async/await都是将上一个异步函数执行完成，才会通知下一个异步执行</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">const func = x =&gt; &#123;</span><br><span class="line">    return new Promise(resolve=&gt;&#123;</span><br><span class="line">        setTimeout(_=&gt;&#123;</span><br><span class="line">            resolve(++x)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基于Promise</span><br><span class="line">func(0).then(result=&gt;&#123;</span><br><span class="line">    console.log(x)  // 1</span><br><span class="line">    return func(x)</span><br><span class="line">&#125;).then(result=&gt;&#123;</span><br><span class="line">    console.log(x)  // 2</span><br><span class="line">    return func(x)</span><br><span class="line">&#125;).then(result=&gt;&#123;</span><br><span class="line">    console.log(x)  // 3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 基于async/await</span><br><span class="line">(async function()&#123;</span><br><span class="line">    let x = await func(0)</span><br><span class="line">    console.log(x); // 1</span><br><span class="line">    </span><br><span class="line">    x = await func(x)</span><br><span class="line">    console.log(x);  // 2</span><br><span class="line">    </span><br><span class="line">    x = await func(x)</span><br><span class="line">    console.log(x);  // 3</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 基于generator函数</span><br><span class="line">function* generator(x)&#123;</span><br><span class="line">    x = yield func(x)</span><br><span class="line">    console.log(x)  // 1</span><br><span class="line">    </span><br><span class="line">    x = yield func(x)</span><br><span class="line">    console.log(x)  // 2</span><br><span class="line">    </span><br><span class="line">    x = yield func(x)</span><br><span class="line">    console.log(x)  // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iterator = generator(0);</span><br><span class="line">let result = iterator = generator(0)</span><br><span class="line">result.value.then(x=&gt;&#123;</span><br><span class="line">    result = iterator.next(x);</span><br><span class="line">    result.value.then(x=&gt;&#123;</span><br><span class="line">        result = iterator.next(x);</span><br><span class="line">        result.value.then(x=&gt;&#123;</span><br><span class="line">            result = iterator.next(x);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const func = x =&gt; &#123;</span><br><span class="line">    return new Promise(resolve=&gt;&#123;</span><br><span class="line">        setTimeout(_=&gt;&#123;</span><br><span class="line">            resolve(++x)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _async(generator,...parmas)&#123;</span><br><span class="line">    const iterator = generator(...parmas);</span><br><span class="line">    const next = x =&gt; &#123;</span><br><span class="line">        let &#123; value,done &#125; = iterator.next(x);</span><br><span class="line">        if(done) return ;</span><br><span class="line">        value.then(x=&gt;&#123;</span><br><span class="line">            next(x);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_async(function* (x)&#123;</span><br><span class="line">    x = yield func(x)</span><br><span class="line">    console.log(x)  // 1</span><br><span class="line">    </span><br><span class="line">    x = yield func(x)</span><br><span class="line">    console.log(x)  // 2</span><br><span class="line">    </span><br><span class="line">    x = yield func(x)</span><br><span class="line">    console.log(x)  // 3</span><br><span class="line">&#125;,0)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍历器(Iterator)、生成器(Generator)</title>
      <link href="/2020/11/14/2020-11-14-%E9%81%8D%E5%8E%86%E5%99%A8-Iterator-%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8-Generator-md/"/>
      <url>/2020/11/14/2020-11-14-%E9%81%8D%E5%8E%86%E5%99%A8-Iterator-%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8-Generator-md/</url>
      
        <content type="html"><![CDATA[<h2 id="遍历器-Iterator"><a href="#遍历器-Iterator" class="headerlink" title="遍历器(Iterator)"></a>遍历器(Iterator)</h2><blockquote><p><code>遍历器(Iterator)</code>是一种机制（接口）：为各种不同的数据提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作，依次处理该数据结构的所有成员</p></blockquote><ul><li>拥有<code>next</code>方法用于依次遍历数据结构的成员</li><li>每一次遍历返回的结果都是一个对象 <code>{done:false,value:xxx}</code><ul><li><code>done</code>：记录是否遍历完成</li><li><code>value</code>：当前遍历的结果</li></ul></li></ul><a id="more"></a><blockquote><p>在JS中是没有<code>Iterator</code>这个类的概念的，但是我们可以自己实现一个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Iterator&#123;</span><br><span class="line">    constructor(arr)&#123;</span><br><span class="line">        this.arr = arr;</span><br><span class="line">        this.index = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    next()&#123;</span><br><span class="line">        let index = this.index,</span><br><span class="line">            arr = this.arr;</span><br><span class="line">        if(index&gt;arr.length-1)&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                done:true,</span><br><span class="line">                value:undefined</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            done:false,</span><br><span class="line">            value:arr[this.index++]</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [10,20,30]</span><br><span class="line">let itor = new Iterator(arr)</span><br><span class="line">console.log(itor.next());   //=&gt;&#123;done:false,value:10&#125;</span><br><span class="line">console.log(itor.next());   //=&gt;&#123;done:false,value:20&#125;</span><br><span class="line">console.log(itor.next());   //=&gt;&#123;done:false,value:30&#125;</span><br><span class="line">console.log(itor.next());   //=&gt;&#123;done:ture,value:undefined&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然浏览器中未提供Iterator类，但是浏览器通过<code>Symbol.iterator</code>属性给JS中的许多数据结构提供了可遍历性，只有拥有<code>Symbol.iterator</code>属性的数据结构（值），被称为可遍历的，就可以基于<code>for of</code>循环来处理</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/ca041310-23cb-11eb-b680-7980c8a877b8.jpg"><ul><li>数组</li><li>部分类数组（argument/NodeList/HTMLCollection…）</li><li>String</li><li>Set</li><li>Map</li><li>generator object</li><li>…</li></ul><p><strong>重构Symbol.iterator</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let arr = [10,20,30,40]</span><br><span class="line">arr[Symbol.iterator] = function()&#123;</span><br><span class="line">    // 必须返回一个符合Iterator规范的对象：具备next方法</span><br><span class="line">    let index = 0,</span><br><span class="line">        self = this;</span><br><span class="line">    return &#123;</span><br><span class="line">        next()&#123;</span><br><span class="line">            if(index &gt; self.length - 1)&#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    done:true,</span><br><span class="line">                    value:undefined</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return &#123;</span><br><span class="line">                done:false,</span><br><span class="line">                value:self[index++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let item of arr)&#123;</span><br><span class="line">    console.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// console.log(...arg)  =&gt; 展开运算符处理机制也是先验证Symbol.iterator遍历器结构，如果存在，就按照这个结构去处理</span><br></pre></td></tr></table></figure><blockquote><p>对象本身不是符合Iterator遍历规范的数据，但是我么可以手动设置Symbol.iterator让其具备这个能力</p></blockquote><ol><li>自定义类数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    0:10,</span><br><span class="line">    1:20,</span><br><span class="line">    2:30,</span><br><span class="line">    length:3</span><br><span class="line">    [Symbol.iterator]:Array.prototype[Symbol.iterator]  //直接借用数组的Symbol.iterator</span><br><span class="line">    &lt;!--[Symbol.iterator]:function()&#123;--&gt;</span><br><span class="line">    &lt;!--    let index = 0,--&gt;</span><br><span class="line">    &lt;!--        self = this;--&gt;</span><br><span class="line">    &lt;!--    return &#123;--&gt;</span><br><span class="line">    &lt;!--        next()&#123;--&gt;</span><br><span class="line">    &lt;!--            return index &gt; self.length - 1 ? &#123;--&gt;</span><br><span class="line">    &lt;!--                done:true,--&gt;</span><br><span class="line">    &lt;!--                value:undefined--&gt;</span><br><span class="line">    &lt;!--            &#125;:&#123;--&gt;</span><br><span class="line">    &lt;!--                done:false,--&gt;</span><br><span class="line">    &lt;!--                value:self[index++]--&gt;</span><br><span class="line">    &lt;!--            &#125;--&gt;</span><br><span class="line">    &lt;!--        &#125;--&gt;</span><br><span class="line">    &lt;!--    &#125;--&gt;</span><br><span class="line">    &lt;!--&#125;--&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let item of obj)&#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype[Symbol.iterator]:function()&#123;</span><br><span class="line">    let self = this;</span><br><span class="line">    let keys = [</span><br><span class="line">        ...Object.hasOwnPropertyName(self),</span><br><span class="line">        ...Object.hasOwnPropertySymbol(self)</span><br><span class="line">    ];</span><br><span class="line">    let index:0;</span><br><span class="line">    return &#123;</span><br><span class="line">        next()&#123;</span><br><span class="line">            return index &gt; self.length - 1 ? &#123;</span><br><span class="line">                done:true,</span><br><span class="line">                value:undefined</span><br><span class="line">            &#125;:&#123;</span><br><span class="line">                done:false,</span><br><span class="line">                value:self[keys[index++]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj1 = &#123;</span><br><span class="line">    name:&apos;BSmall&apos;,</span><br><span class="line">    age:11,</span><br><span class="line">    [Symbol(&quot;A&quot;)]:100,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let item of obj1)&#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成器对象-Generator"><a href="#生成器对象-Generator" class="headerlink" title="生成器对象(Generator)"></a>生成器对象(Generator)</h2><blockquote><p>生成器对象是由一个generator function返回的，并且它符合迭代协议和迭代器协议</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* func()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">func.prototype.AA = &apos;10&apos;</span><br><span class="line"></span><br><span class="line">let iterator = func()</span><br><span class="line">// iterator.__proto__ = func.prototype</span><br><span class="line">console.log(interator)  //返回值是当前func的实例</span><br><span class="line"></span><br><span class="line">console.log(iterator instanceof func)   //true  </span><br><span class="line">// new func()   //=&gt; 但是func本身是无法 new 执行  Uncaught TypeError: func is not a constructor</span><br><span class="line"></span><br><span class="line">/* 也是GeneratorFunction的一个实例</span><br><span class="line"> *      + next：依次遍历对应的值</span><br><span class="line"> *      + return：结束遍历并返回return指定的值</span><br><span class="line"> *      + throw</span><br><span class="line"> *</span><br><span class="line"> * 它拥有Symbol(Symbol.iterator)这个属性值：说明我们获取的结果是具备Iterator迭代规范的</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><blockquote><p>next()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* func()&#123;</span><br><span class="line">    console.log(&quot;A&quot;)</span><br><span class="line">    yield 1;</span><br><span class="line">    console.log(&quot;B&quot;)</span><br><span class="line">    yield 2;</span><br><span class="line">    console.log(&quot;C&quot;)</span><br><span class="line">    yield 3;</span><br><span class="line">    console.log(&quot;D&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iterator = func();</span><br><span class="line">console.log(iterator.next())    // &#123;done:false,value:1&#125;</span><br><span class="line">console.log(iterator.next())    // &#123;done:false,value:2&#125;</span><br><span class="line">console.log(iterator.next())    // &#123;done:false,value:3&#125;</span><br><span class="line">console.log(iterator.next())    // &#123;done:true,value:undefined&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* func()&#123;</span><br><span class="line">    let x = yield 1;</span><br><span class="line">    console.log(x);     //=&gt; 10</span><br><span class="line">&#125;</span><br><span class="line">let interator = func();</span><br><span class="line">console.log(interator.next())        // &#123;done:false,value:1&#125;</span><br><span class="line">console.log(interator.next(10))      // &#123;done:true,value:undefined&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生成器函数嵌套</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* func1()&#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* func2()&#123;</span><br><span class="line">    yield 3;</span><br><span class="line">    yield func1();</span><br><span class="line">    yield 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let interator = func2();</span><br><span class="line">console.log(iterator.next());   //&#123;done:false,value:3&#125;</span><br><span class="line">console.log(iterator.next());   //&#123;done:false,value:func()&#125;     //func()是Generator实例</span><br><span class="line">console.log(iterator.next());   //&#123;done:false,value:4&#125;</span><br><span class="line">console.log(iterator.next());   //&#123;done:true,value:undefined&#125;</span><br><span class="line">console.log(iterator.next());   //&#123;done:true,value:undefined&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* func1()&#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* func2()&#123;</span><br><span class="line">    yield 3;</span><br><span class="line">    yield* func1();     // * 执行 迭代func1</span><br><span class="line">    yield 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let interator = func2();</span><br><span class="line">console.log(iterator.next());   //&#123;done:false,value:3&#125;</span><br><span class="line">console.log(iterator.next());   //&#123;done:false,value:1&#125;</span><br><span class="line">console.log(iterator.next());   //&#123;done:false,value:2&#125;</span><br><span class="line">console.log(iterator.next());   //&#123;done:false,value:4&#125;</span><br><span class="line">console.log(iterator.next());   //&#123;done:true,value:undefined&#125;</span><br></pre></td></tr></table></figure><blockquote><p>this</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* func1()&#123;</span><br><span class="line">    console.log(this)     // this -&gt; window</span><br><span class="line">    this.NO = &apos;NO&apos;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">&#125;</span><br><span class="line">func1.prototype.OK = &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">let interator = func1();</span><br><span class="line">iterator.next()</span><br><span class="line">console.log(iterator.OK);   //OK</span><br><span class="line">console.log(iterator.NO);   //undefined</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布订阅设计模式</title>
      <link href="/2020/11/13/2020-11-13-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-md/"/>
      <url>/2020/11/13/2020-11-13-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-md/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式思想"><a href="#设计模式思想" class="headerlink" title="设计模式思想"></a>设计模式思想</h2><blockquote><p>所有的设计模式都是用来有效管理代码的（没有设计模式也能实现效果）</p></blockquote><ul><li>便捷开发</li><li>通俗易懂</li><li>便于维护</li></ul><a id="more"></a><h2 id="发布订阅设计模式"><a href="#发布订阅设计模式" class="headerlink" title="发布订阅设计模式"></a>发布订阅设计模式</h2><blockquote><p>发布订阅设计模式是对观察者模式的升级（灵感来源于DOM2级事件），我们通过自定义事件池来模拟DOM2事件池</p></blockquote><p><strong>DOM2事件池</strong><br><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/fe0ddf80-0e1b-11eb-b244-a9f5e5565f30.png"></p><ul><li>发布一个计划，并且向计划中订阅一个个方法</li><li>当触发某个事件或某个阶段，我们可以通知计划中订阅的方法，按照顺序依次执行</li></ul><blockquote><p>JQ中的发布订阅</p></blockquote><ul><li><code>let plan = $Callback()</code> 创建一个新的自定义事件池</li><li><code>plan.add(fn1)</code> 向事件池中订阅方法</li><li><code>plan.remove(fn1)</code> 从事件池中移除方法</li><li><code>plan.fire(...)</code> 通知事件池中的方法执行</li></ul><blockquote><p>Redux中的发布订阅</p></blockquote><ul><li>默认创建一个自定义事件池（一个页面只有一个事件池）</li><li><code>let unsubscribe = subscribe(fn1)</code> 向事件池中订阅方法</li><li><code>unsubscribe()</code> 订阅时的返回值（函数），是用来移除方法的</li><li>内部通知执行（state中的数据变化的时候会默认通知事件池中的事件执行）</li></ul><blockquote><p>Vue中的发布订阅(事件总线)</p></blockquote><ul><li>默认创建一个事件池（一个页面只有一个）</li><li><code>$on(&quot;AA&quot;,fn1)</code> 给某个自定义事件订阅方法</li><li><code>$emit(&quot;AA&quot;,...)</code> 通知事件执行</li></ul><h3 id="发布订阅1-0"><a href="#发布订阅1-0" class="headerlink" title="发布订阅1.0"></a>发布订阅1.0</h3><blockquote><p>基于单例设计模式：不支持自定义事件，一个页面只有一个事件池</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">let sub = (function()&#123;</span><br><span class="line">    //创建自定义事件池</span><br><span class="line">    let pond =[];</span><br><span class="line">    </span><br><span class="line">    //订阅、移除、通知执行</span><br><span class="line">    const on = function on(func)&#123;</span><br><span class="line">        // 去重处理</span><br><span class="line">        for(let i = 0; i &lt; pond.length; i++ )&#123;</span><br><span class="line">            if(pond[i]===func) return ;</span><br><span class="line">        &#125;</span><br><span class="line">        pond.push(func)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const off = function off(func)&#123;</span><br><span class="line">        for(let i = 0 ; i &lt; pond.length; i++ )&#123;</span><br><span class="line">            if(pond[i] === func)&#123;</span><br><span class="line">                // pond.splice(i,1);   //数组塌陷 </span><br><span class="line">                pond[i] = null;  //直接赋值为null</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const fire = function fire(...parmas)&#123;</span><br><span class="line">        for(let i = 0 ; i &lt; pond.length; i++ )&#123;</span><br><span class="line">            let itemFunc = pond[i];</span><br><span class="line">            if(typeof itemFunc !== &quot;function&quot;)&#123;</span><br><span class="line">                //在这里将null移除</span><br><span class="line">                pond.splice(i,1)</span><br><span class="line">                i--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            itemFunc(...parmas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retrun&#123;</span><br><span class="line">        on,</span><br><span class="line">        off,</span><br><span class="line">        fire</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="发布订阅2-0"><a href="#发布订阅2-0" class="headerlink" title="发布订阅2.0"></a>发布订阅2.0</h3><blockquote><p>单事件池，支持自定义事件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">let sub = (function()&#123;</span><br><span class="line">    //创建自定义事件池</span><br><span class="line">    let pond =&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    //订阅、移除、通知执行</span><br><span class="line">    const on = function on(event,func)&#123;</span><br><span class="line">        !pond.hasOwnProperty(event)?pond[event] = []:null;</span><br><span class="line">        let arr = pond[event];</span><br><span class="line">        !arr.includes(func)?arr.push(func):null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const off = function off(event,func)&#123;</span><br><span class="line">        let arr = pond[event];</span><br><span class="line">        if(!arr) return ;</span><br><span class="line">        for(let i = 0 ; i &lt; arr.length; i++ )&#123;</span><br><span class="line">            if(arr[i] === func)&#123;</span><br><span class="line">                arr[i] = null;  //直接赋值为null</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const fire = function fire(event,...parmas)&#123;</span><br><span class="line">        let arr = pond[event];</span><br><span class="line">        if(!arr) return ;</span><br><span class="line">        for(let i = 0 ; i &lt; arr.length; i++ )&#123;</span><br><span class="line">            let itemFunc = arr[i];</span><br><span class="line">            if(typeof itemFunc !== &quot;function&quot;)&#123;</span><br><span class="line">                arr.splice(i,1)</span><br><span class="line">                i--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            itemFunc(...parmas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retrun&#123;</span><br><span class="line">        on,</span><br><span class="line">        off,</span><br><span class="line">        fire</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="发布订阅3-0"><a href="#发布订阅3-0" class="headerlink" title="发布订阅3.0"></a>发布订阅3.0</h3><blockquote><p>面向对象：创建多个事件池，每个事件池是独立的，存放订阅方法，原型存放公共方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    class Sub&#123;</span><br><span class="line">        //实例私有，事件池</span><br><span class="line">        pond = [];</span><br><span class="line">        </span><br><span class="line">        //原型公共方法</span><br><span class="line">        //订阅方法</span><br><span class="line">        on(func)&#123;</span><br><span class="line">            let pond = this.pond;</span><br><span class="line">            !pond.includes(func) ?</span><br><span class="line">                pond.push(func) :</span><br><span class="line">                null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //移除方法</span><br><span class="line">        off(func)&#123;</span><br><span class="line">            let pond = this.pond;</span><br><span class="line">            for(let i = 0; i &lt; pond.length ; i++)&#123;</span><br><span class="line">                if(pond[i] === func)&#123;</span><br><span class="line">                    pond[i] = null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //通知执行</span><br><span class="line">        fire(...parmas)&#123;</span><br><span class="line">            let pond = this.pond;</span><br><span class="line">            for(let i = 0; i &lt; pond.length ; i++)&#123;</span><br><span class="line">                let itemFunc = pond[i];</span><br><span class="line">                if(typeof itemFunc !== &apos;function&apos;)&#123;</span><br><span class="line">                    pond = pond.splice(i,1);</span><br><span class="line">                    i--;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                itemFunc(...parmas)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    window.subscribe = function sub()&#123;</span><br><span class="line">        return new Sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="发布订阅4-0"><a href="#发布订阅4-0" class="headerlink" title="发布订阅4.0"></a>发布订阅4.0</h3><blockquote><p>多事件池，支持自定义事件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    class Sub&#123;</span><br><span class="line">        // 实例私有属性</span><br><span class="line">        // 自定义事件池</span><br><span class="line">        pond = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        // 原型公有属性</span><br><span class="line">        // 订阅方法</span><br><span class="line">        on(event,func)&#123;</span><br><span class="line">            !pond[event] ? pond[event] = [] : null;</span><br><span class="line">            let arr  = pond[event];</span><br><span class="line">            !arr.includes(func) ? arr.push(func) : null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 移除方法</span><br><span class="line">        off(event,func)&#123;</span><br><span class="line">            if(!pond[event]) return ;</span><br><span class="line">            let arr = pond[event];</span><br><span class="line">            for(let i = 0 ; i &lt; arr.length ; i++ )&#123;</span><br><span class="line">                if(arr[i] === func)&#123;</span><br><span class="line">                    arr[i] = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 通知执行</span><br><span class="line">        fire(event,...parmas)&#123;</span><br><span class="line">            if(!pond[event]) return ;</span><br><span class="line">            let arr = pond[event];</span><br><span class="line">            for(let i = 0; i &lt; arr.length ; i++ )&#123;</span><br><span class="line">                let itemFunc = arr[i];</span><br><span class="line">                if(typeof itemFunc !== &quot;function&quot;)&#123;</span><br><span class="line">                    arr = arr.splice(i,1);</span><br><span class="line">                    i--;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                itemFunc(...parmas)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    window.subscribe = function sub()&#123;</span><br><span class="line">        return new Sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux基础、源码、中间件</title>
      <link href="/2020/11/10/2020-11-10-react-redux%E5%9F%BA%E7%A1%80%E3%80%81%E6%BA%90%E7%A0%81%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6-md/"/>
      <url>/2020/11/10/2020-11-10-react-redux%E5%9F%BA%E7%A1%80%E3%80%81%E6%BA%90%E7%A0%81%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6-md/</url>
      
        <content type="html"><![CDATA[<h2 id="react-redux使用"><a href="#react-redux使用" class="headerlink" title="react-redux使用"></a>react-redux使用</h2><blockquote><p><code>react-redux</code>是专门为react项目封装的redux库，目的是简化我们在redux在react项目中的使用</p></blockquote><a id="more"></a><ul><li><code>Provider组件</code><ul><li>将<code>store</code>挂载到祖先元素的上下文中，方便后期的后代组件的调用</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;</span><br><span class="line">import Parent from &apos;./component/Parent&apos;</span><br><span class="line">import store from &apos;./store/index&apos;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Provider store = &#123; store &#125;&gt;    //基于Provider组件，挂载上下文</span><br><span class="line">    &lt;Parent /&gt;</span><br><span class="line">&lt;/Provider&gt;,getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure><ul><li><code>connect</code>高阶函数<ul><li>将redux容器中存储的状态以及需要派发的行为任务都通过属性传递给当前组件</li><li><code>connect</code>执行需要传递两个回调函数</li><li>connect会默认帮我们把actionCreator对象（工程化的action）变为mapDispatchToProps这种函数的模式</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;</span><br><span class="line"></span><br><span class="line">class Child extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; state,dispatch &#125; = this.props;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;当前数字是：&#123; count &#125;&lt;/h3&gt;</span><br><span class="line">            &lt;button onClick=&#123;dispatch(&#123;</span><br><span class="line">                type:&quot;ADD&quot;,</span><br><span class="line">                payload:1</span><br><span class="line">            &#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;dispatch(&#123;</span><br><span class="line">                type:&quot;MINUS&quot;,</span><br><span class="line">                payload:1</span><br><span class="line">            &#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * connect 第一次执行需要传递两个参数</span><br><span class="line"> *      [mapStateToProps]：把redux容器中的公共状态当做属性传递给当前组件</span><br><span class="line"> *      [mapDispatchToProps]：把需要派发的行为方法通过属性传递给当前组件</span><br><span class="line"> */</span><br><span class="line">function mapStateToProps(state)&#123;</span><br><span class="line">    // state中存储了redux管理的所有状态</span><br><span class="line">    </span><br><span class="line">    // return的值，就是当做属性传递给Child的状态信息</span><br><span class="line">    return &#123;</span><br><span class="line">        ...state,   // 如果state中分模块了，就可以 state.xxx 导出需要的数据</span><br><span class="line">        qqq:100     // 可以自定义属性传给组件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapDispatchToProps(dispatch)&#123;</span><br><span class="line">    return dispatch;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">export default connect(mapStateToProps,mapDispatchToProps)(Child)</span><br><span class="line">// export default connect(mapStateToProps,action.count)(Child)</span><br></pre></td></tr></table></figure><h2 id="react-redux源码解析"><a href="#react-redux源码解析" class="headerlink" title="react-redux源码解析"></a>react-redux源码解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// react-redux的依赖</span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">// 创建上下文</span><br><span class="line">const ThemeContext = React.createContext();</span><br><span class="line"></span><br><span class="line">// 创建Provider组件</span><br><span class="line">export class Provider extends Component &#123;</span><br><span class="line">    static propTypes = &#123;</span><br><span class="line">        store: PropTypes.object.isRequired</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;ThemeContext.Provider value=&#123;&#123;</span><br><span class="line">            store:this.props.store</span><br><span class="line">        &#125;&#125;&gt;</span><br><span class="line">            &#123; this.props.children &#125;</span><br><span class="line">        &lt;/ThemeContext.Provider&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function connect(mapStateToProps,mapDispatchToProps)&#123;</span><br><span class="line">    if(typeof mapState !== &apos;function&apos;)&#123;</span><br><span class="line">        mapStateToProps = function()&#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof mapDispatchToProps !== &apos;function&apos;)&#123;</span><br><span class="line">        if(mapDispatchToProps !== null &amp;&amp; typeof mapDispatchToProps === &apos;object&apos;)&#123;</span><br><span class="line">            const actions = mapDispatchToProps;</span><br><span class="line">            mapDispatchToProps = function(dispatch)&#123;</span><br><span class="line">                const obj = &#123;&#125;;</span><br><span class="line">                for(let key in actions)&#123;</span><br><span class="line">                    if(!actions.hasOwnProperty(key)) break;</span><br><span class="line">                    obj[key] = function(...args)&#123;</span><br><span class="line">                        dispatch(actions[key](...arg));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            mapDispatchToProps = function()&#123;</span><br><span class="line">                return &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function connectHOC(Component)&#123;</span><br><span class="line">        return class Proxy extends React.Component &#123;</span><br><span class="line">            static contextType = ThemeContext;</span><br><span class="line">            render()&#123;</span><br><span class="line">                return &lt;Component &#123;...this.queryProps()&#125; /&gt;;</span><br><span class="line">            &#125;</span><br><span class="line">            queryProps = () =&gt; &#123;</span><br><span class="line">                const store = this.context.store;</span><br><span class="line">                const state = mapStateToProps(store.getState());</span><br><span class="line">                const action = mapDispatchToProps(store.dispatch);</span><br><span class="line">                return &#123;</span><br><span class="line">                    ...state,</span><br><span class="line">                    ...action</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            conponentDidMount()&#123;</span><br><span class="line">                this.context.store.subscribe(()=&gt;&#123;</span><br><span class="line">                    this.forceUpdate();</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h2><blockquote><p>在控制台输出每次派发任务的情况</p></blockquote><ul><li>redux-logger</li></ul><blockquote><p>管控action creators中异步处理的（二选一）</p></blockquote><ul><li>redux-thunk</li><li>redux-promise </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore,applyMiddelware &#125; from &apos;redux&apos;</span><br><span class="line">import reduxLogger from &apos;redux-logger&apos;</span><br><span class="line">import reducer from &apos;./reducer/index&apos;</span><br><span class="line"></span><br><span class="line">// applyMiddleware：应用中间件</span><br><span class="line">const store = createStore(reducer,applyMiddleware(reduxLogger))</span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure><h3 id="实现一个简单的react-logger中间件"><a href="#实现一个简单的react-logger中间件" class="headerlink" title="实现一个简单的react-logger中间件"></a>实现一个简单的<code>react-logger</code>中间件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export const logger = function logger(store)&#123;</span><br><span class="line">    return function(dispatch)&#123;</span><br><span class="line">        return function midDispatch(action)&#123;</span><br><span class="line">            console.log(&quot;老值是：&quot;,store.getState())</span><br><span class="line">            dispatch(action)</span><br><span class="line">            console.log(&quot;新值是：&quot;,store.getState())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简写</span><br><span class="line">/* export const logger = store =&gt; diapatch =&gt; action =&gt;&#123;</span><br><span class="line"> *     console.log(&quot;老值是：&quot;,store.getState())</span><br><span class="line"> *     dispatch(action)</span><br><span class="line"> *     console.log(&quot;新值是：&quot;,store.getState())</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="实现一个简单的react-thunk中间件"><a href="#实现一个简单的react-thunk中间件" class="headerlink" title="实现一个简单的react-thunk中间件"></a>实现一个简单的<code>react-thunk</code>中间件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const thunk = function thunk(store)&#123;</span><br><span class="line">    return function(dispatch)&#123;</span><br><span class="line">        return function midDispatch(action)&#123;</span><br><span class="line">            if(typeof action === &apos;function&apos;)&#123;</span><br><span class="line">                return action(dispatch,store.getState)</span><br><span class="line">            &#125;</span><br><span class="line">            return dispatch(action)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux源码解析</title>
      <link href="/2020/11/09/2020-11-09-redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-md/"/>
      <url>/2020/11/09/2020-11-09-redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-md/</url>
      
        <content type="html"><![CDATA[<h2 id="redux基本流程"><a href="#redux基本流程" class="headerlink" title="redux基本流程"></a>redux基本流程</h2><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/7e9aa6b0-1fdd-11eb-81ea-f115fe74321c.png"><blockquote><p>react和redux之间没有必然的联系，redux可以应用在各种前端开发中</p></blockquote><a id="more"></a><h2 id="redux源码解析，以及不足点优化"><a href="#redux源码解析，以及不足点优化" class="headerlink" title="redux源码解析，以及不足点优化"></a>redux源码解析，以及不足点优化</h2><blockquote><p>redux的不足点及优化</p></blockquote><ol><li><code>getState</code> 函数返回的是state公共状态的引用地址，这会导致用户拿到的state，在直接修改时会影响redux中的公共状态<ul><li>为了防止返回的状态和原始状态使用相同的引用地址，我们可以在<code>getState</code>中对获取的数据进行<code>深克隆</code></li></ul></li><li><code>subscribe</code>函数在向事件池中添加事件没有考虑去重</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">export function createStore(reducer,fn)&#123;</span><br><span class="line">    if(typeof reducer !== &quot;function&quot;)&#123;</span><br><span class="line">        thorw new TypeError(&apos;reducer mast be a function!&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建容器和事件池</span><br><span class="line">    let state;</span><br><span class="line">    let listeners = [];</span><br><span class="line">    </span><br><span class="line">    // 获取容器中的状态</span><br><span class="line">    const getSatet = function getState()&#123;</span><br><span class="line">        //1. 防止返回的状态和原始状态共用同一引用地址，这样会导致获取状态后直接就可以修改容器中的状态</span><br><span class="line">        return JSON.parse(JSON.stringify(state))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 向容器中的事件池追加方法</span><br><span class="line">    const subscribe = function subscribe(func)&#123;</span><br><span class="line">        if(typeof func !== &apos;function&apos;) return;</span><br><span class="line">        //2. 向事件池中添加事件去重</span><br><span class="line">        if(!listeners.includes(func))&#123;</span><br><span class="line">             listeners.push(func)</span><br><span class="line">        &#125;</span><br><span class="line">        return function unsubscribe()&#123;</span><br><span class="line">            listeners = listeners.filter(item=&gt;item!==func)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 派发行为任务</span><br><span class="line">    const dispatch = function dispatch()&#123;</span><br><span class="line">        if(action === null || action == undefined) return;</span><br><span class="line">        if(typeof action !== &quot;object&quot;) return;</span><br><span class="line">        if(!action.hasOwnProperty(type)) return;</span><br><span class="line">        </span><br><span class="line">        //=&gt;通知reducer执行,将返回值替换原始状态信息</span><br><span class="line">        state = reducer(state,action);</span><br><span class="line">        </span><br><span class="line">        //=&gt;如果状态改变，通知事件池中的方法一次执行</span><br><span class="line">        listeners.forEach(item=&gt;&#123;</span><br><span class="line">            item &amp;&amp; item()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //初始化时，我们需要自己派发一次dispatch</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">        type:`@@redux/INIT$&#123;Math.render()&#125;`</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    if(typeof fn === &apos;function&apos;)&#123;</span><br><span class="line">        return fn(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        getState,</span><br><span class="line">        subscribe,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//合并reducer</span><br><span class="line">export const combineReducer = function(obj)&#123;</span><br><span class="line">    return function(state=&#123;&#125;,action)&#123;</span><br><span class="line">        for(let reducer in obj)&#123;</span><br><span class="line">            state[reducer] = obj[reducer](state[reducer],action)</span><br><span class="line">        &#125;</span><br><span class="line">        return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//中间件</span><br><span class="line">// 中间件其实都是在dispatch执行的时候起作用</span><br><span class="line">// 原理其实就是，把用户调用的dispatch变成中间件的某个方法</span><br><span class="line">// 这个方法就可以做中间件想做的事情，做完之后在执行原生的</span><br><span class="line"></span><br><span class="line">// 单个中间件</span><br><span class="line">&lt;!--export const applyMiddleware = function(middleware)&#123;--&gt;</span><br><span class="line">&lt;!--    return function(createStore)&#123;--&gt;</span><br><span class="line">&lt;!--        return function(reducer)&#123;--&gt;</span><br><span class="line">&lt;!--            let store = creatStore(reducer);--&gt;</span><br><span class="line">&lt;!--            let middle = middleware(store);--&gt;</span><br><span class="line">&lt;!--            let midDipatch = middle(store.dispatch)--&gt;</span><br><span class="line">&lt;!--            return &#123;--&gt;</span><br><span class="line">&lt;!--                ...store,--&gt;</span><br><span class="line">&lt;!--                dispatch:midDispatch--&gt;</span><br><span class="line">&lt;!--            &#125;--&gt;</span><br><span class="line">&lt;!--        &#125;--&gt;</span><br><span class="line">&lt;!--    &#125;--&gt;</span><br><span class="line">&lt;!--&#125;--&gt;</span><br><span class="line"></span><br><span class="line">// 组合函数</span><br><span class="line">export const compose = (...fns) =&gt; (...args)&#123;</span><br><span class="line">    let first = fns.shift();</span><br><span class="line">    return fns.reduce((prev,next)=&gt;&#123;</span><br><span class="line">        return next(prev)</span><br><span class="line">    &#125;,first(...args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多个中间件</span><br><span class="line">export const applyMiddleware = function(...middlewares)&#123;</span><br><span class="line">    // middlewares 中存储了所有中间件 </span><br><span class="line">    return function(createStore)&#123;</span><br><span class="line">        return function(reducer)&#123;</span><br><span class="line">            let store = creatStore(reducer);</span><br><span class="line">            // let middle = middleware(store);</span><br><span class="line">            let middles = middlewares.map(item=&gt;item(store))</span><br><span class="line">            // let midDipatch = middle(store.dispatch)</span><br><span class="line">            let midDipatch = compose(...middles)(store.dispatch)</span><br><span class="line">            return &#123;</span><br><span class="line">                ...store,</span><br><span class="line">                dispatch:midDispatch</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合组件中属性、上下文传递以及高阶组件的应用</title>
      <link href="/2020/11/07/2020-11-07-%E5%A4%8D%E5%90%88%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%B1%9E%E6%80%A7%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BC%A0%E9%80%92%E4%BB%A5%E5%8F%8A%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8-md/"/>
      <url>/2020/11/07/2020-11-07-%E5%A4%8D%E5%90%88%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%B1%9E%E6%80%A7%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BC%A0%E9%80%92%E4%BB%A5%E5%8F%8A%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8-md/</url>
      
        <content type="html"><![CDATA[<h2 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h2><blockquote><p>通常我们在项目中采用的是符合组件的开发形式，即组件嵌套组件的模式，而组件嵌套就会衍生组件间传值的问题。在React中除去redux，我们最常用的传参方式有<code>属性传递</code>以及<code>上下文传递</code></p></blockquote><a id="more"></a><h3 id="属性传递"><a href="#属性传递" class="headerlink" title="属性传递"></a>属性传递</h3><blockquote><p>属性传递是单向的，这和Vue是一样的，但是Vue是基于<code>$emit+自定义事件</code>的方式实现的子传父，React中则是利用了回调函数的机制</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;</span><br><span class="line"></span><br><span class="line">function Counter(props)&#123;</span><br><span class="line">    return &lt;&gt;</span><br><span class="line">        &lt;h3&gt;当前数字是：&#123;props.count&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;button onClick=&#123;props.add.bind(this,10)&#125;&gt;子组件+10&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        count:10</span><br><span class="line">    &#125;</span><br><span class="line">    add = (n=1)=&gt;&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            count:this.state.count+1</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            // 属性和函数都是通过自定义属性的方式传递过去，但是函数使用箭头函数，所以执行时this会找到父级上下文</span><br><span class="line">            &lt;Counter count=&#123; this.state.count &#125; onClick=&#123;this.add&#125; /&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.add.bind(this,1)&#125;&gt;父组件+1&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><blockquote><p>React的上下文有点类似于Vue的provide/inject，上下文也是定义在公共祖先元素上，那么他的直属子孙组件都能够拿到，祖先元素上定义的属性</p></blockquote><p><strong>老写法</strong>：通常都会包装成高阶组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在公共的祖先组件中，通过以下方式定义上下文（这样后代元素就可以通过某种方式拿到getChildContext中的属性了）</span><br><span class="line">state childContextType = &#123;</span><br><span class="line">    theme:PropTypes.string,</span><br><span class="line">    num:PropTypes.number</span><br><span class="line">&#125;</span><br><span class="line">getChildContext()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        theme:this.props.theme,</span><br><span class="line">        num:100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 后代组件接收的方式</span><br><span class="line">static contextTypes = &#123;</span><br><span class="line">    theme:PropTypes.string,</span><br><span class="line">    num:PropTypes.number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 后代组件中调用</span><br><span class="line">this.context.theme</span><br><span class="line">this.context.num</span><br></pre></td></tr></table></figure><p><strong>新写法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建上下文,新建 context.js 文件</span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">const MyContext = React.createContext();</span><br><span class="line"></span><br><span class="line">export default MyConponent</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 2. 祖先组件导出属性</span><br><span class="line">//  + 导入上下文</span><br><span class="line">import MyContext from &apos;context&apos;</span><br><span class="line"></span><br><span class="line">//  + 导出属性,基于 MyContext.Provider 标签将祖先组件包裹起来，再使用value属性暴露私有属性</span><br><span class="line">ReactDOM.render(&lt;MyContext.Provider value=&#123;&#123;</span><br><span class="line">    theme:this.props.theme,</span><br><span class="line">    num:100</span><br><span class="line">&#125;&#125;&gt;    </span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">&lt;/MyContext.Provider&gt;,document.getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 3. 子组件接收属性</span><br><span class="line">//  + 导入上下文</span><br><span class="line">import MyContext from &apos;context&apos;</span><br><span class="line"></span><br><span class="line">//  + 接收上下文</span><br><span class="line">static contextType = MyContext</span><br><span class="line"></span><br><span class="line">//  + 调用属性</span><br><span class="line">this.context.num</span><br></pre></td></tr></table></figure><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><blockquote><p>高阶组件就是用函数在组件上套一个组件，在这个组件上定义一些公共的参数，然后我们就可以基于这个函数向一个组件传递默认参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;</span><br><span class="line"></span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            App组件</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function connect(Com)&#123;</span><br><span class="line">    return class Temp extends Component&#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            name:BSmall;</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            return &lt;Com class=&quot;box&quot; name=&#123; this.state.name &#125; &#123;...this.props&#125;/&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App = connect(App);     //基于connect高阶组件传递参数</span><br></pre></td></tr></table></figure><p><strong>基于柯里化函数传参的高阶组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;</span><br><span class="line"></span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            App组件</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function connect(...parmas)&#123;</span><br><span class="line">    return function connect(Com)&#123;</span><br><span class="line">        return class Temp extends Component&#123;</span><br><span class="line">            state = &#123;</span><br><span class="line">                name:BSmall;</span><br><span class="line">            &#125;</span><br><span class="line">            render()&#123;</span><br><span class="line">                return &lt;Com class=&quot;box&quot; &#123;...parmas&#125; name=&#123; this.state.name &#125; &#123;...this.props&#125;/&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App = connect(&#123;sex:0,age:18&#125;)(App);     //基于connect高阶组件传递参数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hooks函数</title>
      <link href="/2020/11/05/2020-11-05-React%E7%9A%84Hooks%E5%87%BD%E6%95%B0-md/"/>
      <url>/2020/11/05/2020-11-05-React%E7%9A%84Hooks%E5%87%BD%E6%95%B0-md/</url>
      
        <content type="html"><![CDATA[<h2 id="函数式组件和类组件"><a href="#函数式组件和类组件" class="headerlink" title="函数式组件和类组件"></a>函数式组件和类组件</h2><blockquote><p>函数式组件是静态的所以比较适合用来做一些展示类的组件，用户不手动刷新，数据就不会刷新；类组件虽然也能做展示，但是每次执行都会进行一段完整的生命周期，如果只是简单展示的话，类组件消耗性能太大了。但是正是由于类组件的复杂性给予了类组件强大的功能来实现复杂的业务逻辑。</p></blockquote><a id="more"></a><blockquote><p>但是如果我们往往在有些不复杂的组件开发的时候，会纠结使用函数式组件不能动态刷新，而使用类组件又大材小用，浪费性能。所以官方为我们提供了<code>Hooks函数</code>，<strong>赋予了函数值组件一些类组件的功能</strong>，从而实现我们的需求。</p></blockquote><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><blockquote><p>React提供的Hooks函数，目的是让<code>函数式组件</code>能够拥有类似<code>类组件</code>的一些功能效果</p></blockquote><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><blockquote><p>在函数式组件中应用状态<code>state</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;useState&#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">function VoteHook(props)&#123;</span><br><span class="line">    /*</span><br><span class="line">     * useState:应用状态</span><br><span class="line">     *      @params</span><br><span class="line">     *          initState 初始状态值（也可以是函数，函数中返回初始状态值）</span><br><span class="line">     *      @return </span><br><span class="line">     *          数组：[状态，更改状态的方法]</span><br><span class="line">     */</span><br><span class="line">    let [supNum,changeSupNum] = useState(0)</span><br><span class="line">    return &lt;section&gt;</span><br><span class="line">        &lt;header&gt;</span><br><span class="line">            &lt;h3&gt;&#123;props.title&#125;&lt;/h3&gt;</span><br><span class="line">            &lt;span&gt;N: 0&lt;/span&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">        &lt;main&gt;</span><br><span class="line">            &lt;p&gt;支持人数:&#123;supNum&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;反对人数:0&lt;/p&gt;</span><br><span class="line">        &lt;/main&gt;</span><br><span class="line">        &lt;footer&gt;</span><br><span class="line">            //点击时不适用解构出来的changeSupNum也是能够更改状态，但是不会通知视图更新</span><br><span class="line">            &lt;button onClick=&#123;ev=&gt;&#123;</span><br><span class="line">                //更改状态（直接传递需要更改的值即可），会通知组件重新渲染，类似setState</span><br><span class="line">                changeSupNum(++supNum);</span><br><span class="line">            &#125;&#125;&gt;支持&lt;/button&gt;</span><br><span class="line">            &lt;button&gt;反对&lt;/button&gt;</span><br><span class="line">        &lt;/footer&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多状态</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;useState&#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">function VoteHook(props)&#123;</span><br><span class="line">    //let [state,changeNum] = useState(&#123;</span><br><span class="line">    //    supNum:0,</span><br><span class="line">    //    oppNum:0</span><br><span class="line">    //&#125;)</span><br><span class="line">    </span><br><span class="line">    let [state,changeNum] = useState(function init()&#123;</span><br><span class="line">        //将初始值写成函数的好处</span><br><span class="line">        // 1. 可以根据不同的业务场景，赋值不一样的初始值</span><br><span class="line">        // 2. 只会在第一次渲染组件的时候赋值初始值，后期重新渲染，当前操作不再执行，属于优化操作</span><br><span class="line">        return &#123;</span><br><span class="line">            supNum:0,</span><br><span class="line">            oppNum:0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     *  官方不推荐我们像上述一样使用，建议我们像下面一样，一个数据一个useState</span><br><span class="line">     *  let [supNum,changeSup] = useState(0)</span><br><span class="line">     *  let [oppNum,changeOpp] = useState(0)</span><br><span class="line">     */</span><br><span class="line">    return &lt;section&gt;</span><br><span class="line">        &lt;header&gt;</span><br><span class="line">            &lt;h3&gt;&#123;props.title&#125;&lt;/h3&gt;</span><br><span class="line">            &lt;span&gt;N: &#123; state.supNum + state.oppNum &#125;&lt;/span&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">        &lt;main&gt;</span><br><span class="line">            &lt;p&gt;支持人数:&#123;state.supNum&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;反对人数:&#123;state.oppNum&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/main&gt;</span><br><span class="line">        &lt;footer&gt;</span><br><span class="line">            &lt;button onClick=&#123;ev=&gt;&#123;</span><br><span class="line">                changeNum(&#123;</span><br><span class="line">                    ...state,   //和类组件的setState不同，函数式组件中useState的state不会默认合并，而是直接赋值新值（所以我们需要将之前的数据结构到更改的数据中）</span><br><span class="line">                    supNum: ++state.supNum</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;&#125;&gt;支持&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;ev=&gt;&#123;</span><br><span class="line">                changeNum(&#123;</span><br><span class="line">                    oppNum: ++state.oppNum</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;&#125;&gt;反对&lt;/button&gt;</span><br><span class="line">        &lt;/footer&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><blockquote><p>让函数式组件拥有生命周期函数（类似于componentDidMount/componentUpdate）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;useState,useEffect&#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">function VoteHook(props)&#123;</span><br><span class="line">    let [supNum,changeSup] = useState(0)</span><br><span class="line">    let [oppNum,changeOpp] = useState(0)</span><br><span class="line">    </span><br><span class="line">    // 1. 同时触发 componentDidMount/componentUpdate</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;)</span><br><span class="line">    // 2. 只触发 componentDidMount</span><br><span class="line">     useEffect(()=&gt;&#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    // 3. 依赖触发(只有supNum更改才触发)</span><br><span class="line">     useEffect(()=&gt;&#123;</span><br><span class="line">        console.log(3)</span><br><span class="line">    &#125;,[supNum])</span><br><span class="line">    // 4. 只触发 componentUpdate</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        return ()=&gt;&#123;</span><br><span class="line">            console.log(4)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return &lt;section&gt;</span><br><span class="line">        &lt;header&gt;</span><br><span class="line">            &lt;h3&gt;&#123;props.title&#125;&lt;/h3&gt;</span><br><span class="line">            &lt;span&gt;N: &#123; state.supNum + state.oppNum &#125;&lt;/span&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">        &lt;main&gt;</span><br><span class="line">            &lt;p&gt;支持人数:&#123;state.supNum&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;反对人数:&#123;state.oppNum&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/main&gt;</span><br><span class="line">        &lt;footer&gt;</span><br><span class="line">            &lt;button onClick=&#123;ev=&gt;&#123;</span><br><span class="line">                changeNum(&#123;</span><br><span class="line">                    supNum: ++state.supNum</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;&#125;&gt;支持&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;ev=&gt;&#123;</span><br><span class="line">                changeNum(&#123;</span><br><span class="line">                    oppNum: ++state.oppNum</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;&#125;&gt;反对&lt;/button&gt;</span><br><span class="line">        &lt;/footer&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现一个简单的<code>useEffect</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let prevDependencies;</span><br><span class="line">function useEffect(callback,dependencies)&#123;</span><br><span class="line">    const isChanged = dependencies ?</span><br><span class="line">        dependencies.some((item,index)=&gt; item === prevDependencies[index]) :</span><br><span class="line">        true ;</span><br><span class="line">    //如果dependencies不存在，或者有变化</span><br><span class="line">    if( !dependencies || isChanged )&#123;</span><br><span class="line">        callback();</span><br><span class="line">        prevDependencies = dependencies;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useRef-createRef"><a href="#useRef-createRef" class="headerlink" title="useRef/createRef"></a>useRef/createRef</h3><blockquote><p>让函数式组件也能够操作DOM</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;useRef&#125; from &apos;react&apos;</span><br><span class="line">function GetNum()&#123;</span><br><span class="line">    //1. 使用Ref</span><br><span class="line">    let num = useRef();</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        //2. 想要获取那个DOM元素，就给其赋值DOM的ref属性</span><br><span class="line">        &lt;span ref=&#123;num&#125;&gt;1024&lt;/span&gt;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;&#123;</span><br><span class="line">            3. 基于current属性就可以获取到DOM元素</span><br><span class="line">            console.log(num.current.innerHTML)</span><br><span class="line">        &#125;&#125;&gt;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><blockquote><p>让函数式组件也能够向redux一样管理状态</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React生命周期以及PureComponent</title>
      <link href="/2020/11/04/2020-11-04-React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8APureComponent-md/"/>
      <url>/2020/11/04/2020-11-04-React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8APureComponent-md/</url>
      
        <content type="html"><![CDATA[<h2 id="React生命周期函数"><a href="#React生命周期函数" class="headerlink" title="React生命周期函数"></a>React生命周期函数</h2><blockquote><p>在框架中开发中，都是框架底层处理我们编写的代码，从代码到页面展示的过程，React内部是经历过一些步骤的，官方为我们提供的生命周期函数，是让我们在代码解析到这个阶段的时候，能够执行我们所编写的业务逻辑。</p></blockquote><a id="more"></a><p>在新版的React中为我们提供了新的生命周期，并弃用了一些生命周期</p><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/881eece0-1b6f-11eb-899d-733ae62bed2f.webp"><h3 id="创建时"><a href="#创建时" class="headerlink" title="创建时"></a>创建时</h3><ul><li><code>constructor()</code></li></ul><blockquote><p>初始化属性和状态，是第一个生命周期</p></blockquote><ul><li><code>static getDerivedStateFromProps()</code></li></ul><blockquote><p>根据属性对象派生状态对象，简单理解就是说直接将props上的属性都挂在state上</p></blockquote><ul><li><code>render()</code></li></ul><blockquote><p>组件渲染时（挂载）</p></blockquote><ul><li><code>componentDidMount()</code></li></ul><blockquote><p>组件渲染（挂载）完成</p></blockquote><h3 id="更新时"><a href="#更新时" class="headerlink" title="更新时"></a>更新时</h3><ul><li><p><code>static getDerivedStateFromProps()</code></p></li><li><p><code>shouldComponentUpdate()</code></p><ul><li>true 允许更新继续向下执行</li><li>false 不允许更新，停止执行，不会调用之后的生命周期函数（状态更新，视图不更新）</li><li><code>forceUpdate</code>强制更新，直接跳过 shouldComponentUpdate 这层</li></ul></li></ul><blockquote><p>查看组件是否可以更新</p></blockquote><ul><li><code>render()</code></li></ul><blockquote><p>根据新的状态对象重新挂载(渲染)组件</p></blockquote><ul><li><code>getSnapshotBeforeUpdate()</code></li></ul><blockquote><p>在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()</p></blockquote><ul><li><code>componentDidUpdate</code></li></ul><blockquote><p>组件更新完成</p></blockquote><h3 id="卸载时"><a href="#卸载时" class="headerlink" title="卸载时"></a>卸载时</h3><ul><li><code>componentWillUnmount</code></li></ul><blockquote><p>组件卸载之前</p></blockquote><h3 id="数据获取为什么一定要在componentDidMount里面调用"><a href="#数据获取为什么一定要在componentDidMount里面调用" class="headerlink" title="数据获取为什么一定要在componentDidMount里面调用"></a>数据获取为什么一定要在componentDidMount里面调用</h3><ul><li>constructor</li></ul><blockquote><p>constructor()中获取数据的话，如果时间太长，或者出错，组件就渲染不出来，整个页面都没法渲染了</p></blockquote><ul><li>componentWillMount()</li></ul><blockquote><ol><li>如果使用SSR（服务端渲染）,componentWillMount会执行2次，一次在服务端，一次在客户端。而componentDidMount不会。</li></ol></blockquote><blockquote><ol start="2"><li>React16之后采用了Fiber架构，只有componentDidMount声明周期函数是确定被执行一次的，类似componentWillMount的生命周期钩子都有可能执行多次，所以不加以在这些生命周期中做有副作用的操作，比如请求数据之类</li></ol></blockquote><ul><li>componentDidMount()</li></ul><blockquote><ol><li>确保已经render过一次。提醒我们正确地设置初始状态，这样就不会得到导致错误的undefined状态</li></ol></blockquote><blockquote><ol start="2"><li>componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码</li></ol></blockquote><h3 id="新旧对比"><a href="#新旧对比" class="headerlink" title="新旧对比"></a>新旧对比</h3><ul><li><p>废弃</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ul></li><li><p>增加了</p><ul><li>getDerivedStateFromProps</li><li>getSnapshotbeforeUpdate</li></ul></li></ul><blockquote><p>旧图</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/89483860-1b74-11eb-8a36-ebb87efcf8c0.webp"><h2 id="PureComponent-纯粹组件"><a href="#PureComponent-纯粹组件" class="headerlink" title="PureComponent 纯粹组件"></a>PureComponent 纯粹组件</h2><blockquote><p>PureComponent 和 Component 的区别在于，PureComponent相当于默认给当前组件在<code>shouldComponentUpdate</code>设置为true</p></blockquote><ul><li>在这个函数中默认进行了关于<code>原始属性/状态</code>和<code>最新要修改的属性/状态</code>的一个<code>浅比较</code><ul><li>浅比较相当于<code>===</code>，对于基本数据类型值比较的是值</li><li>对于引用数据类型来说，浅比较只是比较引用地址（当堆的值改变时，地址没变，会被判断状态未修改，从而导致组件不会重新渲染）</li><li>为了防止PureComponent浅比较，我们一般将引用类型值克隆一份再重新复制</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React类组件</title>
      <link href="/2020/10/31/2020-10-31-React%E7%B1%BB%E7%BB%84%E4%BB%B6-md/"/>
      <url>/2020/10/31/2020-10-31-React%E7%B1%BB%E7%BB%84%E4%BB%B6-md/</url>
      
        <content type="html"><![CDATA[<h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><blockquote><p>创建一个继承React.Component/React.PureComponent的类，那么这个类就是类组件</p></blockquote><ul><li>渲染的时候发现type是一个类，则会创建当前类的实例</li><li>同样会把解析出来的props传递给当前类,并且React会默认帮我们将props挂载在当前类的实例上（方法中可以直接使用this.props操作），但是默认情况下是执行完constructor在把props挂载在实例上的，所以在constructor中不写是无法基于this.props获取</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        //默认this.props = props</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        let time = new Data().toLocalString();</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;time&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;&gt;</span><br><span class="line">    &lt;Clock index=&#123;1&#125; &gt;</span><br><span class="line">        &lt;span&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/Clock&gt;</span><br><span class="line">&lt;/&gt;,getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure><h3 id="受控组件-class"><a href="#受控组件-class" class="headerlink" title="受控组件(class)"></a>受控组件(class)</h3><blockquote><p>基于数据驱动视图的渲染（类组件是动态组件），受数据控制视图渲染渲染组件</p></blockquote><h4 id="组件状态（state）"><a href="#组件状态（state）" class="headerlink" title="组件状态（state）"></a>组件状态（state）</h4><blockquote><p>状态是我们自己在组件中挂载的state，而props是外部出入组件的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        //1. 初始化状态（把后续需要使用的状态全部初始化）</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            time: new Date().toLocalString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ES7中给实例设置属性可以直接写在这里</span><br><span class="line">    // state = &#123;</span><br><span class="line">    //    ...</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        //2. 渲染的时候使用状态</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;this.state.time&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;    //第一次加载完的生命周期函数</span><br><span class="line">        setInterval(_=&gt;&#123;</span><br><span class="line">            // this.state.time = new Date().toLocalString();</span><br><span class="line">            // 上述代码可以修改状态，但是不会通知视图渲染 =&gt; setState</span><br><span class="line">            this.setState = (&#123;</span><br><span class="line">                time: new Date().toLocalString();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>setState</strong></p><blockquote><p>setState在大部分情况下是异步的，基于原生事件的时候是同步的（作者说会在后续版本中修复），setState的原理是基于发布订阅，它本身是同步操作，但是会在异步中通知事件池中的事件执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  setState([partialState],[callback])</span><br><span class="line"> *  @parmas:</span><br><span class="line"> *      [partialState] : 需要修改的状态</span><br><span class="line"> *      [callback] : 当状态更新视图重新渲染触发的回调函数（类似于Vue的$nextTick）</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><blockquote><p>组件中传入 props 是只读的，所以我们尽可能的将属性值保存到state(状态中)，再修改</p></blockquote><p><strong>prop-types : 属性设置规则的插件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add prop-types</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">/* 给属性设置规则：prop-types</span><br><span class="line"> *      =&gt; 设置默认值</span><br><span class="line"> *      =&gt; 设置传递值的类型和是否必传</span><br><span class="line"> */</span><br><span class="line">class Vote extends React.Component &#123;</span><br><span class="line">    static defaultProps = &#123;     // 设置默认值 =&gt; Vote.defaultProps = &#123; &#125;</span><br><span class="line">        // 必传的属性不需要使用默认值</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    static propTypes = &#123;    //设置规则  =&gt; Vote.propTypes = &#123; &#125;</span><br><span class="line">        title:PropTypes.string.isRequired</span><br><span class="line">        supNum:PropTypes.number,</span><br><span class="line">        oppNum:PropTypes.number</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; title,supNum,oppNum &#125; = this.props;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            //....</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class原型上的this"><a href="#class原型上的this" class="headerlink" title="class原型上的this"></a>class原型上的<code>this</code></h3><blockquote><p>Vue上操作组件原型上的方法没有<code>this</code>的问题，是因为Vue在运行时，在底层中帮我们直接基于bind将方法中的<code>this</code>全部预设成了当前组件的实例，而React并没有帮我们做这一层封装，直接调用类原型上的方法时<code>this</code>指向 undefined (基于严格模式)，所以需要我们手动控制this指向</p></blockquote><p><strong>方法一：箭头函数</strong>:保证箭头函数是上下文中的<code>this</code>-&gt; EC(render)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            time: new Date().toLocalString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //基于箭头函数编写</span><br><span class="line">    handle = (ev,n) =&gt; &#123;</span><br><span class="line">        clearInterval(this.autoTime);</span><br><span class="line">        console.log(ev,n)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;this.state.time&#125;</span><br><span class="line">            &lt;!--&lt;button onClick=&#123; this.handle(ev,100) &#125;&gt;暂停时间&lt;/button&gt;--&gt;</span><br><span class="line">            &lt;button onClick=&#123;ev=&gt;&#123;</span><br><span class="line">                // clearInterval(this.autoTimer)    //不好</span><br><span class="line">                this.handle(ev,100)</span><br><span class="line">            &#125;&#125;&gt;暂停时间&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123; </span><br><span class="line">        this.autoTime = setInterval(_=&gt;&#123;</span><br><span class="line">            this.setState = (&#123;</span><br><span class="line">                time: new Date().toLocalString();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：bind</strong>:预设this</p><blockquote><p>和箭头函数的传参顺序是相反的（事件对象在最末尾）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            time: new Date().toLocalString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handle(n,ev)&#123;</span><br><span class="line">        clearInterval(this.autoTime);</span><br><span class="line">        console.log(n,ev)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;this.state.time&#125;</span><br><span class="line">            &lt;button onClick=&#123; this.handle.bind(this,100) &#125;&gt;暂停时间&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123; </span><br><span class="line">        this.autoTime = setInterval(_=&gt;&#123;</span><br><span class="line">            this.setState = (&#123;</span><br><span class="line">                time: new Date().toLocalString();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非受控组件-ref"><a href="#非受控组件-ref" class="headerlink" title="非受控组件(ref)"></a>非受控组件(ref)</h3><blockquote><p>React中不推崇我们直接操作DOM，但是我们在项目开发中会有不可避免的DOM操作，React为我们提供了<code>ref</code>，给我们操作DOM</p></blockquote><p>使用ref清除定时器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            time: new Date().toLocalString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;this.state.time&#125;</span><br><span class="line">            // &lt;button ref=&quot;btn&quot; &#125;&gt;暂停时间&lt;/button&gt;  在项目中通常不这么设置</span><br><span class="line">            &lt;button ref=&#123;x=&gt;&#123;</span><br><span class="line">                //函数表达式的方式</span><br><span class="line">                // x 就是当前操作的元素</span><br><span class="line">                this.btn = x;   //直接将元素挂载到实例上，不走refs</span><br><span class="line">            &#125; &#125;&gt;暂停时间&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123; </span><br><span class="line">        this.autoTime = setInterval(_=&gt;&#123;</span><br><span class="line">            this.setState = (&#123;</span><br><span class="line">                time: new Date().toLocalString();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,1000);</span><br><span class="line">        // 在这里就可以获取到 DOM 元素 this.refs.btn</span><br><span class="line">        this.btn.addEventListener(&apos;click&apos;,_=&gt;&#123;</span><br><span class="line">            clearInterval(this.autoTime);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3><blockquote><p>在React中我们将事件对象打印出来，会发现他的属性都被<code>defineProperty</code>劫持的，所以他的事件对象不是原生的，而是<code>合成事件对象</code></p></blockquote><ul><li>合成事件是基于事件委托实现的，目的是为了实现PC端和移动端的兼容，例如：移动端的click存在300ms延迟，我们设置的onClick在PC端被识别为click，在移动端被识别为touch事件模型（实现事件的跨平台开发）</li><li>事件对象也是React内部合成的一套对象，但是对于我们的操作没有任何影响，他是把所有的原生事件对象的所有属性给get和set了</li><li>ev.persist() 阻止事件的劫持，使用原生事件</li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React函数式组件</title>
      <link href="/2020/10/30/2020-10-30-React%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-md/"/>
      <url>/2020/10/30/2020-10-30-React%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-md/</url>
      
        <content type="html"><![CDATA[<h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><blockquote><p>不管是Vue还是React中都推崇的是组件化开发，将一个项目拆分成一个个组件，这样做的目的是实现组件的复用，有利于团队的协作开发。所以不管是Vue还是React，都是基于组件化的概念来实现应用开发。</p></blockquote><p>react中的组件开发</p><ul><li>函数式组件</li><li>类组件</li><li>React Hooks (函数式组件的拓展)</li></ul><a id="more"></a><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><blockquote><p>在React中，创建一个函数，返回JSX元素，那么这个组件就是函数式组件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Clock(props )&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &#123;new Date().toLocalString()&#125;</span><br><span class="line">    &lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;&gt;</span><br><span class="line">    &lt;Clock/&gt;    </span><br><span class="line">&lt;/&gt;,getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure><blockquote><p>函数式组件在运作的时候，如果细腻DOM的type是一个函数（或者一个类），会首先把函数执行（把解析出来的props传给这个函数），函数会把一个新的虚拟DOM对象返回，最后再进行渲染</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/8ef876d0-1a61-11eb-8a36-ebb87efcf8c0.png"><blockquote><p>函数式组件是<code>静态组件</code>，调取组件渲染出一个结果，后续组件除非重新渲染，否则组件第一次渲染的结果是不会改变的（当然React Hooks可以帮我们解决这个问题）</p></blockquote><h3 id="双闭合组件"><a href="#双闭合组件" class="headerlink" title="双闭合组件"></a>双闭合组件</h3><blockquote><p>组件的调取可以使双闭合，也可以是单闭合，双闭合调用可以把子元素当做props中的children传递给组件（类似于Vue的slot插槽）</p></blockquote><p>首先我们需要明确，<code>&lt;Clock&gt;&lt;/Clock&gt;</code>组件是我们自定义的组件，在自定义组件上传递属性都是自定义属性，所以在上面传<code>style</code>属性是不生效的，但是我们给组件传入的<code>props</code>中有<code>style</code>属性，我们直接将属性拿到，并将它应用函数返回的在<code>JSX元素</code>上就可以生效了。</p><p>在双闭合标签是允许我们<code>自定义子元素</code>的，但是直接传入是没有效果的，子元素会默认传递给<code>props.children</code>属性，我们可以直接在函数式组件中拿到<code>children</code>，并按照自己的需求将它绑定到<code>JSX元素</code>上，就可以实现效果了。</p><h3 id="React-Children"><a href="#React-Children" class="headerlink" title="React.Children"></a>React.Children</h3><blockquote><p>React为我们提供用来提供专门用来处理传递进来的子元素children的工具对象<code>React.Children</code>，里面存放了用来操作children的方法</p></blockquote><ul><li><code>React.Children.map()</code>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//语法</span><br><span class="line">React.Children.map(children, function[(thisArg)])</span><br></pre></td></tr></table></figure><p>在 children 里的每个直接子节点上调用一个函数，并将 this 设置为 thisArg。如果 children 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。如果子节点为 null 或是 undefined，则此方法将返回 null 或是 undefined，而不会返回数组。</p><blockquote><p>如果 children 是一个 Fragment 对象，它将被视为单一子节点的情况处理，而不会被遍历。</p></blockquote><ul><li><code>React.Children.forEach()</code>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//语法</span><br><span class="line">React.Children.forEach(children, function[(thisArg)])</span><br></pre></td></tr></table></figure><p>与 React.Children.map() 类似，但它不会返回一个数组</p><ul><li><code>React.Children.count()</code>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.Children.count(children)</span><br></pre></td></tr></table></figure><p>返回 children 中的组件总数量，等同于通过 map 或 forEach 调用回调函数的次数</p><ul><li><code>React.Children.only()</code>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.Children.only(children)</span><br></pre></td></tr></table></figure><p>验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误</p><ul><li><code>React.Children.toArray()</code>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.Children.toArray(children)</span><br></pre></td></tr></table></figure><p>将 children 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 key。当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 this.props.children 之前对内容重新排序或获取子集时。</p><blockquote><p>React.Children.toArray() 在拉平展开子节点列表时，更改 key 值以保留嵌套数组的语义。也就是说，toArray 会为返回数组中的每个 key 添加前缀，以使得每个元素 key 的范围都限定在此函数入参数组的对象内</p></blockquote><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><blockquote><p>组件中传递进来的props属性是只读的（只能获取，不能修改）</p></blockquote><ul><li>如果非要修改某一个值，可以将它的值赋值给一个变量或者状态，然后修改变量或者状态</li><li>或者将属性深克隆，然后再操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的JSX语法以及渲染原理</title>
      <link href="/2020/10/29/2020-10-29-React%E7%9A%84JSX%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86-md/"/>
      <url>/2020/10/29/2020-10-29-React%E7%9A%84JSX%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86-md/</url>
      
        <content type="html"><![CDATA[<h2 id="JSX基础语法"><a href="#JSX基础语法" class="headerlink" title="JSX基础语法"></a>JSX基础语法</h2><blockquote><p>JSX(JavaScript and xml)，React中使用JSX来元素来构建元素</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在React中的html结构不管是我们定义的，还是函数返回的，都是JSX</span><br><span class="line">const element = &lt;div&gt;JSX&lt;/div&gt;;</span><br><span class="line">function Element()&#123;     //React中组件都是函数，import导入时组件名必须大写</span><br><span class="line">    return &lt;div&gt;JSX&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="唯一根节点"><a href="#唯一根节点" class="headerlink" title="唯一根节点"></a>唯一根节点</h3><ul><li>最外层只能有一个根节点</li><li><code>&lt;&gt;&lt;/&gt;</code> fragment空标记，既能作为容器把一堆内容包裹起来，还不占层级结构</li></ul><h3 id="动态数据"><a href="#动态数据" class="headerlink" title="动态数据"></a>动态数据</h3><ul><li>动态绑定数据用<code>{ }</code>,大括号中存放的是JS表达式<ul><li>直接放数组：把数组中的每一项都呈现出来</li><li>一般情况下不能直接渲染对象</li></ul></li><li>JSX虚拟DOM对象是可以直接放在<code>{ }</code>中渲染的</li></ul><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li>设置行内样式，必须是<code>style=\{\{color:&quot;red&quot;\}\}</code></li><li>设置样式类名需要使用className而不是class</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Hello()&#123;</span><br><span class="line">    let sty = &#123;color:&apos;red&apos;&#125;</span><br><span class="line">    return &lt;h1 className=&quot;box&quot; style=&#123;sty&#125;&gt;hello world&lt;/h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><ul><li>JSX中进行的判断一般都要基于三元运算符来完成</li></ul><p><strong>基于三元运算符模拟v-if和v-show</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//模拟vue的v-if</span><br><span class="line">function Hello()&#123;</span><br><span class="line">    let str = &quot;BSmall&quot;; </span><br><span class="line">    return &lt;h1 className=&quot;box&quot; style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt;</span><br><span class="line">    hello </span><br><span class="line">    &#123; 2 &gt; 1 ? &lt;span&gt;&#123;str&#125;&lt;/span&gt;:&lt;span&gt;world&lt;/span&gt; &#125; </span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">&#125;</span><br><span class="line">//模拟vue的v-show</span><br><span class="line">function Hello1()&#123;</span><br><span class="line">    let num = 2 ; </span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h1 className=&quot;box&quot; style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt;hello world&lt;/h1&gt;</span><br><span class="line">        &lt;h2 style=&#123;&#123;display:&#123;num&#125; &gt; 1 ? &quot;block&quot; : &quot;none&quot; &#125;&#125;&gt;BSmall&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>JSX中遍历数组中的每一项，动态绑定多个JSX元素，一般都是基于数组的<code>map</code>来实现的（map迭代数组支持返回值，且返回的是数组）=&gt; 和vue一样，循环绑定的元素要设置key值（作用：用于dom-diff的差异化对比）</li></ul><p><strong>基于三元运算符模拟v-for</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Hello()&#123;</span><br><span class="line">    let ary = [1,2,3,4,5,6]; </span><br><span class="line">    return &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            ary.map((item,index)=&gt;&#123;</span><br><span class="line">                return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没有map怎么实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Hello()&#123; </span><br><span class="line">    let ary = [1,2,3,4,5,6]; </span><br><span class="line">    function fn(ary)&#123;</span><br><span class="line">        var temp=[];</span><br><span class="line">        for(let i = 0; i&lt;ary.length;i++)&#123;</span><br><span class="line">            temp.push(&lt;li key=&#123;i&#125;&gt;&#123;ary[i]&#125;&lt;/li&gt;)</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            fn(ary)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSX强编程性和防止XSS攻击"><a href="#JSX强编程性和防止XSS攻击" class="headerlink" title="JSX强编程性和防止XSS攻击"></a>JSX强编程性和防止XSS攻击</h2><blockquote><p>JSX语法具有很强的编程性，而这时Vue的模板语法中不具备的，所以Vue中现在也支持了JSX语法</p></blockquote><blockquote><p>JSX语法具备过滤效果（过滤非法内容），有效防止XSS攻击</p></blockquote><h2 id="JSX语法转换为真实DOM"><a href="#JSX语法转换为真实DOM" class="headerlink" title="JSX语法转换为真实DOM"></a>JSX语法转换为真实DOM</h2><blockquote><p>JSX渲染为真实DOM的原理和步骤</p></blockquote><ol><li>基于<code>babel-preset-react-app</code>把JSX语法变为<code>React.createElement</code>的模式</li></ol><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/45719200-1924-11eb-81ea-f115fe74321c.png"><ol start="2"><li><p>基于<code>React.createElement</code>方法的执行，创建出虚拟对象DOM对象（JSX对象）</p><ul><li>创建的是一个对象</li><li>type属性：存储的是标签名（或者组件）</li><li>props属性：没有传递任何属性，也没有任何的子元素，其为空对象；把传递给createElement的属性，都赋值给props；如果有子元素，则新增一个children属性，可以使一个值，也可以是一个数组</li></ul></li></ol><p><strong>实现createElement</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">React.createElement = function(type,props,...children)&#123;</span><br><span class="line">    let jsxObj = &#123;</span><br><span class="line">        type,</span><br><span class="line">        props:&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //传递了属性，把传递的属性都放置在jsxObj的props中</span><br><span class="line">    if(props !== null)&#123;</span><br><span class="line">        jsxObj.props = &#123; ...props &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果传递了子元素，还需要jsxObj的props中设置children属性</span><br><span class="line">    if(children.length &gt; 0)&#123;</span><br><span class="line">        jsxObj.props.children = children;</span><br><span class="line">        if( children.length === 1 )&#123;</span><br><span class="line">            jsxObj.props.children = children[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return jsxObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>基于<code>ReactDOM.render</code>把创建的虚拟DOM渲染到页面的指定容器里</li></ol><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/fc992e00-1999-11eb-b997-9918a5dda011.png"><blockquote><p><code>ReactDOM.render([JSX-Obj],[container],[callback])</code>;[callback]渲染触发的回调函数，这里可以获取到真实的DOM</p></blockquote><p><strong>实现ReactDOM.render</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render = function render(jsxObj,container,callback)&#123;</span><br><span class="line">    let &#123; type,props &#125; = jsxObj;</span><br><span class="line">    </span><br><span class="line">    if(typeof type === &quot;string&quot;)&#123;</span><br><span class="line">        //创建DOM元素</span><br><span class="line">        let element = document.createElement(type);</span><br><span class="line">        //增加到指定容器中</span><br><span class="line">        container.appendChild(element);</span><br><span class="line">        //给创建的DOM设置属性</span><br><span class="line">        for(let key in props)&#123;</span><br><span class="line">            if(!props.hasOwnProperty(key)) break;</span><br><span class="line">            //样式类和行内样式特殊处理</span><br><span class="line">            if(key === &apos;className&apos;)&#123;</span><br><span class="line">                element.setAttribute(&apos;class&apos;,props[key]);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(key === &apos;style&apos;)&#123;</span><br><span class="line">                let styObj = props[&apos;style&apos;];</span><br><span class="line">                for(let attr in styObj)&#123;</span><br><span class="line">                   if(!styObj.hasOwnProperty(attr))&#123;</span><br><span class="line">                       element.style[attr] = styObj[attr];</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //children处理</span><br><span class="line">            if(key === &quot;children&quot;)&#123;</span><br><span class="line">                //统一转成数组操作</span><br><span class="line">                let children = props[children];</span><br><span class="line">                if(!Array.isArray(children))&#123;</span><br><span class="line">                    children = [children];</span><br><span class="line">                &#125;</span><br><span class="line">                //循环子元素</span><br><span class="line">                children.forEach(item=&gt;&#123;</span><br><span class="line">                    //如果是文本，直接创建文本节点赋值给element即可</span><br><span class="line">                    //如果是新的虚拟DOM对象，则需要重复调用render方法，把新创建的DOM对象增加给element（递归）</span><br><span class="line">                    if(typeof item ===&quot;string&quot;)&#123;</span><br><span class="line">                        element.appendChild(document.createTextNode(item));</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    render(item,element);</span><br><span class="line">                &#125;)</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            element.setAttribute(key,props[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        //触发回调函数</span><br><span class="line">        callback &amp;&amp; callback();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react脚手架</title>
      <link href="/2020/10/28/2020-10-28-react%E8%84%9A%E6%89%8B%E6%9E%B6-md/"/>
      <url>/2020/10/28/2020-10-28-react%E8%84%9A%E6%89%8B%E6%9E%B6-md/</url>
      
        <content type="html"><![CDATA[<h2 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h2><blockquote><p>create-react-app 是React官方为我们提供的脚手架</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//全局安装脚手架</span><br><span class="line">$ npm install -g create-react-app</span><br><span class="line">//创建项目</span><br><span class="line">$ create-react-app xxx</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="脚手架默认安装"><a href="#脚手架默认安装" class="headerlink" title="脚手架默认安装"></a>脚手架默认安装</h3><ul><li>react</li><li>react-dom 开发HTML页面应用  （与之相对应的还有react-native 开发原生APP）</li><li>react-scripts</li></ul><blockquote><p>react和vue一样，脚手架都会默认把配置好的webpack配置项隐藏在<code>node_modules</code>中</p></blockquote><p>vue中为我们提供了<code>vue.config.js</code>文件让用户能够自己修改配置项</p><p>react中想要修改配置项</p><ol><li>需要使用<code>eject</code>命令，将配置文件暴露出来</li></ol><p><strong>package.json 配置文件</strong></p><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/de5fc100-18fa-11eb-b680-7980c8a877b8.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn eject/npm run eject</span><br></pre></td></tr></table></figure><ol start="2"><li><code>eject</code>操作是不可逆转的，react要求我们在暴露之前先将代码通过<code>git</code>提交历史区</li></ol><blockquote><p>config -&gt; webpack配置项</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-config</span><br><span class="line">    |- webpack.config.js</span><br><span class="line">    |- webpackDevServer.config.js</span><br><span class="line">    |- path.js （存放各配置的地址文件信息）</span><br><span class="line">    |- ...</span><br></pre></td></tr></table></figure><blockquote><p>scripts </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-script</span><br><span class="line">    |- start.js     开发环境下 $ yarn start 先执行这个文件</span><br><span class="line">    |- build.js     生产环境下 $ yarn build 先执行这个文件</span><br><span class="line">    |- ...</span><br></pre></td></tr></table></figure><h3 id="public-index-html-入口页面"><a href="#public-index-html-入口页面" class="headerlink" title="public/index.html 入口页面"></a>public/index.html 入口页面</h3><blockquote><p>当前项目SPA单页面应用情况下唯一的入口页面（后期所有编写的模块，都会放在index.html的#root中）</p></blockquote><ol><li>默认情况下，我们会把所有需要开发引入的资源（样式|图片…）和编写的模块等都放在src目录中（webpack本身就是打包src目录，根据入口的index.js的依赖项打包）</li><li>但是有些东西我们需要写在index.html中</li></ol><ul><li><p>页面导入最后打包的css、js，由于打包后文件比较大，第一次请求页面需要一点时间，这段时间内，我们看到的就是白屏效果</p><ul><li>为了解决白屏效果，我们可能会在index.html中设置loading效果（这些内容是一加载页面就展现出来的）</li><li>给资源做304缓存</li></ul></li><li><p>有一些模块不支持，CommonJS/ES6Module这种模块导入导出规范，此时需要我们把这些模块导入在index.html单独的script导入</p></li><li><p>还可以把一些公共资源直接在这里导入（这样webpack就不会把内容打包在一起）</p></li></ul><h3 id="src-index-js-入口文件"><a href="#src-index-js-入口文件" class="headerlink" title="src/index.js 入口文件"></a>src/index.js 入口文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|- src</span><br><span class="line">    |- assets</span><br><span class="line">    |- component</span><br><span class="line">    |- pages</span><br><span class="line">    |- store</span><br><span class="line">    |- index.js</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;,document.getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure><h3 id="配置向后兼容"><a href="#配置向后兼容" class="headerlink" title="配置向后兼容"></a>配置向后兼容</h3><ul><li><p>browserlist</p><ul><li><a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">browserlist</a></li></ul></li><li><p>Polyfill(react-app-polyfill)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个简单的Vuex</title>
      <link href="/2020/10/25/2020-10-25-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Vuex-md/"/>
      <url>/2020/10/25/2020-10-25-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Vuex-md/</url>
      
        <content type="html"><![CDATA[<h2 id="Vuex-Store"><a href="#Vuex-Store" class="headerlink" title="Vuex.Store"></a>Vuex.Store</h2><blockquote><p>Vuex中定义的是<code>Store类</code>，创建的也是Store的实例</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/3a157580-1766-11eb-9dfb-6da8e309e0d8.png"><a id="more"></a><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><blockquote><p>Vuex也是通过<code>Vue.use</code>的方式，通过插件的方式来使用的。use方法会默认去找install方法执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let Vue = null;</span><br><span class="line"></span><br><span class="line">function install(_vue)&#123;</span><br><span class="line">    if(_vue &amp;&amp; _vue ==Vue)&#123;     //防止重复注册vuex</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    Vue = _vue;</span><br><span class="line">    Vue.mixin(&#123;     //通过 mixin 混入的方式将store实例挂在到所有的组件上</span><br><span class="line">        beforeCreate()&#123;</span><br><span class="line">            if(this.$options.store)&#123;</span><br><span class="line">                //store已经注入到Vue实例中了</span><br><span class="line">                this.$store = this.$options.store;  //将vuex实例挂在到实例上</span><br><span class="line">            &#125;else if(this.$parent)&#123;</span><br><span class="line">                this.$store = this.$parent.$store;  //遍历到子组件的时候，直接去父组件那里拿vuex实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Store类的实现"><a href="#Store类的实现" class="headerlink" title="Store类的实现"></a>Store类的实现</h3><ul><li><code>state</code>中的属性是响应式的，这里可以通过<code>new Vue</code>的方式将用户配置的state传入Vue实例的data中，后面我们直接获取实例中data劫持后的state数据即可</li><li><code>mutations</code>和<code>actions</code>的实现方式是相同的，通过箭头函数将用户传入的函数包装一下，在里面通过call来改变this指向，页面中执行的是我们包装的箭头函数</li><li><code>getters</code>通过<code>Object.defineProperty</code>转化成getter来实现缓存效果,用户获取getters中的属性时，获取到的是对应函数执行的结果</li><li><code>commit</code>和<code>dispatch</code>都是直接定义在实例上的，直接通过用户传入的type值，从store实例上直接拿到对应函数执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Store&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        //this.state = options.state </span><br><span class="line">        //vuex中的数据是响应式的</span><br><span class="line">        let vm = new Vue(&#123;</span><br><span class="line">            data:&#123;</span><br><span class="line">                state: options.state</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        //实例挂载属性</span><br><span class="line">        this.state = vm.state;</span><br><span class="line"></span><br><span class="line">        this.mutations = &#123;&#125;;    </span><br><span class="line">        let mutations = options.mutations || &#123;&#125;;</span><br><span class="line">        Object.keys(mutations).forEach(key=&gt;&#123;   //遍历mutations给每个函数包装一层闭包，通过call的方式将this改成vuex实例</span><br><span class="line">            this.mutations[key] = (payload)=&gt;&#123;</span><br><span class="line">                mutations[key].call(this,this.state,payload)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        this.actions = &#123;&#125;;</span><br><span class="line">        let actions = options.actions || &#123;&#125;;</span><br><span class="line">        Object.keys(actions).forEach(key=&gt;&#123;   //actions的实现方式和mutations一样</span><br><span class="line">            this.actions[key] = (payload)=&gt;&#123;</span><br><span class="line">                actions[key].call(this,this,payload)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        this.getters = &#123;&#125;;</span><br><span class="line">        let getters = options.getters || &#123;&#125;;</span><br><span class="line">        Object.keys(getters).forEach(key=&gt;&#123;</span><br><span class="line">            Object.defineProperty(this.getters,key,&#123;</span><br><span class="line">                get:()=&gt;&#123;</span><br><span class="line">                    return getters[key].call(this,this.state)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    commit(type,payload)&#123;</span><br><span class="line">        this.mutations[type](payload)</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(type,payload)&#123;</span><br><span class="line">        this.actions[type](payload)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><blockquote><p>辅助函数的实现方式都大同小异，都是将我们在普通操作vuex中比较繁琐的<code>导入</code>封装成一个个函数来提供快捷的操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">export function mapState(ary=[])&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    ary.forEach(key=&gt;&#123;</span><br><span class="line">        obj[key] = function()&#123;</span><br><span class="line">            return this.$store.state[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function mapGetters(ary=[])&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    ary.forEach(key=&gt;&#123;</span><br><span class="line">        obj[key] = function(parmas)&#123;</span><br><span class="line">            return this.$store.getters(key,parmas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function mapMutations(ary=[])&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    ary.forEach(key=&gt;&#123;</span><br><span class="line">        obj[key] = function(parmas)&#123;</span><br><span class="line">            return this.$store.commit(key,parmas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function mapActions(ary=[])&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    ary.forEach(key=&gt;&#123;</span><br><span class="line">        obj[key] = function(parmas)&#123;</span><br><span class="line">            return this.$store.dispatch(key,parmas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><blockquote><p>自此我们就通过很多重复逻辑，实现了一个最简单的vuex</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">let Vue = null;</span><br><span class="line"></span><br><span class="line">class Store&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        let vm = new Vue(&#123;</span><br><span class="line">            data:&#123;</span><br><span class="line">                state: options.state</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        this.state = vm.state;</span><br><span class="line">        this.mutations = &#123;&#125;;    </span><br><span class="line">        let mutations = options.mutations || &#123;&#125;;</span><br><span class="line">        Object.keys(mutations).forEach(key=&gt;&#123;   //遍历mutations给每个函数包装一层闭包，通过call的方式将this改成vuex实例</span><br><span class="line">            this.mutations[key] = (payload)=&gt;&#123;</span><br><span class="line">                mutations[key].call(this,this.state,payload)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        this.actions = &#123;&#125;;</span><br><span class="line">        let actions = options.actions || &#123;&#125;;</span><br><span class="line">        Object.keys(actions).forEach(key=&gt;&#123;   //actions的实现方式和mutations一样</span><br><span class="line">            this.actions[key] = (payload)=&gt;&#123;</span><br><span class="line">                actions[key].call(this,this,payload)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        this.getters = &#123;&#125;;</span><br><span class="line">        let getters = options.getters || &#123;&#125;;</span><br><span class="line">        Object.keys(getters).forEach(key=&gt;&#123;</span><br><span class="line">            Object.defineProperty(this.getters,key,&#123;</span><br><span class="line">                get:()=&gt;&#123;</span><br><span class="line">                    return getters[key].call(this,this.state)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    commit(type,payload)&#123;</span><br><span class="line">        this.mutations[type](payload)</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(type,payload)&#123;</span><br><span class="line">        this.actions[type](payload)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function install(_vue)&#123;</span><br><span class="line">    if(_vue &amp;&amp; _vue ==Vue)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    Vue = _vue;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        beforeCreate()&#123;</span><br><span class="line">            if(this.$options.store)&#123;</span><br><span class="line">                //store已经注入到Vue实例中了</span><br><span class="line">                this.$store = this.$options.store;  //将vuex实例挂在到实例上</span><br><span class="line">            &#125;else if(this.$parent)&#123;</span><br><span class="line">                this.$store = this.$parent.$store;  //遍历到子组件的时候，直接去父组件那里拿vuex实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//辅助函数</span><br><span class="line">export function mapState(ary=[])&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    ary.forEach(key=&gt;&#123;</span><br><span class="line">        obj[key] = function()&#123;</span><br><span class="line">            return this.$store.state[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">export function mapGetters(ary=[])&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    ary.forEach(key=&gt;&#123;</span><br><span class="line">        obj[key] = function(parmas)&#123;</span><br><span class="line">            return this.$store.getters(key,parmas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">export function mapMutations(ary=[])&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    ary.forEach(key=&gt;&#123;</span><br><span class="line">        obj[key] = function(parmas)&#123;</span><br><span class="line">            return this.$store.commit(key,parmas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">export function mapActions(ary=[])&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    ary.forEach(key=&gt;&#123;</span><br><span class="line">        obj[key] = function(parmas)&#123;</span><br><span class="line">            return this.$store.dispatch(key,parmas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">    install,</span><br><span class="line">    Store,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueRouter源码解析</title>
      <link href="/2020/10/22/2020-10-22-VueRouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-md/"/>
      <url>/2020/10/22/2020-10-22-VueRouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-md/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>vue-router的源码不算很多，本文并没有对源码进行逐行的分析，而是将主要的核心思想抽离出来，尽量的模拟实现整个vue-router的运作过程。</p></blockquote><a id="more"></a><h3 id="初始化应用"><a href="#初始化应用" class="headerlink" title="初始化应用"></a>初始化应用</h3><blockquote><p>在构建Vue应用的时候，我们都需要使用<code>Vue.use(plugin)</code>，以安装插件的方式来安装VueRouter，同时需要在Vue上挂在router实例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">let a = new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">import Home from &apos;./views/Home.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &apos;hash&apos;,</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;home&apos;,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/about&apos;,</span><br><span class="line">      name: &apos;about&apos;,</span><br><span class="line">      component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &apos;./views/About.vue&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="install-插件安装"><a href="#install-插件安装" class="headerlink" title="install 插件安装"></a>install 插件安装</h3><blockquote><p><code>vue-router</code>是官方为我们提供的插件，只要是插件就需要在<code>new Vue()</code>之前使用<code>Vue.use(plugin)</code>调用。而use方法会默认查找插件中的<code>install</code>方法执行，如果插件是一个函数，会被当做install执行。</p></blockquote><blockquote><p>VueRouter的install具体做了什么？</p></blockquote><ul><li>全局注册<code>router-link</code>和<code>router-view</code>组件</li><li>mixin全局混入<code>_route</code>和<code>_router</code></li><li>用<code>defineProperty</code>将<code>_route</code>和<code>_router</code>代理到<code>$route</code>和<code>$router</code></li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/e3450400-14d6-11eb-880a-0db19f4f74bb.png"><p><strong>install.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import RouterLink from &apos;./components/router-link&apos;;</span><br><span class="line">import RouterView from &apos;./components/router-view&apos;;</span><br><span class="line">export let Vue</span><br><span class="line"></span><br><span class="line">const install = function(_Vue)&#123;</span><br><span class="line">    Vue = _Vue;</span><br><span class="line">    Vue.component(&apos;router-link&apos;,RouterLink);</span><br><span class="line">    Vue.component(&apos;router-view&apos;,RouterView);</span><br><span class="line">    </span><br><span class="line">    //Vue.mixin 混入 Vue中的高阶组建，给每个组件添加功能</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        beforeCreate()&#123;</span><br><span class="line">            // console.log(&quot;name&quot;,this.options.name);</span><br><span class="line">            if(this.options.router)&#123;</span><br><span class="line">                this._routerRoot = this;    //根实例</span><br><span class="line">                this._router = this.options.router</span><br><span class="line">                this._router.init(this)</span><br><span class="line">                Vue.util.defineReactive(this,&quot;_route&quot;,this._router.history.current);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //儿子 孙子</span><br><span class="line">                this._routerRoot = this.$parent &amp;&amp; this.$parent._routerRoot</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    Object.defineProperty(Vue.prototype,&apos;$route&apos;,&#123;</span><br><span class="line">        get()&#123;</span><br><span class="line">            return this._routerRoot &amp;&amp; this._routerRoot._route;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    Object.defineProperty(Vue.prototype,&apos;$router&apos;,&#123;</span><br><span class="line">        get()&#123;</span><br><span class="line">            return this._routerRoot &amp;&amp; this._routerRoot._router;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default install;</span><br></pre></td></tr></table></figure><h2 id="new-VueRouter"><a href="#new-VueRouter" class="headerlink" title="new VueRouter()"></a>new VueRouter()</h2><blockquote><p>下图是整个<code>new VueRouter</code>的整个过程，创建的router实例注入Vue实例中，并通过mixin混入到所有组件中，通过$router获取到的就是router实例了</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/e74b5c60-145a-11eb-81ea-f115fe74321c.png"><p><strong>index.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import install from &apos;./install&apos;;</span><br><span class="line">import creatMatcher from &apos;./create-matcher&apos;;</span><br><span class="line">import HashHistory from &apos;./history/hashHistory&apos;</span><br><span class="line">import BrowserHistory from &apos;./history/browserHistory&apos;</span><br><span class="line"></span><br><span class="line">class VueRouter&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        //需要根据用户配置，制作映射表(创建一个匹配器)</span><br><span class="line">        //1.匹配功能 match  </span><br><span class="line">        //2. 动态添加路由的功能 addRoutes</span><br><span class="line">        this.matcher = creatMatcher(options,routes||[])</span><br><span class="line">        // 创建历史管理</span><br><span class="line">        this.mode = options.mode || &quot;hash&quot;;</span><br><span class="line">        switch(this.mode)&#123;</span><br><span class="line">            case &quot;hash&quot;:</span><br><span class="line">                this.history = new HashHistory(this);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;history&quot;:</span><br><span class="line">                this.history = new BrowserHistory(this);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init(app)&#123;  //this VueRouter实例上的方法</span><br><span class="line">        //需要根据当前路径，实现页面跳转的逻辑</span><br><span class="line">        //页面跳转的时候，会进行匹配的操作  根据路劲获取对应的记录</span><br><span class="line">        let setupHashListener = ()=&gt;&#123;</span><br><span class="line">            history.setupListener()     //hashChange</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const history = this.history;</span><br><span class="line">        //路径跳转和匹配的功能</span><br><span class="line">        history.transitionTo(history.getCurrentLocation(),setupHashListener)</span><br><span class="line">        //根据current的值监听route</span><br><span class="line">        history.listen((route)=&gt;&#123;</span><br><span class="line">            app._route = route; //更新视图的操作，当current变化后再次更新_route属性</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    match(location)&#123;</span><br><span class="line">        return this.matcher.match(location);</span><br><span class="line">    &#125;</span><br><span class="line">    // transitionTo  跳转路劲的逻辑   hash和browser都有</span><br><span class="line">    // getCurrentLocation  获取当前路径  hash和browser实现方式不一样</span><br><span class="line">    // setupHashListener  监听hash</span><br><span class="line">    push(location)&#123;</span><br><span class="line">        window.location.hash = location</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VueRouter.install = install;</span><br><span class="line"></span><br><span class="line">export default VueRouter;</span><br></pre></td></tr></table></figure><h3 id="matcher"><a href="#matcher" class="headerlink" title="matcher"></a>matcher</h3><blockquote><p>matcher是router实例上挂载的第一个属性，上面存储了两个主要的方法<code>match</code>和<code>addRoutes</code>，<code>match</code>用来根据用户输入的路径获取匹配记录，<code>addRoutes</code>用来动态添加路由</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/459714f0-14fe-11eb-81ea-f115fe74321c.png"><p><strong>create-matcher.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import createRouteMap from &apos;./create-route-map&apos;</span><br><span class="line">import &#123;createRoute&#125; from &apos;./history/base&apos;</span><br><span class="line"></span><br><span class="line">export default function creatMatcher(routes)&#123;</span><br><span class="line">    //获取所有的路径  route =&gt; pathlist pathMap</span><br><span class="line">    let &#123;pathlist,pathMap&#125; = createRouteMap(routes)</span><br><span class="line">    //根据用户输入的路径获取匹配记录</span><br><span class="line">    const match = function match(location)&#123; </span><br><span class="line">        let record = pathMap[location]; //获取对应的记录</span><br><span class="line">        return createRoute(record,&#123;path:location&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    //动态添加路由</span><br><span class="line">    const addRoutes = function addRoutes(routes)&#123;</span><br><span class="line">        createRouteMap(routes,pathlist,pathMap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        match,</span><br><span class="line">        addRoutes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>create-route-map.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function addRouteRecord(route,pathList,pathMap,parentRecord)&#123;</span><br><span class="line">    let path = parentRecord ? `$&#123;parentRecord&#125;/$&#123;route.path&#125;` : route.path;</span><br><span class="line">    let record = &#123;  //当前路由产生的记录 path component</span><br><span class="line">        path,</span><br><span class="line">        component:route.component,</span><br><span class="line">        parent:parentRecord</span><br><span class="line">    &#125;</span><br><span class="line">    if(!pathMap[path])&#123; //防止用户编写路由时有重复，不去覆盖</span><br><span class="line">        pathList.push(path);</span><br><span class="line">        pathMap[path] = record;</span><br><span class="line">    &#125;</span><br><span class="line">    if(route.children)&#123; //子路由页要放在对应的pathList,pathMap中</span><br><span class="line">        route.children.forEach(r=&gt;&#123;</span><br><span class="line">            addRouteRecord(r,pathList,pathMap,record)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createRouteMap(routes,oldPathList,oldPathMap)&#123;</span><br><span class="line">    let oldPathList = oldPathList || [];</span><br><span class="line">    let oldPathMap = oldPathMap || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    routes.forEach(route=&gt;&#123;</span><br><span class="line">        addRouteRecord(route,pathList,pathMap)</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">        pathList,</span><br><span class="line">        pathMap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default createRouteMap;</span><br></pre></td></tr></table></figure><h3 id="new-HashHistory"><a href="#new-HashHistory" class="headerlink" title="new HashHistory()"></a>new HashHistory()</h3><blockquote><p><code>new VueRouter</code>除了生成实例之外的最主要的作用就是，区分<code>mode</code>模式，在用户未定义mode的时候默认是<code>hash</code>模式，这里我们主要讲解hash模式下的处理，<code>history</code>模式下的代码不是很多，这里就不讲解了，有兴趣的朋友可以从npm上拉下来看一看。</p></blockquote><p><strong>开局那张图</strong><br><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/e74b5c60-145a-11eb-81ea-f115fe74321c.png"></p><p><strong>base.js</strong>：公共类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export const createRoute = (record,location)=&gt;&#123; //根据匹配的记录来计算匹配到的所有的记录</span><br><span class="line">    let matched = [];</span><br><span class="line">    if(record)&#123;</span><br><span class="line">        while(record)&#123;</span><br><span class="line">            matched.unshift(record);</span><br><span class="line">            record = record.parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        ...location,</span><br><span class="line">        matched</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class History&#123;</span><br><span class="line">    constructor(router)&#123;</span><br><span class="line">        this.router = router;</span><br><span class="line">        this.current = createRoute(null,&#123;   //null表示没有匹配到</span><br><span class="line">            path:&apos;/&apos;</span><br><span class="line">        &#125;);     //matched 的值是一个[]</span><br><span class="line">    &#125;</span><br><span class="line">    transitionTo(localtion,complete)&#123;</span><br><span class="line">        //获取当前路径匹配出对应的记录，当路径变化的时候，获取到对应的记录=&gt;渲染页面</span><br><span class="line">        let current = this.router.match(localtion);</span><br><span class="line">        //防止重复点击，不需要再次渲染</span><br><span class="line">        //匹配到的路劲和个数都相同就不需要再次跳转了</span><br><span class="line">        if(this.current.path === location &amp;&amp; this.current.matched.length === current.matched.length)&#123;</span><br><span class="line">            return </span><br><span class="line">        &#125;</span><br><span class="line">        this.current = current; //用最新匹配的结果，去更新视图</span><br><span class="line">        //_route更新</span><br><span class="line">        this.cb &amp;&amp; this.cb(current);</span><br><span class="line">        //当路径变化后，监视hash再次进行匹配操作</span><br><span class="line">        complete &amp;&amp; complete()</span><br><span class="line">    &#125;</span><br><span class="line">    listen(cb)&#123;</span><br><span class="line">        this.cb = cb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hashHistory.js</strong>：HashHistory类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import History from &quot;./base&quot;;</span><br><span class="line"></span><br><span class="line">const ensureHash = ()=&gt;&#123;</span><br><span class="line">    if(window.location.hash)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    window.location.hash = &quot;/&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class HashHistory extends History&#123;</span><br><span class="line">    constructor(router)&#123;</span><br><span class="line">        super(router);</span><br><span class="line">        this.router = router;</span><br><span class="line">        ensureHash()</span><br><span class="line">    &#125;</span><br><span class="line">    //获取当前路径</span><br><span class="line">    getCurrentLocation()&#123;</span><br><span class="line">        return window.location.hash.slice(1);</span><br><span class="line">    &#125;</span><br><span class="line">    setupListener()&#123;</span><br><span class="line">        window.addEventListener(&apos;hashchange&apos;,()=&gt;&#123;</span><br><span class="line">            //再次执行匹配的操作</span><br><span class="line">            this.transitionTo(this.getCurrentLocation());</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="router-link-amp-router-view"><a href="#router-link-amp-router-view" class="headerlink" title="router-link &amp; router-view"></a>router-link &amp; router-view</h3><blockquote><p><code>router-link</code>默认渲染成a标签，用于点击跳转的载体；<code>router-view</code>是用于存放组件的容器</p></blockquote><p><strong>router-link.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name:&apos;router-link&apos;,</span><br><span class="line">  functional:true,</span><br><span class="line">  props:&#123;</span><br><span class="line">    to:&#123;</span><br><span class="line">      type:String,</span><br><span class="line">      required:true</span><br><span class="line">    &#125;,</span><br><span class="line">    tag:&#123;</span><br><span class="line">      type:String</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render(h,context)&#123;</span><br><span class="line">    let tag = context.tag || &apos;a&apos;;</span><br><span class="line">    const clickHandler = ()=&gt;&#123; </span><br><span class="line">        context.parent.$router.push(context.props.to);</span><br><span class="line">    &#125;</span><br><span class="line">    return h(tag,&#123;</span><br><span class="line">      on: &#123;</span><br><span class="line">        click: clickHandler</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,context.slots().default);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>router-view.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    name: &apos;router-view&apos;,</span><br><span class="line">    functional: true, </span><br><span class="line">    render(h,context) &#123; </span><br><span class="line">        let &#123;</span><br><span class="line">            parent,</span><br><span class="line">            data</span><br><span class="line">        &#125; = context;</span><br><span class="line">        let route = parent.$route;</span><br><span class="line">        let depth = 0;</span><br><span class="line">        data.routerView = true; </span><br><span class="line">        while (parent) &#123;</span><br><span class="line">            if (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) &#123;</span><br><span class="line">                depth++;</span><br><span class="line">            &#125;</span><br><span class="line">            parent = parent.$parent;</span><br><span class="line">        &#125;</span><br><span class="line">        let record = route.matched[depth];</span><br><span class="line">        if (!record) &#123;</span><br><span class="line">            return h(); </span><br><span class="line">        &#125;</span><br><span class="line">        return h(record.component, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router的基本使用</title>
      <link href="/2020/10/21/2020-10-21-vue-router%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-md/"/>
      <url>/2020/10/21/2020-10-21-vue-router%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-md/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><blockquote><p><code>Vue Router</code> 是 Vue.js 官方为我们提供的的路由管理器，通过<code>Vue Router</code>能够帮助我们更快的构建单页面应用。</p></blockquote><blockquote><p>Vue.js的核心是将一个应用程序划分为多个组件，通过组件组合的方式实现一个单页面应用，而<code>Vue Router</code>的作用就是帮助我们实现各组件之间的跳转。我们要做的是将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。</p></blockquote><a id="more"></a><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>HTML</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Hello App!&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;!-- 使用 router-link 组件来导航. --&gt;</span><br><span class="line">    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span><br><span class="line">    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span><br><span class="line">    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;!-- 路由出口 --&gt;</span><br><span class="line">  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>JavaScript</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">// 1. 定义 (路由) 组件。</span><br><span class="line">// 可以从其他文件 import 进来</span><br><span class="line">const Foo = &#123; template: &apos;&lt;div&gt;foo&lt;/div&gt;&apos; &#125;</span><br><span class="line">const Bar = &#123; template: &apos;&lt;div&gt;bar&lt;/div&gt;&apos; &#125;</span><br><span class="line"></span><br><span class="line">// 2. 定义路由</span><br><span class="line">// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是</span><br><span class="line">// 通过 Vue.extend() 创建的组件构造器，</span><br><span class="line">// 或者，只是一个组件配置对象。</span><br><span class="line">// 我们晚点再讨论嵌套路由。</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/foo&apos;, component: Foo &#125;,</span><br><span class="line">  &#123; path: &apos;/bar&apos;, component: Bar &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 3. 创建 router 实例，然后传 `routes` 配置</span><br><span class="line">// 还可以传别的配置参数</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes // (缩写) 相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 4. 创建和挂载根实例。</span><br><span class="line">// 记得要通过 router 配置参数注入路由，</span><br><span class="line">// 从而让整个应用都有路由功能</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>在我们将路由器注入应用之后，我们就可以在任意组件中通过<code>this.$router</code>的方式访问路由器，也可以通过<code>this.$route</code>的方式来访问当前路由</p></blockquote><h3 id="hash-amp-history-模式"><a href="#hash-amp-history-模式" class="headerlink" title="hash &amp; history  模式"></a>hash &amp; history  模式</h3><blockquote><p><code>hash</code>模式是vue-router的默认模式，使用的是URL的hash来模拟完整的URL，当URL改变时，是不会触发页面的重新加载的，但是这种模式有一个唯一的缺点，就是在路径中显示<code>#</code>会让URL看起来比较“丑”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//hash 借助的是 `onhashchange`</span><br><span class="line">window.onhashchange = function()&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>history</code>模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面，但是这种模式需要后台配置，不然当用户在浏览器直接访问 <code>http://oursite.com/user/id</code> 就会返回 404，这就不好了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//history 借助的是 `popstate` `replacestate`</span><br></pre></td></tr></table></figure><blockquote><p><code>abstract</code>模式，用于Node.js环境下</p></blockquote><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="号传参"><a href="#号传参" class="headerlink" title="?号传参"></a><code>?号</code>传参</h4><blockquote><p>直接通过?的方式可以实现少量的参数传递</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/?a=12&quot;&gt;首页&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h4 id="query传参"><a href="#query传参" class="headerlink" title="query传参"></a><code>query</code>传参</h4><blockquote><p>通过这种方式我们可以直接将参数放在一个对象中传递过去</p></blockquote><blockquote><p>:to={path:’/‘,query:参数}</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//直接传递对象</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:Home,query:&#123;a:1,b:2&#125;&#125;&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line">//将对象放在data中的obj中，将obj动态的传递过去</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:Home,query:obj&#125;&#125;&quot;&gt;首页&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><blockquote><p>参数接收： <code>this.$route.query</code></p></blockquote><h4 id="parmas传参"><a href="#parmas传参" class="headerlink" title="parmas传参"></a><code>parmas</code>传参</h4><blockquote><p>通过动态路径传参的方式，将参数传递</p></blockquote><blockquote><p>:to=”{name:组件名,parmas:{属性名要和路由映射表向对应} }</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name:about,parmas:&#123;a:1,b:2&#125;&#125;&quot;&gt;关于页&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 这种方式需要配合映射表一起使用</span><br><span class="line"> *  &#123;</span><br><span class="line"> *      path:&apos;about/:a/:b&apos;</span><br><span class="line"> *      component: about</span><br><span class="line"> *  &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><blockquote><p>参数接收： <code>this.$route.parmas</code></p></blockquote><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><blockquote><p>$router中存储的都是一些方法，$route中存储的都是一些参数</p></blockquote><h4 id="this-router-push"><a href="#this-router-push" class="headerlink" title="this.$router.push()"></a>this.$router.push()</h4><blockquote><p><code>this.$router.push()</code>,push中传递的参数等同于to后面的内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">router.push(&apos;home&apos;)</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">router.push(&#123; path: &apos;home&apos; &#125;)</span><br><span class="line"></span><br><span class="line">// 命名的路由</span><br><span class="line">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: &apos;123&apos; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 带查询参数，变成 /register?plan=private</span><br><span class="line">router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userId = &apos;123&apos;</span><br><span class="line">router.push(&#123; name: &apos;user&apos;, params: &#123; userId &#125;&#125;) // -&gt; /user/123</span><br><span class="line">router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123</span><br><span class="line">// 这里的 params 不生效</span><br><span class="line">router.push(&#123; path: &apos;/user&apos;, params: &#123; userId &#125;&#125;) // -&gt; /user</span><br></pre></td></tr></table></figure><h4 id="this-router-replace"><a href="#this-router-replace" class="headerlink" title="this.$router.replace()"></a>this.$router.replace()</h4><blockquote><p>跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录</p></blockquote><table><thead><tr><th align="left">声明式</th><th align="left">编程式</th></tr></thead><tbody><tr><td align="left"><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td><td align="left"><code>router.replace(...)</code></td></tr></tbody></table><h4 id="go-amp-back"><a href="#go-amp-back" class="headerlink" title="go &amp; back"></a>go &amp; back</h4><blockquote><p><code>this.$router.go()</code>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在浏览器记录中前进一步，等同于 history.forward()</span><br><span class="line">router.go(1)</span><br><span class="line"></span><br><span class="line">// 后退一步记录，等同于 history.back()</span><br><span class="line">router.go(-1)</span><br><span class="line"></span><br><span class="line">// 前进 3 步记录</span><br><span class="line">router.go(3)</span><br><span class="line"></span><br><span class="line">// 如果 history 记录不够用，那就默默地失败呗</span><br><span class="line">router.go(-100)</span><br><span class="line">router.go(100)</span><br></pre></td></tr></table></figure><blockquote><p><code>this.$router.back()</code> == <code>this.$router.go(-1)</code></p></blockquote><p><strong>参考文档</strong></p><ul><li><a href="https://router.vuejs.org/zh/guide/" target="_blank" rel="noopener">Vue Router官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件及组件间的通信</title>
      <link href="/2020/10/19/2020-10-19-Vue%E7%BB%84%E4%BB%B6%E5%8F%8A%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1-md/"/>
      <url>/2020/10/19/2020-10-19-Vue%E7%BB%84%E4%BB%B6%E5%8F%8A%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1-md/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><blockquote><p>组件时Vue中最强大的功能之一，组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树</p></blockquote><img src="/images/loading.png" data-original="https://www.runoob.com/wp-content/uploads/2017/01/components.png"><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><blockquote><p>通过 <code>Vue.component(tagName, options)</code> 的方式注册的全局组件，我们可以在项目的任何地方调用，所有实例都能够使用。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;runoob&gt;&lt;/runoob&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 在创建实例之前注册全局组件</span><br><span class="line">    Vue.component(&apos;runoob&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;自定义组件!&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    // 创建根实例</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;runoob&gt;&lt;/runoob&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=&quot;run&quot;&gt;</span><br><span class="line">    &lt;h1&gt;自定义组件!&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 在创建实例之前注册全局组件</span><br><span class="line">    Vue.component(&apos;runoob&apos;, &#123;</span><br><span class="line">      template: &apos;#run&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    // 创建根实例</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><blockquote><p>我们也可以在实例选项中注册局部组件，这样组件只能在这个实例中使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;runoob&gt;&lt;/runoob&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Child = &#123;</span><br><span class="line">  template: &apos;&lt;h1&gt;自定义组件!&lt;/h1&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 创建根实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    // &lt;runoob&gt; 将只在父模板可用</span><br><span class="line">    &apos;runoob&apos;: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在真实项目中每一个<code>.vue</code>的文件都是一个组件，我们的注册方式决定了是全局组件还是局部组件，通常我们都是用来定义局部组件</p><h2 id="组件间传值"><a href="#组件间传值" class="headerlink" title="组件间传值"></a>组件间传值</h2><h3 id="props-自定义属性-amp-emit-自定事件"><a href="#props-自定义属性-amp-emit-自定事件" class="headerlink" title="props+自定义属性 &amp; $emit+自定事件"></a>props+自定义属性 &amp; $emit+自定事件</h3><blockquote><p>相信大家在学习Vue的时候都听过，Vue是<code>双向数据绑定，单向数据流</code>，双向数据绑定不用说，单向数据流就是指的prop数据的传播只能由父组件传递给子组件，父组件通过<code>prop</code>给子组件下发数据，但是并不是说子组件就没有办法给父组件传值了，子组件可以通过<code>$emit</code>触发自定义事件给父组件发送信息</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/a2455f90-11cf-11eb-8bd0-2998ac5bbf7e.png"><h4 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h4><blockquote><p>我们可以自定prop的验证规则，校验出入值是否符合我们的预期，如果不符合预期则会在控制台中发出警告。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br><span class="line">    propA: Number,</span><br><span class="line">    // 多个可能的类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    // 必填的字符串</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // 带有默认值的数字</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    // 带有默认值的对象</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      // 对象或数组默认值必须从一个工厂函数获取</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &apos;hello&apos; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        // 这个值必须匹配下列字符串中的一个</span><br><span class="line">        return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。</p></blockquote><h3 id="attrs-listeners隔代组件传值"><a href="#attrs-listeners隔代组件传值" class="headerlink" title="$attrs/$listeners隔代组件传值"></a>$attrs/$listeners隔代组件传值</h3><blockquote><p><code>$attrs</code>和<code>$listeners</code>传递的方式其实和上一种方式是相似的，$attrs会接收所有在组件上定义的自定义属性（被props接收了的将接收不到），$listeners是接收所有的自定义事件。</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/c593aa60-11d4-11eb-8a36-ebb87efcf8c0.png"><h3 id="ref与-parent-children父子组件传值"><a href="#ref与-parent-children父子组件传值" class="headerlink" title="ref与$parent/$children父子组件传值"></a>ref与$parent/$children父子组件传值</h3><blockquote><p>这种方式就比较流氓了，直接将父组件的实例或子组件的实例拿过来操作，这样的话有个非常不好的点，就在于这种没有依赖关系的修改，在后期维护的时候，子组件较多的时候，不能分辨到底是哪个组件将父组件的数据改变，不推荐使用。</p></blockquote><h3 id="provide-inject隔代组件传值"><a href="#provide-inject隔代组件传值" class="headerlink" title="provide/inject隔代组件传值"></a>provide/inject隔代组件传值</h3><blockquote><p><code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。如果传入的值是字符串，数字，布尔值等基本类型则会无响应！</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/890fbc10-11d8-11eb-9dfb-6da8e309e0d8.png"><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><blockquote><p>Vuex是一个公共仓库，任何组件都是可以在这里取值</p></blockquote><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p><strong>参考文献</strong> </p><ul><li><p><a href="https://www.runoob.com/vue2/vue-component.html" target="_blank" rel="noopener">菜鸟教程</a></p></li><li><p><a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">Vue官方文档</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue核心响应式原理和模板编译</title>
      <link href="/2020/10/16/2020-10-16-Vue%E6%A0%B8%E5%BF%83%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-md/"/>
      <url>/2020/10/16/2020-10-16-Vue%E6%A0%B8%E5%BF%83%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-md/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h2><blockquote><p>Vue2.0是基于<code>Object.defineProperty</code>来实现数据劫持的，这也是Vue的核心api。当我们传入一个<code>JavaScript对象</code>来作为Vue的<code>data</code>属性，Vue在内部会遍历这个对象的所有属性，并通过Object.defineProperty来将<code>数据劫持</code>，转化为<code>getter</code>或<code>setter</code>，转化之后Vue就可以<code>追踪依赖</code>，在属性值访问和修改的时候<code>通知变更</code>。每一个组件实例都对应一个<code>watcher实例</code>，在组件渲染的过程中把“接触”过的数据 <code>property</code> 记录为依赖。当依赖项的 <code>setter</code> 触发时，会通知 watcher，从而使它关联的组件<code>重新渲染</code>。</p></blockquote><a id="more"></a><p><strong>官网图片</strong><br><img src="/images/loading.png" data-original="https://cn.vuejs.org/images/data.png"></p><blockquote><p>Vue3.0中将数据劫持的核心api，替换成了Proxy的方式实现，其本质核心还是对于data数据的监听，通过Proxy代理对象的方式可以直接将整个对象直接监听，而不需要再去遍历属性，这样就大大的提高了效率（属性是对象的时候还是需要再Proxy一下）</p></blockquote><h2 id="Vue核心原理"><a href="#Vue核心原理" class="headerlink" title="Vue核心原理"></a>Vue核心原理</h2><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/600deca0-0fb3-11eb-b680-7980c8a877b8.png"><h3 id="Vue类（资源调度）"><a href="#Vue类（资源调度）" class="headerlink" title="Vue类（资源调度）"></a>Vue类（资源调度）</h3><blockquote><p>Vue类在整个项目中扮演的是<code>资源调度者</code>的身份，主要是将我们在new Vue的时候传入的参数以及Vue实例分发给不同的类来完成相对应的功能</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/b36f76b0-1040-11eb-8ff1-d5dcf8779628.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//基类 负责调度</span><br><span class="line">class Vue&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        //给实例添加属性</span><br><span class="line">        this.$el = options.el;</span><br><span class="line">        this.$data = options.data;</span><br><span class="line"></span><br><span class="line">        //根元素 存在 编译模板</span><br><span class="line">        if(this.$el)&#123;</span><br><span class="line">            //把数据 全部转化成 Object.defineProperty 定义</span><br><span class="line">            new Observer(this.$data);</span><br><span class="line">            </span><br><span class="line">            //将DOM模板和vms实例传入  通过模板的指令</span><br><span class="line">            new Compiler(this.$el,this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Observer类（数据劫持）"><a href="#Observer类（数据劫持）" class="headerlink" title="Observer类（数据劫持）"></a>Observer类（数据劫持）</h3><blockquote><p><code>Observer类</code>的主要作用是将我们传入的data数据逐一遍历，再通过<code>Object.defineProperty</code>的方式将属性转化成<code>getter</code>/<code>setter</code></p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/70d298c0-1075-11eb-81ea-f115fe74321c.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Observer&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.observer(data);</span><br><span class="line">    &#125;</span><br><span class="line">    observer(data)&#123;</span><br><span class="line">        if(data &amp;&amp; typeof data == &apos;object&apos;)&#123;</span><br><span class="line">            //如果是对象</span><br><span class="line">            for(let key in data)&#123;</span><br><span class="line">                this.defineReactive(data,key,data[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    defineReactive(obj,key,value)&#123;</span><br><span class="line">        this.observer(value);  </span><br><span class="line">        Object.defineProperty(obj,key,&#123;</span><br><span class="line">            get()&#123;</span><br><span class="line">                //创建watcjer时 会取到对应的内容，并且把watcher放到全局了</span><br><span class="line">                return value;</span><br><span class="line">            &#125;,</span><br><span class="line">            set:(newVal)=&gt;&#123;</span><br><span class="line">                if(value != newVal)&#123;</span><br><span class="line">                    this.observer(newVal)</span><br><span class="line">                    value = newVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Compiler类（编译模板）"><a href="#Compiler类（编译模板）" class="headerlink" title="Compiler类（编译模板）"></a>Compiler类（编译模板）</h3><blockquote><p><code>new Compile</code>执行主要干了三件事情</p></blockquote><ul><li>获取到元素模板，并将模板放到内存中</li><li>在内存中通过指令用数据编译模板</li><li>将编译号的元素模板放回到页面中</li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/3e8d7b90-1080-11eb-b997-9918a5dda011.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//编译类</span><br><span class="line">class Compiler&#123;</span><br><span class="line">    constructor(el,vm)&#123;</span><br><span class="line">        //判断el属性是不是元素，不是元素则获取元素</span><br><span class="line">        this.el = this.isElementNode(el) ? el :document.querySelector(el);</span><br><span class="line">        this.vm = vm;</span><br><span class="line">        </span><br><span class="line">        //这里我们是使用文档碎片来模拟Vue2.0的AST</span><br><span class="line">        //把当前元素中的节点的元素获取到，并放到内存中</span><br><span class="line">        let fragment = this.node2fragment(this.el);</span><br><span class="line"></span><br><span class="line">        //把节点中的内容替换</span><br><span class="line">        //用数据编译模板</span><br><span class="line">        this.compile(fragment)</span><br><span class="line">        //把内容塞回到页面去</span><br><span class="line">        this.el.appendChild(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是不是指令</span><br><span class="line">    isDirective(attrName)&#123;</span><br><span class="line">        return attrName.startsWith(&apos;v-&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 编译元素节点的方法</span><br><span class="line">    compileElement(node)&#123;</span><br><span class="line">        let attributes = node.attributes;</span><br><span class="line">        [...attributes].forEach(attr=&gt;&#123; // type = &quot;text&quot; v-model = &quot;shcool.name&quot;</span><br><span class="line">            let &#123;name,value:expr&#125; = attr;</span><br><span class="line">            //判断是不是指令</span><br><span class="line">            if(this.isDirective(name))&#123;     //v-model  v-html  v-bind</span><br><span class="line">                let [,directive] = name.split(&quot;-&quot;);     //v-on:click=&quot;xxx&quot;</span><br><span class="line">                let [directiveName,eventName] = directive.split(&quot;:&quot;)</span><br><span class="line">                //需要调用不同的指令来处理</span><br><span class="line">                CompileUtil[directiveName](node,expr,this.vm,eventName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    //编译文本节点的方法</span><br><span class="line">    compileText(node)&#123;  //判断当前文本节点的额内容是否包含小胡子语法&#123;&#123;xxx&#125;&#125;</span><br><span class="line">        let content = node.textContent;</span><br><span class="line">        if(/\&#123;\&#123;(.+?)\&#125;\&#125;/.test(content))&#123;  //找到所有符合条件元素</span><br><span class="line">            //文本节点</span><br><span class="line">            CompileUtil[&apos;text&apos;](node,content,this.vm);  //&#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; &#123;&#123;c&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //核心的编译方法 编译内存中的DOM节点</span><br><span class="line">    compile(node)&#123;</span><br><span class="line">        let childNodes = node.childNodes;</span><br><span class="line">        // console.log(childNodes);</span><br><span class="line">        [...childNodes].forEach(child=&gt;&#123;</span><br><span class="line">            if(this.isElementNode(child))&#123;</span><br><span class="line">                this.compileElement(child);</span><br><span class="line">                //如果是元素的话，需要把自己传进去，去遍历子元素</span><br><span class="line">                this.compile(child);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                this.compileText(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    //将节点放到文档碎片</span><br><span class="line">    node2fragment(node)&#123;   </span><br><span class="line">        let fragment = document.createDocumentFragment();</span><br><span class="line">        let firstChild;</span><br><span class="line">        while(firstChild = node.firstChild)&#123;</span><br><span class="line">            // appendChild具有移动性</span><br><span class="line">            fragment.appendChild(firstChild);</span><br><span class="line">        &#125;</span><br><span class="line">        return fragment;</span><br><span class="line">    &#125;</span><br><span class="line">    //是不是元素节点</span><br><span class="line">    isElementNode(node)&#123;    </span><br><span class="line">        return node.nodeType === 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompileUtil-指令编译工具"><a href="#CompileUtil-指令编译工具" class="headerlink" title="CompileUtil 指令编译工具"></a>CompileUtil 指令编译工具</h4><blockquote><p>为了方便我们后期拓展更多的指令，我们将用于指令编译的方法提取出来，放在一个对象中统一管理。</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/61b6ceb0-1084-11eb-b997-9918a5dda011.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">CompileUtil = &#123;</span><br><span class="line">    //根据表达式取到对应的数据</span><br><span class="line">    getVal(vm,expr)&#123;</span><br><span class="line">        return expr.split(&quot;.&quot;).reduce((data,current)=&gt;&#123;</span><br><span class="line">            return data[current]</span><br><span class="line">        &#125;,vm.$data)</span><br><span class="line">    &#125;,</span><br><span class="line">    getContentVal(vm,expr)&#123;</span><br><span class="line">        //遍历的表达式 将内容 重新替换成一个人完整的内容 返回去</span><br><span class="line">        return expr.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g,(...arg)=&gt;&#123;</span><br><span class="line">            return this.getVal(vm,arg[1])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    setValue(vm,expr,value)&#123;</span><br><span class="line">        expr.split(&quot;.&quot;).reduce((data,current,index,arr)=&gt;&#123;</span><br><span class="line">            if(index == arr.length-1)&#123;</span><br><span class="line">                return data[current] = value;</span><br><span class="line">            &#125;</span><br><span class="line">            return data[current]</span><br><span class="line">        &#125;,vm.$data)</span><br><span class="line">    &#125;,</span><br><span class="line">    //解析v-model指令</span><br><span class="line">    model(node,expr,vm)&#123;    //node是节点  expr表达式  vm是实例</span><br><span class="line">        //给输入框赋予valse属性</span><br><span class="line">        let fn = this.updater[&quot;modelUpdader&quot;];</span><br><span class="line">        new Watcher(vm,expr,(newVal)=&gt;&#123; //给输入框加一个观察者，当数据更新后会触发此方法，会拿新值给输入框赋值</span><br><span class="line">            fn(node,newVal);</span><br><span class="line">        &#125;);</span><br><span class="line">        node.addEventListener(&quot;input&quot;,(e)=&gt;&#123;</span><br><span class="line">            let value = e.target.value; //获取用户输入的内容</span><br><span class="line">            this.setValue(vm,expr,value);</span><br><span class="line">        &#125;)</span><br><span class="line">        let value = this.getVal(vm,expr);</span><br><span class="line">        fn(node,value);</span><br><span class="line">    &#125;,</span><br><span class="line">    html(node,expr,vm)&#123;</span><br><span class="line">        let fn = this.updater[&quot;htmlUpdader&quot;];</span><br><span class="line">        new Watcher(vm,expr,(newVal)=&gt;&#123; </span><br><span class="line">            fn(node,newVal);</span><br><span class="line">        &#125;);</span><br><span class="line">        let value = this.getVal(vm,expr);</span><br><span class="line">        fn(node,value);</span><br><span class="line">    &#125;,</span><br><span class="line">    on(node,expr,vm,eventName)&#123; //expr -&gt; change</span><br><span class="line">        node.addEventListener(eventName,(e)=&gt;&#123;</span><br><span class="line">            vm[expr].call(vm,e);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    text(node,expr,vm)&#123;//expr  =&gt; &#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; &#123;&#123;c&#125;&#125;</span><br><span class="line">        let fn = this.updater[&quot;textUpdater&quot;];</span><br><span class="line">        let content = expr.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g,(...args)=&gt;&#123;</span><br><span class="line">            //给文本中的每个 小胡子 加上观察者</span><br><span class="line">            new Watcher(vm,args[1],()=&gt;&#123;</span><br><span class="line">                fn(node,this.getContentVal(vm,expr));    //返回了一个全的字符串</span><br><span class="line">            &#125;)</span><br><span class="line">            return this.getVal(vm,args[1]);</span><br><span class="line">        &#125;);</span><br><span class="line">        fn(node,content);</span><br><span class="line">    &#125;,</span><br><span class="line">    updater:&#123;</span><br><span class="line">        //把数据插入到节点中</span><br><span class="line">        modelUpdader(node,value)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;,</span><br><span class="line">        htmlUpdader(node,value)&#123;  //xss工具</span><br><span class="line">            node.innerHTML = value;</span><br><span class="line">        &#125;,</span><br><span class="line">        textUpdater(node,value)&#123;</span><br><span class="line">            node.textContent = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Watcher（观察者）-amp-Dep（发布订阅）"><a href="#Watcher（观察者）-amp-Dep（发布订阅）" class="headerlink" title="Watcher（观察者）&amp; Dep（发布订阅）"></a>Watcher（观察者）&amp; Dep（发布订阅）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//观察者（发布订阅） 观察者  被观察者</span><br><span class="line">//订阅</span><br><span class="line">class Dep&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.subs = []; //事件池  存放所有的watcher</span><br><span class="line">    &#125;</span><br><span class="line">    //订阅</span><br><span class="line">    addSub(watcher)&#123;   //添加watcher</span><br><span class="line">        this.subs.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    //发布</span><br><span class="line">    notify()&#123;</span><br><span class="line">        this.subs.forEach(watcher=&gt;watcher.updata());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Watcher&#123;</span><br><span class="line">    constructor(vm,expr,cb)&#123;</span><br><span class="line">        this.vm = vm;</span><br><span class="line">        this.expr = expr;</span><br><span class="line">        this.cb = cb;</span><br><span class="line">        //默认先存放一个老值</span><br><span class="line">        this.oldValue = this.get();</span><br><span class="line">    &#125;</span><br><span class="line">    get()&#123;</span><br><span class="line">        Dep.target = this;  //先把自己放在this上</span><br><span class="line">        //取值 把观察者和数据关联起来</span><br><span class="line">        let value = CompileUtil.getVal(this.vm,this.expr);</span><br><span class="line">        Dep.target = null;  //不取消 任何值取值 都会添加watcher</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    updata()&#123;   //更新操作  数据变化之后 会调用观察者的updata方法</span><br><span class="line">        let newVal = CompileUtil.getVal(this.vm,this.expr);</span><br><span class="line">        if(newVal !== this.oldValue)&#123;</span><br><span class="line">            this.cb(newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在数据劫持的时候给每个属性注入观察者watcher，在数据被更改的时候通知事件池中的watcher执行</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/7bd1aa30-110c-11eb-9dfb-6da8e309e0d8.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">defineReactive(obj,key,value)&#123;</span><br><span class="line">    this.observer(value);  </span><br><span class="line">    let dep =new Dep(); //给每个属性 都加上一个具有发布订阅的功能</span><br><span class="line">    Object.defineProperty(obj,key,&#123;</span><br><span class="line">        get()&#123;</span><br><span class="line">            //创建watcher时 会取到对应的内容，并且把watcher放到全局了</span><br><span class="line">            Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">            return value;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:(newVal)=&gt;&#123;</span><br><span class="line">            if(value != newVal)&#123;</span><br><span class="line">                this.observer(newVal)</span><br><span class="line">                value = newVal;</span><br><span class="line">                //数据改变通知watcher执行</span><br><span class="line">                dep.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h2><blockquote><p>index.html</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;school.name&quot;&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123;school.name&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123;school.age&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;!-- 如果数据不变化 是与就不更新 --&gt;</span><br><span class="line">        &#123;&#123;getNewName&#125;&#125;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;button v-on:click=&quot;change&quot;&gt;更新操作&lt;/button&gt;</span><br><span class="line">        &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script src=&quot;MVVM.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        let vm = new Vue(&#123;</span><br><span class="line">            el:&quot;#app&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                school:&#123;</span><br><span class="line">                    name:&apos;BSmall&apos;,</span><br><span class="line">                    age:18</span><br><span class="line">                &#125;,</span><br><span class="line">                message:&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed:&#123;</span><br><span class="line">                getNewName()&#123;</span><br><span class="line">                    return this.school.name + &quot;11111&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                change()&#123;</span><br><span class="line">                    this.school.name = &quot;aaa&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>MVVM.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//观察者（发布订阅） 观察者  被观察者</span><br><span class="line">//订阅</span><br><span class="line">class Dep&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.subs = []; //存放所有的watcher</span><br><span class="line">    &#125;</span><br><span class="line">    //订阅</span><br><span class="line">    addSub(watcher)&#123;   //添加watcher</span><br><span class="line">        this.subs.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    //发布</span><br><span class="line">    notify()&#123;</span><br><span class="line">        this.subs.forEach(watcher=&gt;watcher.updata());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Watcher&#123;</span><br><span class="line">    constructor(vm,expr,cb)&#123;</span><br><span class="line">        this.vm = vm;</span><br><span class="line">        this.expr = expr;</span><br><span class="line">        this.cb = cb;</span><br><span class="line">        //默认先存放一个老值</span><br><span class="line">        this.oldValue = this.get();</span><br><span class="line">    &#125;</span><br><span class="line">    get()&#123;</span><br><span class="line">        Dep.target = this;  //先把自己放在this上</span><br><span class="line">        //取值 把观察者和数据关联起来</span><br><span class="line">        let value = CompileUtil.getVal(this.vm,this.expr);</span><br><span class="line">        Dep.target = null;  //不取消 任何值取值 都会添加watcher</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    updata()&#123;   //更新操作  数据变化之后 会调用观察者的updata方法</span><br><span class="line">        let newVal = CompileUtil.getVal(this.vm,this.expr);</span><br><span class="line">        if(newVal !== this.oldValue)&#123;</span><br><span class="line">            this.cb(newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现数据劫持的功能</span><br><span class="line">class Observer&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.observer(data);</span><br><span class="line">    &#125;</span><br><span class="line">    observer(data)&#123;</span><br><span class="line">        if(data &amp;&amp; typeof data == &apos;object&apos;)&#123;</span><br><span class="line">            //如果是对象</span><br><span class="line">            for(let key in data)&#123;</span><br><span class="line">                this.defineReactive(data,key,data[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    defineReactive(obj,key,value)&#123;</span><br><span class="line">        this.observer(value);  </span><br><span class="line">        let dep =new Dep(); //给每个属性 都加上一个具有发布订阅的功能</span><br><span class="line">        Object.defineProperty(obj,key,&#123;</span><br><span class="line">            get()&#123;</span><br><span class="line">                //创建watcjer时 会取到对应的内容，并且把watcher放到全局了</span><br><span class="line">                Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">                return value;</span><br><span class="line">            &#125;,</span><br><span class="line">            set:(newVal)=&gt;&#123;</span><br><span class="line">                if(value != newVal)&#123;</span><br><span class="line">                    this.observer(newVal)</span><br><span class="line">                    value = newVal;</span><br><span class="line">                    dep.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//编译类</span><br><span class="line">class Compiler&#123;</span><br><span class="line">    constructor(el,vm)&#123;</span><br><span class="line">        //判断el属性是不是元素，不是元素则获取</span><br><span class="line">        this.el = this.isElementNode(el) ? el :document.querySelector(el);</span><br><span class="line">        this.vm = vm;</span><br><span class="line">        //把当前元素中的节点的元素获取到，并放到内存中</span><br><span class="line">        let fragment = this.node2fragment(this.el);</span><br><span class="line"></span><br><span class="line">        //把节点中的内容替换</span><br><span class="line">        //用数据编译模板</span><br><span class="line">        this.compile(fragment)</span><br><span class="line">        //把内容塞回到页面去</span><br><span class="line">        this.el.appendChild(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是不是指令</span><br><span class="line">    isDirective(attrName)&#123;</span><br><span class="line">        return attrName.startsWith(&apos;v-&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 编译元素节点的方法</span><br><span class="line">    compileElement(node)&#123;</span><br><span class="line">        let attributes = node.attributes;</span><br><span class="line">        [...attributes].forEach(attr=&gt;&#123; // type = &quot;text&quot; v-model = &quot;shcool.name&quot;</span><br><span class="line">            let &#123;name,value:expr&#125; = attr;</span><br><span class="line">            //判断是不是指令</span><br><span class="line">            if(this.isDirective(name))&#123;     //v-model  v-html  v-bind</span><br><span class="line">                let [,directive] = name.split(&quot;-&quot;);     //v-on:click=&quot;xxx&quot;</span><br><span class="line">                let [directiveName,eventName] = directive.split(&quot;:&quot;)</span><br><span class="line">                //需要调用不同的指令来处理</span><br><span class="line">                CompileUtil[directiveName](node,expr,this.vm,eventName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    //编译文本节点的方法</span><br><span class="line">    compileText(node)&#123;  //判断当前文本节点的额内容是否包含小胡子语法&#123;&#123;xxx&#125;&#125;</span><br><span class="line">        let content = node.textContent;</span><br><span class="line">        if(/\&#123;\&#123;(.+?)\&#125;\&#125;/.test(content))&#123;  //找到所有符合条件元素</span><br><span class="line">            //文本节点</span><br><span class="line">            CompileUtil[&apos;text&apos;](node,content,this.vm);  //&#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; &#123;&#123;c&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //核心的编译方法 编译内存中的DOM节点</span><br><span class="line">    compile(node)&#123;</span><br><span class="line">        let childNodes = node.childNodes;</span><br><span class="line">        // console.log(childNodes);</span><br><span class="line">        [...childNodes].forEach(child=&gt;&#123;</span><br><span class="line">            if(this.isElementNode(child))&#123;</span><br><span class="line">                this.compileElement(child);</span><br><span class="line">                //如果是元素的话，需要把自己传进去，去遍历子元素</span><br><span class="line">                this.compile(child);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                this.compileText(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    //将节点放到文档碎片</span><br><span class="line">    node2fragment(node)&#123;   </span><br><span class="line">        let fragment = document.createDocumentFragment();</span><br><span class="line">        let firstChild;</span><br><span class="line">        while(firstChild = node.firstChild)&#123;</span><br><span class="line">            // appendChild具有移动性</span><br><span class="line">            fragment.appendChild(firstChild);</span><br><span class="line">        &#125;</span><br><span class="line">        return fragment;</span><br><span class="line">    &#125;</span><br><span class="line">    //是不是元素节点</span><br><span class="line">    isElementNode(node)&#123;    </span><br><span class="line">        return node.nodeType === 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CompileUtil = &#123;</span><br><span class="line">    //根据表达式取到对应的数据</span><br><span class="line">    getVal(vm,expr)&#123;</span><br><span class="line">        return expr.split(&quot;.&quot;).reduce((data,current)=&gt;&#123;</span><br><span class="line">            return data[current]</span><br><span class="line">        &#125;,vm.$data)</span><br><span class="line">    &#125;,</span><br><span class="line">    getContentVal(vm,expr)&#123;</span><br><span class="line">        //遍历的表达式 将内容 重新替换成一个人完整的内容 返回去</span><br><span class="line">        return expr.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g,(...arg)=&gt;&#123;</span><br><span class="line">            return this.getVal(vm,arg[1])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    setValue(vm,expr,value)&#123;</span><br><span class="line">        expr.split(&quot;.&quot;).reduce((data,current,index,arr)=&gt;&#123;</span><br><span class="line">            if(index == arr.length-1)&#123;</span><br><span class="line">                return data[current] = value;</span><br><span class="line">            &#125;</span><br><span class="line">            return data[current]</span><br><span class="line">        &#125;,vm.$data)</span><br><span class="line">    &#125;,</span><br><span class="line">    //解析v-model指令</span><br><span class="line">    model(node,expr,vm)&#123;    //node是节点  expr表达式  vm是实例</span><br><span class="line">        //给输入框赋予valse属性</span><br><span class="line">        let fn = this.updater[&quot;modelUpdader&quot;];</span><br><span class="line">        new Watcher(vm,expr,(newVal)=&gt;&#123; //给输入框加一个观察者，当数据更新后会触发此方法，会拿新值给输入框赋值</span><br><span class="line">            fn(node,newVal);</span><br><span class="line">        &#125;);</span><br><span class="line">        node.addEventListener(&quot;input&quot;,(e)=&gt;&#123;</span><br><span class="line">            let value = e.target.value; //获取用户输入的内容</span><br><span class="line">            this.setValue(vm,expr,value);</span><br><span class="line">        &#125;)</span><br><span class="line">        let value = this.getVal(vm,expr);</span><br><span class="line">        fn(node,value);</span><br><span class="line">    &#125;,</span><br><span class="line">    html(node,expr,vm)&#123;</span><br><span class="line">        let fn = this.updater[&quot;htmlUpdader&quot;];</span><br><span class="line">        new Watcher(vm,expr,(newVal)=&gt;&#123; </span><br><span class="line">            fn(node,newVal);</span><br><span class="line">        &#125;);</span><br><span class="line">        let value = this.getVal(vm,expr);</span><br><span class="line">        fn(node,value);</span><br><span class="line">    &#125;,</span><br><span class="line">    on(node,expr,vm,eventName)&#123; //expr -&gt; change</span><br><span class="line">        node.addEventListener(eventName,(e)=&gt;&#123;</span><br><span class="line">            vm[expr].call(vm,e);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    text(node,expr,vm)&#123;//expr  =&gt; &#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; &#123;&#123;c&#125;&#125;</span><br><span class="line">        let fn = this.updater[&quot;textUpdater&quot;];</span><br><span class="line">        let content = expr.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g,(...args)=&gt;&#123;</span><br><span class="line">            //给文本中的每个 小胡子 加上观察者</span><br><span class="line">            new Watcher(vm,args[1],()=&gt;&#123;</span><br><span class="line">                fn(node,this.getContentVal(vm,expr));    //返回了一个全的字符串</span><br><span class="line">            &#125;)</span><br><span class="line">            return this.getVal(vm,args[1]);</span><br><span class="line">        &#125;);</span><br><span class="line">        fn(node,content);</span><br><span class="line">    &#125;,</span><br><span class="line">    updater:&#123;</span><br><span class="line">        //把数据插入到节点中</span><br><span class="line">        modelUpdader(node,value)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;,</span><br><span class="line">        htmlUpdader(node,value)&#123;  //xss工具</span><br><span class="line">            node.innerHTML = value;</span><br><span class="line">        &#125;,</span><br><span class="line">        textUpdater(node,value)&#123;</span><br><span class="line">            node.textContent = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//基类 负责调度</span><br><span class="line">class Vue&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        //给实例添加属性</span><br><span class="line">        this.$el = options.el;</span><br><span class="line">        this.$data = options.data;</span><br><span class="line">        let computed = options.computed;</span><br><span class="line">        let methods = options.methods;</span><br><span class="line"></span><br><span class="line">        //根元素 存在 编译模板</span><br><span class="line">        if(this.$el)&#123;</span><br><span class="line">            //把数据 全部转化成 Object.defineProperty 定义</span><br><span class="line">            new Observer(this.$data);</span><br><span class="line">            </span><br><span class="line">            //</span><br><span class="line">            for(let key in computed)&#123;   //有依赖关系</span><br><span class="line">                Object.defineProperty(this.$data,key,&#123;</span><br><span class="line">                    get:()=&gt;&#123;</span><br><span class="line">                        return computed[key].call(this);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            for(let key in methods)&#123;   //有依赖关系</span><br><span class="line">                Object.defineProperty(this,key,&#123;</span><br><span class="line">                    get:()=&gt;&#123;</span><br><span class="line">                        return methods[key];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">             //把数据获取操作 vm上的取值操作都代理到vm.$data上</span><br><span class="line">             this.proxyVm(this.$data)</span><br><span class="line"></span><br><span class="line">            new Compiler(this.$el,this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    proxyVm(data)&#123;</span><br><span class="line">        for(let key in data)&#123;</span><br><span class="line">            Object.defineProperty(this,key,&#123;    //实现了可以通过vm取到$data中的数据</span><br><span class="line">                get()&#123;</span><br><span class="line">                    return data[key]; //进行了转化操作</span><br><span class="line">                &#125;,</span><br><span class="line">                set(newValue)&#123;</span><br><span class="line">                    data[key] = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件</title>
      <link href="/2020/10/14/2020-10-14-DOM%E4%BA%8B%E4%BB%B6-md/"/>
      <url>/2020/10/14/2020-10-14-DOM%E4%BA%8B%E4%BB%B6-md/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h2><blockquote><p><code>document.body.onclick = function(){}</code> 是给body绑定点击事件？</p></blockquote><p><strong>事件</strong>：是浏览器赋予元素的默认行为，可以理解为天生自带的，不论我们是否为其绑定方法，当某些行为触发的时候，相关的事件都会被触发执行</p><a id="more"></a><p><strong>事件绑定</strong>：给元素的默认行为绑定方法，这样可以在行为触发的时候，执行这个方法（如果不为某个事件绑定方法，事件还是会被触发，只是什么都不做）</p><h3 id="常见事件行为"><a href="#常见事件行为" class="headerlink" title="常见事件行为"></a>常见事件行为</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><ul><li><code>click</code> <strong>点击事件</strong>(PC端：频繁点击N次，触发N次点击事件)<strong>单击事件</strong>(移动端：300ms内没有发生第二次点击事件，算作单击事件行为，所以click在移动端有300ms的延迟)</li><li><code>dbclick</code> 双击事件</li><li><code>contextmenu</code> 鼠标右键点击触发</li><li><code>mousedown</code> 鼠标按下</li><li><code>mouseup</code> 鼠标抬起</li><li><code>mousemove</code> 鼠标移动</li><li><code>mouseover</code> 鼠标滑入</li><li><code>mouseout</code> 鼠标滑出</li><li><code>mouseenter</code> 鼠标进入</li><li><code>mouseleave</code> 鼠标离开</li><li><code>wheel</code> 鼠标滚轮滚动</li></ul><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><ul><li><code>keydown</code> 键盘按下</li><li><code>keyup</code> 键盘抬起</li><li><code>keypress</code> 长按（除Shift/Fn/CapsLock健之外）</li></ul><h4 id="手指事件"><a href="#手指事件" class="headerlink" title="手指事件"></a>手指事件</h4><blockquote><p>Touch Event 单手指事件模型</p></blockquote><ul><li><code>touchstart</code> 手指按下</li><li><code>touchmove</code> 手指移动</li><li><code>touchend</code> 手指松开</li></ul><blockquote><p>Gesture Event 多手指事件模型</p></blockquote><h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><ul><li><code>focus</code> 获取焦点</li><li><code>blur</code> 失去焦点</li><li><code>submit</code> 表单提交（前提：表单元素都包含在form中，并且点击的按钮是submit）</li><li><code>reset</code> 表单重置（前提：表单元素都包含在form中，并且点击的按钮是reset）</li><li><code>select</code> 下拉框内容选中</li><li><code>change</code> 内容改变</li><li><code>input</code> 移动端中，监控文本框中的内容随着输入改变而触发</li></ul><h4 id="资源事件"><a href="#资源事件" class="headerlink" title="资源事件"></a>资源事件</h4><ul><li><code>load</code> 加载成功（ window.onload/img.onload ）</li><li><code>error</code> 加载失败</li><li><code>beforeunload</code> 资源卸载之前（ window.onbeforeunload 页面关闭之前触发 ）</li></ul><h4 id="CSS3过渡事件"><a href="#CSS3过渡事件" class="headerlink" title="CSS3过渡事件"></a>CSS3过渡事件</h4><ul><li><code>transitionstart</code> CSS过渡开始</li><li><code>transitionend</code> CSS过渡已经完成</li><li><code>transitionrun</code> CSS过渡运行中</li></ul><h4 id="视图事件"><a href="#视图事件" class="headerlink" title="视图事件"></a>视图事件</h4><ul><li><code>resize</code> 元素或窗口大小改变</li><li><code>scroll</code> 滚动事件</li></ul><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><h3 id="DOM0级事件绑定"><a href="#DOM0级事件绑定" class="headerlink" title="DOM0级事件绑定"></a>DOM0级事件绑定</h3><blockquote><p>给元素默认的事件行为绑定方法，这样可以在行为触发的时候，执行这个方法</p></blockquote><pre><code>语法：[元素].on[事件]=[函数]document.body.onclick = function(){}移除绑定：赋值为null或者其他非函数的值document.body.onclick = null</code></pre><blockquote><p>原理：每一个DOM元素对象上的私有属性上都有很多类似于“onxxxx”的私有属性，我们为这些属性赋值，就是DOM0级事件绑定</p></blockquote><ul><li>如果没有对应事件的事件属性（如：DOMContentLoaded）则无法基于这种办法实现事件绑定</li><li>只能给当前元素的某个事件绑定一个方法，绑定多个最后一个会将之前绑定的覆盖</li><li>优势是执行效率快，使用方便</li></ul><h3 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h3><pre><code>语法：[元素].addEventListener([事件},[方法],[捕获/冒泡])document.body.addEventListener(click,fn1,flase);移除：[元素].removeEventListener([事件},[方法],[捕获/冒泡]) 需要与添加时的参数一致document.body.removeEventListener(click,fn1,flase);</code></pre><blockquote><p>原理：每一个DOM元素都会基于原型链的查找机制，找到<strong>EventTarget.prototype</strong>上的<code>addEventListener</code>和<code>removeEventListener</code>等方法，基于这些方法实现的事件绑定和移除采用的是<code>事件池机制</code>-<code>Event Pool</code></p></blockquote><ul><li>DOM2级事件绑定，绑定的方法一般不写匿名函数，主要是方便移除事件的时候使用</li><li>凡是浏览器提供的事件行为，都可以基于这种模式完成事件绑定和移除（DOMContentLoaded也可以添加）</li><li>可以同时给当前元素绑定多个不同的方法（进入事件池）,这样事件行为触发，会从事件池中按照绑定的；顺序依次取出执行</li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/fe0ddf80-0e1b-11eb-b244-a9f5e5565f30.png"><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><blockquote><p>给当前元素的某个事件行为绑定方法，当事件行为触发，不仅会把绑定的方法执行，还会给方法默认传递一个参数，这个参数就是事件对象</p></blockquote><p><strong>事件对象</strong>：存储当前事件操作及触发的相关信息（浏览器记录的当前操作的信息，和在那个函数中无关）</p><h3 id="MouseEvent-鼠标事件对象及常用属性"><a href="#MouseEvent-鼠标事件对象及常用属性" class="headerlink" title="MouseEvent 鼠标事件对象及常用属性"></a>MouseEvent 鼠标事件对象及常用属性</h3><table><thead><tr><th align="left">属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>type</code></td><td align="left">发生的事件的类型，例如”click”, “mouseover”</td></tr><tr><td align="left"><code>target,srcElement</code></td><td align="left">发生事件的节点，可能与currentTarget不同</td></tr><tr><td align="left"><code>currentTarget</code></td><td align="left">正在处理事件的节点，如果在capturing阶段和冒泡阶段处理事件，这个属性就与target属性不同。在事件监听函数中应该用这个属性而不是this</td></tr><tr><td align="left"><code>stopPropagation()</code></td><td align="left">可以阻止事件从当前正在处理他的节点传播</td></tr><tr><td align="left"><code>preventDefault()</code></td><td align="left">阻止浏览器执行与事件相关的默认动作，与0级DOM中返回false一样</td></tr><tr><td align="left"><code>clientX, clientY</code></td><td align="left">鼠标相对于浏览器的x坐标y坐标</td></tr><tr><td align="left"><code>screenX, screenY</code></td><td align="left">鼠标相对于显示器左上角的x坐标y坐标</td></tr><tr><td align="left"><code>pageX,pageY</code></td><td align="left">鼠标相对于页面的x坐标y坐标</td></tr><tr><td align="left"><code>path</code></td><td align="left">记录事件的传播路径</td></tr></tbody></table><blockquote><p>IE6-8不兼容preventDefault()和stopPropagation()，可以使用ev.renturnValue = false阻止默认行为,使用ev.canceBubble = true来阻止冒泡</p></blockquote><h3 id="键盘事件对象-KeyboardEvent"><a href="#键盘事件对象-KeyboardEvent" class="headerlink" title="键盘事件对象 KeyboardEvent"></a>键盘事件对象 KeyboardEvent</h3><ul><li>key/code 存储按键名字</li><li>which/KeyCode 获取按键的键盘码(Window)<ul><li>方向键（左37 上38 右39 下40）</li><li><code>Space</code> 32 </li><li><code>BackSpace</code> 8</li><li><code>Del</code> 46</li><li><code>Enter</code> 13</li><li><code>Shift</code> 16</li><li><code>Ctrl</code> 17</li><li><code>Alt</code> 18</li></ul></li><li>altKey 是否按下alt键（组合按键）</li><li>ctrlKey 是否按下ctrl键（组合按键）</li><li>shiftKey 是否按下shift键（组合按键）</li></ul><h3 id="手指事件对象-移动端-TouchEvent"><a href="#手指事件对象-移动端-TouchEvent" class="headerlink" title="手指事件对象(移动端) TouchEvent"></a>手指事件对象(移动端) TouchEvent</h3><ul><li>changedTouches / targetTouches / touches 都是用来记录手指的信息的，平时常用changedTouches<ul><li>changedTouches 手指按下、移动、离开屏幕都会记录存储，手指离开也会记录最后一次信息</li><li>touches 拿不到最后一次手指离开的信息</li><li>获取到的结果都是TouchList集合，记录每一根手指信息</li></ul></li><li>ev.changedTouches[0] 第一根手指信息 </li></ul><h3 id="普通事件对象-Event"><a href="#普通事件对象-Event" class="headerlink" title="普通事件对象 Event"></a>普通事件对象 Event</h3><h2 id="事件默认行为和事件传播机制"><a href="#事件默认行为和事件传播机制" class="headerlink" title="事件默认行为和事件传播机制"></a>事件默认行为和事件传播机制</h2><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><blockquote><p>浏览器会赋予元素很多默认行为，这些默认行为我们都可以基于ev.preventDefault来禁用默认行为</p></blockquote><ul><li>鼠标右键菜单</li><li>点击 <code>a</code> 标签实现页面跳转</li><li>部分浏览器会记录输入记录，在下一次输入的时候有模糊匹配</li><li>键盘按下会输入内容</li></ul><h3 id="事件传播机制"><a href="#事件传播机制" class="headerlink" title="事件传播机制"></a>事件传播机制</h3><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/c462d3f0-0e91-11eb-8bd0-2998ac5bbf7e.png"><blockquote><p>阶段一：捕获阶段（CAPTURING_PHASE） 从最外层元素一致向内层逐级查找，直到找到事件源为止；目的是为冒泡阶段的传播提供路径（ev.path存放的就是捕获阶段收集的传播路径）</p></blockquote><blockquote><p>阶段二：目标阶段（AT_TARGET） 把当前事件源的相关事件行为触发执行</p></blockquote><blockquote><p>阶段三：冒泡阶段（BUBBLING_PHASE） 按照捕获阶段收集的传播路径，不仅仅当前事件源的相关事件行为触发，而且从内到外，其祖先所有元素的相关事件行为也都会被触发</p></blockquote><p>DOM0级事件绑定中给元素行为绑定的方法，都是在目标阶段/冒泡阶段触发的</p><p>DOM2级事件绑定可以控制事件在捕获阶段执行（虽然没什么实际意义）</p><ul><li>[元素].addEventlistener(事件，方法，false/true)</li><li>最后一个参数默认是false：控制方法在冒泡阶段执行，如果设置为true就可以在捕获阶段执行了</li></ul><blockquote><p>阻止事件冒泡<code>ev.stopPropagation()</code>或者<code>ev.canceBubble=true</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//兼容IE6~8</span><br><span class="line">ev.stopPropagation() ? ev.stopPropagation() : ev.canceBubble=true ;</span><br></pre></td></tr></table></figure><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p><strong>事件委托的优点</strong>：</p><ul><li>可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件</li></ul><p>如上面代码所示，如果给每个li列表项都绑定一个函数，那对内存的消耗是非常大的，因此较好的解决办法就是将li元素的点击事件绑定到它的父元素ul身上，执行事件的时候再去匹配判断目标元素。</p><ul><li>可以实现当新增子对象时无需再次对其绑定（动态绑定事件）</li></ul><p>在很多时候，我们需要通过<code>AJAX</code>或者用户操作动态的增加或者删除列表项li元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p><p><strong>基本实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//将方法委托给body</span><br><span class="line">document.body.onclick = function(ev)&#123;</span><br><span class="line">    let target = ev.target,</span><br><span class="line">        targetClass = targetClass;</span><br><span class="line">    if(target === &quot;inner&quot;)&#123;</span><br><span class="line">        console.log(&quot;inner&quot;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(target === &quot;outer&quot;)&#123;</span><br><span class="line">        console.log(&quot;outer&quot;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(target === &quot;box&quot;)&#123;</span><br><span class="line">        console.log(&quot;box&quot;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><blockquote><p>使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。</p></blockquote><p><strong>参考文献</strong></p><p><a href="https://juejin.im/post/6844903853956022285" target="_blank" rel="noopener">理解：javascript中DOM0,DOM2,DOM3级事件模型</a></p><p><a href="https://blog.csdn.net/qq_38128179/article/details/86293394" target="_blank" rel="noopener">JavaScript事件代理（事件委托）</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染原理及性能优化</title>
      <link href="/2020/10/12/2020-10-12-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-md/"/>
      <url>/2020/10/12/2020-10-12-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-md/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器获取资源"><a href="#浏览器获取资源" class="headerlink" title="浏览器获取资源"></a>浏览器获取资源</h2><blockquote><p>在浏览器中输入URL地址之后，在经过一系列的网络解析、路由传输之后到达指定的服务器，服务器响应客户端请求并返回相应的资源</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/3aa0ea20-0c85-11eb-9dfb-6da8e309e0d8.png"><a id="more"></a><h2 id="浏览器渲染解析代码"><a href="#浏览器渲染解析代码" class="headerlink" title="浏览器渲染解析代码"></a>浏览器渲染解析代码</h2><blockquote><p>客户端从服务器获取到需要渲染页面的源代码后才能显示在浏览器的视图容器中，这个过程浏览器开辟一个“GUI渲染线程”，自上而下解析代码</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/ac10b330-0c98-11eb-8a36-ebb87efcf8c0.png"><blockquote><p>自上而下渲染解析代码的过程是“同步”的，但是有些操作也是异步的</p></blockquote><ol><li>关于CSS资源的加载</li></ol><ul><li><p>遇到的是<code>&lt;style&gt;</code> “内嵌样式”</p><ul><li>“同步” 交给GUI渲染线程解析</li></ul></li><li><p>遇到的是<code>&lt;link&gt;</code> “外链样式”</p><ul><li>“异步” 开辟一个新的“HTTP网络请求线程”　</li><li>注意：同一个源下，根据不同的浏览器，最多只允许同时开辟4～7个HTTP线程 “HTTP的并发数”</li><li>不等待资源信息请求回来，GUI渲染线程继续向下渲染</li><li>GUI渲染线程同步操作都处理完成后，再把基于HTTP图片络线程请求回来的资源文件进行解析渲染</li></ul></li><li><p>遇到<code>@import</code> “导入式样式”</p><ul><li>“同步” 开辟一个新的“HTTP网络请求线程”去请求资源文件</li><li>但是在资源文件没有请求回来之前，GUI渲染线程会被“阻塞”，不允许其继续向下渲染</li></ul></li></ul><ol start="2"><li>遇到<code>&lt;script&gt;</code>资源的请求</li></ol><ul><li><p>默认都是“同步”的：必须基于HTTP网络线程，把资源请求回来之后，并且交给“JS渲染线程”渲染解析完成后，GUI渲染线程才能继续向下渲染，所以<code>&lt;script&gt;</code>默认也是“阻碍GUI渲染”的</p></li><li><p>async属性：遇到<code>&lt;script async&gt;</code>首先也是开辟一个HTTP网络线程去请求加载资源文件，与此同时GUI渲染线程继续向下渲染「把默认的同步改为“异步”」，但是一旦当资源请求回来后，会中断GUI的渲染，先把请求回来的JS进行渲染解析</p></li><li><p>defer属性：遇到<code>&lt;script defer&gt;</code> 和async类似，都是新开辟HTTP网络线程去请求加载资源文件，与此同时GUI还会继续渲染「“异步”」，但是不一样的地方是，defer和link类似，是在GUI同步的代码渲染完成后，才会渲染解析请求回来的JS代码</p></li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/55f6d9f0-0c9a-11eb-b997-9918a5dda011.png"><ol start="3"><li>遇到<code>&lt;img&gt;</code>或者音视频资源</li></ol><ul><li>遇到这些资源，也会发送新的HTTP网络线程，请求加载对应的资源文件，不会阻碍GUI的渲染「“异步”」；当GUI渲染完成后，才会把请求回来资源信息进行渲染解析；</li></ul><blockquote><p>Webkit浏览器预测解析：chrome的预加载扫描器html-preload-scanner通过扫描节点中的 “src” , “link”等属性，找到外部连接资源后进行预加载，避免了资源加载的等待时间，同样实现了提前加载以及加载和执行分离</p></blockquote><h2 id="页面渲染步骤"><a href="#页面渲染步骤" class="headerlink" title="页面渲染步骤"></a>页面渲染步骤</h2><h3 id="1-DOM-Tree-DOM树"><a href="#1-DOM-Tree-DOM树" class="headerlink" title="1.DOM Tree(DOM树)"></a>1.DOM Tree(DOM树)</h3><blockquote><p>自上而下渲染完页面，整理好整个页面的DOM结构关系</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/276025b0-0d1c-11eb-b244-a9f5e5565f30.png"><ul><li>从服务器获取到字节流（进制编码）</li><li>将进制编码编译成具体字符</li><li>根据token解析生成不同的tag（词法解析，解析出起始和结束标签）</li><li>生成具体的DOM节点</li><li>按照相互的对照关系生成DOM树</li></ul><h3 id="2-CSSOM-Tree-样式树"><a href="#2-CSSOM-Tree-样式树" class="headerlink" title="2.CSSOM Tree(样式树)"></a>2.CSSOM Tree(样式树)</h3><blockquote><p>把所有的样式资源请求加载回来后，按照引入CSS的顺序，依次渲染样式代码，生成样式树</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/26b05db0-0d1c-11eb-81ea-f115fe74321c.png"><h3 id="3-RENDER-TREE-渲染树"><a href="#3-RENDER-TREE-渲染树" class="headerlink" title="3.RENDER TREE(渲染树)"></a>3.RENDER TREE(渲染树)</h3><blockquote><p>把生成的DOM树和CSSOM树合并在一起，生成渲染树（设置display:none的元素不进行处理）</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/2e730f70-0d1c-11eb-9dfb-6da8e309e0d8.png"><h3 id="4-Layout-布局-回流-重排"><a href="#4-Layout-布局-回流-重排" class="headerlink" title="4.Layout 布局/回流/重排"></a>4.Layout 布局/回流/重排</h3><blockquote><p>根据生成的渲染树，计算它们在设备视口(viewport)内的确切位置和大小</p></blockquote><h3 id="5-分层处理"><a href="#5-分层处理" class="headerlink" title="5.分层处理"></a>5.分层处理</h3><blockquote><p>按照层级定位分层处理，每一个层级都有会详细规划出具体的绘制步骤</p></blockquote><p>具体的绘制过程可以查看代码调试工具的 More-tools 下的 Layers</p><h3 id="6-Painting"><a href="#6-Painting" class="headerlink" title="6.Painting"></a>6.Painting</h3><blockquote><p>按照每一个层级计算处理的绘制步骤，开始绘制页面</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/35dcf2d0-0d1c-11eb-b997-9918a5dda011.png"><h2 id="前端性能优化：「CRP：关键渲染路径」"><a href="#前端性能优化：「CRP：关键渲染路径」" class="headerlink" title="前端性能优化：「CRP：关键渲染路径」"></a>前端性能优化：「CRP：关键渲染路径」</h2><h3 id="1-DOM-Tree"><a href="#1-DOM-Tree" class="headerlink" title="1. DOM Tree"></a>1. DOM Tree</h3><ul><li>减少DOM的层级嵌套</li><li>不要使用“非标准”的标签</li></ul><h3 id="2-CSSOM-Tree"><a href="#2-CSSOM-Tree" class="headerlink" title="2. CSSOM Tree"></a>2. CSSOM Tree</h3><ul><li>尽可能不要使用@import（阻塞GUI渲染）</li><li>如果CSS代码比较少，尽可能使用“style内嵌样式”（尤其是移动端开发）</li><li>如果使用link，尽可能把所有的样式资源合并为一个，且压缩（减少HTTP请求数量，因为HTTP的并发性也是有限制的，以及渲染CSS的时候，也不需要再计算依赖关系…）</li><li>CSS选择器链短一些（因为CSS选择器渲染是从右到左的）</li><li>把link等导入CSS的操作放在HEAD中（目的是：一加载页面就开始请求资源，同时GUI去生成DOM树 “CSS等资源预先加载”）</li></ul><h3 id="3-对于其他资源的优化"><a href="#3-对于其他资源的优化" class="headerlink" title="3. 对于其他资源的优化"></a>3. 对于其他资源的优化</h3><ul><li>对于<code>&lt;script&gt;</code>，尽可能放置在页面的底部（防止其阻塞GUI的渲染）；对于部分<code>&lt;script&gt;</code>需要使用async或者defer；</li><li>async是不管JS的依赖关系的，哪一个资源先获取到，就先把这个资源代码渲染执行</li><li>defer不会这样的，和link一样，是等待所有<code>&lt;script defer&gt;</code>都请求回来后，按照导入顺序/依赖关系依次渲染执行的 </li></ul><h3 id="4-对于-lt-img-gt"><a href="#4-对于-lt-img-gt" class="headerlink" title="4. 对于&lt;img&gt;"></a>4. 对于<code>&lt;img&gt;</code></h3><ul><li>懒加载：第一次加载页面的时候不要加载请求图片，哪怕它是异步的，但是也占据了HTTP并发的数量，导致其他资源延后加载</li><li>图片的BASE64：不用去请求加载图片，BASE64码基本上代表的就是图片，而且页面渲染图片的时候速度也会很快（慎用，但是在webpack工程化中可以使用，因为它基于file-loader可以自动base64）</li><li>雪碧图</li></ul><h3 id="5-Layout-Painting：重要的优化手段（减少DOM的“回流-重排”和重绘）"><a href="#5-Layout-Painting：重要的优化手段（减少DOM的“回流-重排”和重绘）" class="headerlink" title="5. Layout/Painting：重要的优化手段（减少DOM的“回流/重排”和重绘）"></a>5. Layout/Painting：重要的优化手段（减少DOM的“回流/重排”和重绘）</h3><ul><li><p>第一次加载页面必然会有一次回流和重绘</p></li><li><p>触发回流操作后，也必然绘触发重绘；如果只是单纯的重绘，则不会引发回流；性能优化点，重点都在回流上；</p></li><li><p>操作DOM消耗性能？ =&gt;DOM的回流</p><ul><li>元素在视口中的大小或者位置发生变化</li><li>元素的删除或者新增（以及基于display控制显示隐藏）</li><li>浏览器视口大小发生改变</li><li>这些操作都需要浏览器重新计算每一个元素在视口中的位置和大小（也就是重新Layout/Reflow）</li></ul></li><li><p>当代浏览的渲染队列机制</p></li></ul><p>在当前上下文操作中，遇到一行修改样式的代码，并没有立即通知浏览器渲染，而是把其放置在渲染队列中，接下来看是否还有修改样式的代码，如果有继续放置在渲染队列中…一直到再也没有修改样式的代码或者“遇到一行获取样式的操作”，这样都会刷新浏览器的渲染队列机制（也就是把现在队列中修改样式的操作，统一告诉浏览器渲染，这样只会引发一次回流）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">box.style.width = &quot;100px&quot;;</span><br><span class="line">box.style.height = &quot;200px&quot;;</span><br><span class="line">box.offsetHeight; </span><br><span class="line">// box.style.xxx 或者 window.getComputedStyle(box).xxx 再或者 box.clientWidth|Height|Top|Left 以及 box.offsetWidth|Height|Top|Left 或者 box.scrollWidth|Height|Top|Left ...这些获取样式的操作都会刷新渲染队列</span><br><span class="line">box.style.position = &quot;absolute&quot;;</span><br><span class="line">box.style.top = &quot;100px&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>优化思路：不要自己直接去操作DOM，例如vue/react</p></blockquote><ol><li>样式的“分离读写”：把修改样式和获取样式代码分离开</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* box.style.width = &quot;100px&quot;;</span><br><span class="line"> * box.style.height = &quot;200px&quot;;</span><br><span class="line"> * box.style.position = &quot;absolute&quot;;</span><br><span class="line"> * box.style.top = &quot;100px&quot;;</span><br><span class="line"> * box.offsetHeight;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">box.style.cssText = &quot;width:100px;height:200px;...&quot;;</span><br><span class="line">box.className = &quot;.boxActive&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* box.style.width = box.offsetWidth + 10 + &apos;px&apos;;</span><br><span class="line"> * box.style.height = box.offsetHeight + 10 + &apos;px&apos;;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">let w = box.offsetWidth,</span><br><span class="line">    h = box.offsetHeight;</span><br><span class="line">box.style.width = w + 10 + &apos;px&apos;;</span><br><span class="line">box.style.height = h + &apos;px&apos;;</span><br></pre></td></tr></table></figure><ol start="2"><li>新增元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];</span><br><span class="line">// 循环几次引发几次回流</span><br><span class="line">arr.forEach(item =&gt; &#123;</span><br><span class="line">    let span = document.createElement(&apos;span&apos;);</span><br><span class="line">    span.innerText = item;</span><br><span class="line">    document.body.appendChild(span);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>模板字符串：可能因为把原始容器的内容变为字符串和新的字符串拼接，最后再整体渲染回去，导致原始容器中的元素绑定的一些事件失效…</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str = ``;</span><br><span class="line">arr.forEach(item =&gt; &#123;</span><br><span class="line">    str += `&lt;span&gt;</span><br><span class="line">        $&#123;item&#125;</span><br><span class="line">    &lt;/span&gt;`;</span><br><span class="line">&#125;);</span><br><span class="line">document.body.innerHTML += str;</span><br></pre></td></tr></table></figure><blockquote><p>文档碎片：临时存放元素对象的容器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let frag = document.createDocumentFragment();</span><br><span class="line">arr.forEach(item =&gt; &#123;</span><br><span class="line">    let span = document.createElement(&apos;span&apos;);</span><br><span class="line">    span.innerText = item;</span><br><span class="line">    frag.appendChild(span);</span><br><span class="line">&#125;);</span><br><span class="line">document.body.appendChild(frag);</span><br><span class="line">frag = null;</span><br></pre></td></tr></table></figure><ol start="3"><li>把动画等频发样式改变的操纵，运用到position:fixed/absolute…上 「脱离文档流：单独一层」</li></ol><blockquote><p> 利用分层机制，如果只改变一个层面上的位置大小等信息，浏览器回流和重绘的速度会加快很多</p></blockquote><ol start="4"><li>修改元素的 transform / opacity（filters）… 的这些样式，不会引发DOM的回流 「浏览器的硬件加速，弊端就是消耗浏览器的内存」</li></ol>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue指令</title>
      <link href="/2020/10/09/2020-10-09-vue%E6%8C%87%E4%BB%A4-md/"/>
      <url>/2020/10/09/2020-10-09-vue%E6%8C%87%E4%BB%A4-md/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue指令系统"><a href="#Vue指令系统" class="headerlink" title="Vue指令系统"></a>Vue指令系统</h2><blockquote><p>Vue作为一款框架，它规定了自己的指令语法，用户通过指令实现相对应的功能，不需要关注底层是怎样运行的，只需要通过指令来操作模板即可（指令都是 v-xxx 行内属性）</p></blockquote><a id="more"></a><h3 id="v-text-amp-｛｛-｝｝"><a href="#v-text-amp-｛｛-｝｝" class="headerlink" title="v-text &amp; ｛｛ ｝｝"></a>v-text &amp; <code>｛｛ ｝｝</code></h3><blockquote><p>在Vue中实现数据绑定的最常用的方法就是<code>&quot;Mustache&quot;</code>语法（小胡子语法），也就是<code>｛｛ ｝｝</code>文本差值表达式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt; &#123;&#123; msg &#125;&#125; &lt;/span&gt;</span><br></pre></td></tr></table></figure><p>Mustache 标签将会被替代为对应数据对象上 msg 的属性值。无论何时，绑定的数据对象上 msg 属性值 发生了改变，插值处的内容都会更新。</p><blockquote><p><code>v-text</code> 的表现形式和<code>｛｛ Mustache ｝｝</code> 插值是一样的，只不过v-text是行内属性，小胡子可以直接放置到内容中。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//下面两种方法实现的效果是一致的</span><br><span class="line">&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>v-text 的优势：在初始渲染的时候v-text行内属性是看不到的，而 <code>｛｛ ｝｝</code> 在Vue模板渲染还未完成的时候会被用户看到这个双括号（但是我们基于功能工程化编译之后就不会出现这个问题了）</p><p><code>｛｛ ｝｝</code>的优势：数据拼接更加灵活</p><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><blockquote><p>相当于原生的innerHTML，内容按普通 HTML 插入，不会作为 Vue 模板进行编译。在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="v-cloak-amp-v-once-amp-v-pre"><a href="#v-cloak-amp-v-once-amp-v-pre" class="headerlink" title="v-cloak &amp; v-once &amp; v-pre"></a>v-cloak &amp; v-once &amp; v-pre</h3><blockquote><p>这三个属性后面都是不需要跟属性值的，直接在行内添加即可使用</p></blockquote><blockquote><p><code>v-cloak</code>是专门用来解决小胡子的显示的问题，需要配合css使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>原理：Vue在编译完成之前这个属性都存在于行内，所以通过属性选择器添加的样式会生效，当Vue编译完成之后，会将这个行内属性删除</p><blockquote><p><code>v-once</code>只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>v-pre</code>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><h3 id="v-if-amp-v-else-amp-v-else-if"><a href="#v-if-amp-v-else-amp-v-else-if" class="headerlink" title="v-if &amp; v-else &amp; v-else-if"></a>v-if &amp; v-else &amp; v-else-if</h3><blockquote><p><code>v-if</code>根据表达式的值的 truthiness（true/flase） 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是<code>&lt;template&gt;</code>，将提出它的内容作为条件块，也就是说<code>&lt;template&gt;</code>将不会被渲染成内容的父标签，而是将内容直接渲染到<code>&lt;template&gt;</code>的位置上。</p></blockquote><ul><li>当条件变化时该指令触发过渡效果。</li><li>当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。</li></ul><blockquote><p><code>v-else</code></p></blockquote><ul><li>不需要表达式</li><li>限制：前一兄弟元素必须有 v-if 或 v-else-if</li></ul><blockquote><p><code>v-else-if</code></p></blockquote><ul><li>限制：前一兄弟元素必须有 v-if 或 v-else-if</li></ul><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><blockquote><p>根据表达式之真假值，切换元素的 display CSS property,带有 v-show 的元素始终会被渲染并保留在 DOM 中，当条件变化时该指令触发过渡效果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h4 id="v-show-vs-v-if"><a href="#v-show-vs-v-if" class="headerlink" title="v-show vs v-if"></a><code>v-show</code> vs <code>v-if</code></h4><p>v-if </p><ul><li>是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li><li><strong>惰性</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li><li>在源码中通过一个三元表达式判断v-if的条件是否为真，符合的时候就使用creatElement渲染一个真实的标签，不符合条件就什么都不做</li></ul><p>v-show</p><ul><li>不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</li><li>源码中直接在行内渲染display通过none/block来控制显示隐藏 <code>el.style.display = (条件) ? block : none;</code></li></ul><blockquote><p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p></blockquote><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><blockquote><p>循环展示标签的一个指令，可以用来循环数组、对象、数字、字符串等</p></blockquote><p>我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.message&quot;&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-1&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &apos;Foo&apos; &#125;,</span><br><span class="line">      &#123; message: &apos;Bar&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul><li>缩写：@</li><li>参数：event</li><li>修饰符：</li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">.stop</td><td align="left">调用 event.stopPropagation()</td></tr><tr><td align="left">.prevent</td><td align="left">调用 event.preventDefault()</td></tr><tr><td align="left">.capture</td><td align="left">添加事件侦听器时使用 capture 模式</td></tr><tr><td align="left">.self</td><td align="left">只当事件是从侦听器绑定的元素本身触发时才触发回调</td></tr><tr><td align="left">.{keyCode|keyAlias}</td><td align="left">只当事件是从特定键触发时才触发回调</td></tr><tr><td align="left">.native</td><td align="left">监听组件根元素的原生事件</td></tr><tr><td align="left">.once</td><td align="left">只触发一次回调</td></tr><tr><td align="left">.left</td><td align="left">(2.2.0) 只当点击鼠标左键时触发</td></tr><tr><td align="left">.right</td><td align="left">(2.2.0) 只当点击鼠标右键时触发</td></tr><tr><td align="left">.middle</td><td align="left">(2.2.0) 只当点击鼠标中键时触发</td></tr><tr><td align="left">.passive</td><td align="left">(2.3.0) 以 { passive: true } 模式添加侦听器</td></tr></tbody></table><ul><li>用法</li></ul><p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p><p>用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。</p><ul><li>示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 方法处理器 --&gt;</span><br><span class="line">&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态事件 (2.6.0+) --&gt;</span><br><span class="line">&lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联语句 --&gt;</span><br><span class="line">&lt;button v-on:click=&quot;doThat(&apos;hello&apos;, $event)&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态事件缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 停止冒泡 --&gt;</span><br><span class="line">&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 阻止默认行为 --&gt;</span><br><span class="line">&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span><br><span class="line">&lt;form @submit.prevent&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  串联修饰符 --&gt;</span><br><span class="line">&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 键修饰符，键别名 --&gt;</span><br><span class="line">&lt;input @keyup.enter=&quot;onEnter&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 键修饰符，键代码 --&gt;</span><br><span class="line">&lt;input @keyup.13=&quot;onEnter&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击回调只会触发一次 --&gt;</span><br><span class="line">&lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对象语法 (2.4.0+) --&gt;</span><br><span class="line">&lt;button v-on=&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联语句 --&gt;</span><br><span class="line">&lt;my-component @my-event=&quot;handleThis(123, $event)&quot;&gt;&lt;/my-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 组件中的原生事件 --&gt;</span><br><span class="line">&lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul><li><p>缩写：:</p></li><li><p>参数：attrOrProp (optional)</p></li><li><p>修饰符：</p><ul><li><code>.prop</code> - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？)</li><li><code>.camel</code> - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)</li><li><code>.sync</code> (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。</li></ul></li><li><p>用法：</p><ul><li>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</li><li>在绑定 class 或 style attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</li><li>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</li><li>没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。</li></ul></li><li><p>示例：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 绑定一个 attribute --&gt;</span><br><span class="line">&lt;img v-bind:src=&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;</span><br><span class="line">&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;img :src=&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联字符串拼接 --&gt;</span><br><span class="line">&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- class 绑定 --&gt;</span><br><span class="line">&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- style 绑定 --&gt;</span><br><span class="line">&lt;div :style=&quot;&#123; fontSize: size + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 绑定一个全是 attribute 的对象 --&gt;</span><br><span class="line">&lt;div v-bind=&quot;&#123; id: someProp, &apos;other-attr&apos;: otherProp &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;</span><br><span class="line">&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span><br><span class="line">&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span><br><span class="line">&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- XLink --&gt;</span><br><span class="line">&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>.camel 修饰符允许在使用 DOM 模板时将 v-bind property 名称驼峰化，例如 SVG 的 viewBox property：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg :view-box.camel=&quot;viewBox&quot;&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>在使用字符串模板或通过 vue-loader/vueify 编译时，无需使用 .camel</p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>+限制：<br>    + <code>&lt;input&gt;</code><br>    + <code>&lt;select&gt;</code><br>    + <code>&lt;textarea&gt;</code><br>    + <code>components</code></p><ul><li><p>修饰符：</p><ul><li><code>.lazy</code> - 取代 input 监听 change 事件</li><li><code>.number</code> - 输入字符串转为有效的数字</li><li><code>.trim</code> - 输入首尾空格过滤</li></ul></li><li><p>用法：</p><ul><li>在表单控件或者组件上创建双向绑定</li><li>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。需要通过 JavaScript 在组件的 data 选项中声明初始值</li></ul></li><li><p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件</p><ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li><li>checkbox 和 radio 使用 checked property 和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul></li></ul><p><a href="https://cn.vuejs.org/v2/guide/forms.html#%E6%96%87%E6%9C%AC" target="_blank" rel="noopener">用法示例</a></p><h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><ul><li><p>缩写：#</p></li><li><p>预期：可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。</p></li><li><p>参数：插槽名 (可选，默认值是 default)</p></li><li><p>限用于</p><ul><li><code>&lt;template&gt;</code></li><li><code>组件</code> (对于一个单独的带 prop 的默认插槽)</li></ul></li><li><p>用法：</p></li></ul><p>提供具名插槽或需要接收 prop 的插槽。</p><ul><li>示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 具名插槽 --&gt;</span><br><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    Header content</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  Default slot content</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    Footer content</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 接收 prop 的具名插槽 --&gt;</span><br><span class="line">&lt;infinite-scroll&gt;</span><br><span class="line">  &lt;template v-slot:item=&quot;slotProps&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">      &#123;&#123; slotProps.item.text &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/infinite-scroll&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 接收 prop 的默认插槽，使用了解构 --&gt;</span><br><span class="line">&lt;mouse-position v-slot=&quot;&#123; x, y &#125;&quot;&gt;</span><br><span class="line">  Mouse position: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;</span><br><span class="line">&lt;/mouse-position&gt;</span><br></pre></td></tr></table></figure><p><strong>参考文献</strong></p><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习Vue之前你需要知道的知识</title>
      <link href="/2020/10/08/2020-10-08-%E5%AD%A6%E4%B9%A0Vue%E4%B9%8B%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86-md/"/>
      <url>/2020/10/08/2020-10-08-%E5%AD%A6%E4%B9%A0Vue%E4%B9%8B%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86-md/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue前置知识"><a href="#Vue前置知识" class="headerlink" title="Vue前置知识"></a>Vue前置知识</h2><h3 id="库和框架"><a href="#库和框架" class="headerlink" title="库和框架"></a>库和框架</h3><blockquote><p>库：库中封装了大量的方法，都是提供给开发者直接调用</p></blockquote><blockquote><p>框架：框架中也会封装大量的方法，但是框架中的方法通常是服务于框架的，开发者通过使用框架规定的语法，框架就会调用相应的方法实现</p></blockquote><a id="more"></a><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><blockquote><p>Vue是一个MVVM框架</p></blockquote><p><code>model</code>：数据模型</p><p><code>view</code>：UI视图</p><p><code>view-model</code>：交互工具</p><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/6f9a1290-093f-11eb-8ff1-d5dcf8779628.png"><h3 id="Vue类"><a href="#Vue类" class="headerlink" title="Vue类"></a>Vue类</h3><blockquote><p>vue说到底，它就是一个类，既然是类那么就需要new执行来创建实例</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/2606df20-096a-11eb-8ff1-d5dcf8779628.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过npm下载vue</span><br><span class="line">$ npm install vue -D</span><br></pre></td></tr></table></figure><blockquote><p>我们new Vue创建的实例是Vue应用的根组件，也就是说一个Vue应用只对应一个Vue实例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt; &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=../node_modules/vue/dist/vue.js&quot;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        //创建vue实例,传递一个对象</span><br><span class="line">        let vm = new Vue(&#123;</span><br><span class="line">            //Vue实例配置项，都是规定的</span><br><span class="line">            el:&quot;#app&quot;，</span><br><span class="line">            data:&#123;&#125;</span><br><span class="line">            //...</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><blockquote><p>Vue之所以可以通过数据改变通知视图更新，都是借助于Object.defineProperty这个方法（这个api不兼容IE8，所以如果使用Vue来创建项目就不用考虑兼容IE8了）</p></blockquote><p><code>defineProperty</code>顾名思义它是用来定义属性的一个方法，它与我们常用的obj.xxx=”xxx” 或者 obj[xxx]=”xxx” 的区别是，他提供了更多的定义方式来实现属性的行为特征。</p><table><thead><tr><th align="left">属性名</th><th align="left">含义</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">属性值</td><td align="left">undefined</td></tr><tr><td align="left">get</td><td align="left">给属性提供getter的方法，返回值被用作属性值</td><td align="left">undefined</td></tr><tr><td align="left">set</td><td align="left">给属性提供setter的方法，接收唯一参数并赋值给属性</td><td align="left">undefined</td></tr><tr><td align="left">writeable</td><td align="left">属性是否可重写</td><td align="left">false</td></tr><tr><td align="left">enumerable</td><td align="left">属性是否会出现在for in 或者 Object.keys()的遍历中</td><td align="left">false</td></tr><tr><td align="left">configurable</td><td align="left">是否配置，以及可否删除</td><td align="left">false</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj,&quot;name&quot;,&#123;</span><br><span class="line">    value:&quot;123&quot;,</span><br><span class="line">    writeable:false,    // 是否可枚举</span><br><span class="line">    enumerable:false,   // 是否可更改</span><br><span class="line">    configurable:false  // 是否可删除</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;,</span><br><span class="line">    value = 0;      //借助三方变量来实现set获取数据，get修改数据</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj,&quot;name&quot;,&#123;</span><br><span class="line">    get()&#123;</span><br><span class="line">        //当name属性被调用的时候，触发get：调用时获取的值，就是这个函数的返回值</span><br><span class="line">        return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(val)&#123;</span><br><span class="line">        //当name属性被赋值的时候，触发set:接收的val就是name被赋予的值</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>Object.freeze()</code>会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(),并把所有现有属性标记为writable: false,这样就无法修改它们的值。</p></blockquote><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><blockquote><p>Vue3中使用了Proxy代理的方式来实现的数据劫持，相较于Vue2中使用的defineProperty来说，Proxy代理的方式能够实现对整个对象的监听，而不是一个一个属性的劫持，这样的话就大大的增加了性能</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">// tempObj就是代理对象，往后我们直接操作tempObj即可</span><br><span class="line">var tempObj = new Proxy(obj,&#123;</span><br><span class="line">    get(target,key)&#123;</span><br><span class="line">        //target就是obj</span><br><span class="line">        //key就是我们调用的对应的属性名</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target,key,val)&#123;</span><br><span class="line">        //target,key 同get</span><br><span class="line">        //val就是属性修改的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>使用vue3的时候，如果浏览器不支持Proxy，还是会切换到defineProperty</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS同步异步编程及EventLoop机制</title>
      <link href="/2020/10/01/2020-10-01-JS%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%8F%8AEventLoop%E6%9C%BA%E5%88%B6-md/"/>
      <url>/2020/10/01/2020-10-01-JS%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%8F%8AEventLoop%E6%9C%BA%E5%88%B6-md/</url>
      
        <content type="html"><![CDATA[<h2 id="JS中的同步异步编程"><a href="#JS中的同步异步编程" class="headerlink" title="JS中的同步异步编程"></a>JS中的同步异步编程</h2><blockquote><p>进程、线程</p></blockquote><ul><li>进程代表的是一个程序（浏览器开一个页卡就是一个进程）</li><li>线程是用来处理进程中的具体事物，如果一个进程中有很多事情要做，就可以开辟很多线程</li><li>一个线程同时只能做一件事</li></ul><blockquote><p>浏览器是多线程的</p></blockquote><a id="more"></a><ul><li>GUI渲染线程</li><li>HTTP网络线程</li><li>JS渲染线程</li><li>监听线程等…</li></ul><blockquote><p>JS是单线程的：浏览器只分配一个线程来渲染JS代码</p></blockquote><ul><li>JS中的代码大部分都是“同步编程”，即上面的任务没有完成，下面的任务是无法处理的</li><li>但是JS利用浏览器的多线程机制，可以规划出“异步编程”效果<ul><li>定时器、AJAX/Fetch/跨域（HTTP网络请求）、事件绑定、promise中的异步、Generator函数、async/await…</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 计算程序执行的时间(预估)</span><br><span class="line"> *   + 运行监控 console.time/timeEnd（受当前电脑运行环境的影响）</span><br><span class="line"> *   + 时间复杂度(提前预估)</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">console.time(&apos;AAA&apos;);</span><br><span class="line">for (let i = 0; i &lt; 99999999; i++) &#123;&#125;</span><br><span class="line">console.timeEnd(&apos;AAA&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>死循环阻塞代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;&#125;</span><br><span class="line">console.log(&apos;OK&apos;); // 不执行：上述的死循环一直占用这“JS渲染线程”，线程空闲不下来，就处理不了其他的事情</span><br></pre></td></tr></table></figure><h3 id="定时器的异步编程"><a href="#定时器的异步编程" class="headerlink" title="定时器的异步编程"></a>定时器的异步编程</h3><ul><li>设置定时器任务是同步的</li><li>“间隔interval这么长时间，执行定时器绑定的函数” 这个任务是异步的</li><li>遇到异步任务，浏览器不会等待它执行完，则继续渲染下面的代码；当等到下面代码运行完，时间也到达了执行的条件，才会把异步任务执行；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// setTimeout(() =&gt; &#123;</span><br><span class="line">//     console.log(&quot;OK&quot;); //2</span><br><span class="line">// &#125;, 1000);</span><br><span class="line">// console.log(&apos;NO&apos;); //1</span><br></pre></td></tr></table></figure><blockquote><p>interval设置为零也不是立即执行，而是浏览器都有“最快反应时间（谷歌:5<del>6ms IE:13</del>17ms）”，设置为零，最快也需要等到5～6ms左右</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;OK&apos;); //2</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&apos;NO&apos;); //1</span><br></pre></td></tr></table></figure><p><strong>例题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;, 20);</span><br><span class="line">console.log(2);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;, 10);</span><br><span class="line">console.log(4);</span><br><span class="line">console.time(&apos;AA&apos;);</span><br><span class="line">for (let i = 0; i &lt; 90000000; i++) &#123;</span><br><span class="line">    // do soming</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&apos;AA&apos;); //=&gt;AA: 79ms 左右</span><br><span class="line">console.log(5);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(6);</span><br><span class="line">&#125;, 8);</span><br><span class="line">console.log(7);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(8);</span><br><span class="line">&#125;, 15);</span><br><span class="line">console.log(9);</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/afaaf370-03f1-11eb-8a36-ebb87efcf8c0.png"><h2 id="Promise及Promise中的异步"><a href="#Promise及Promise中的异步" class="headerlink" title="Promise及Promise中的异步"></a>Promise及Promise中的异步</h2><blockquote><p>我之前这一篇关于Promise的文章中有详细的讲解Promise的机制，有兴趣的小伙伴可以认真阅读。–<a href="https://lizhutao.github.io/2020/09/11/2020-09-11-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBPromise%EF%BC%8C%E6%89%BF%E8%AF%BA%E6%A8%A1%E5%BC%8F-md/#more" target="_blank" rel="noopener">深入解读Promise，承诺模式</a></p></blockquote><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><blockquote><p>async/await是ES7中新提供的语法糖</p></blockquote><ul><li>async修饰一个函数：保证函数返回的是一个promise实例<ul><li>和then很相似，函数执行不报错，返回成功的promise实例，报错返回的是失败的</li><li>return的值或者报错的原因就是promise实例的结果</li><li>如果return的是一个新的promise实例，则实例的结果影响返回值</li></ul></li></ul><ul><li>async最常用的应用，是为了修饰函数，让函数中可以使用await（想要使用await，所在的函数必须是async修饰的）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">    await fn();     //Uncaught SyntaxError: await is only valid in async function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>await [promise实例] 等待promise实例状态为成功的时候，再继续执行await后面的代码</li><li>await 修饰非promise实例的时候，直接算做成功</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(async function () &#123;</span><br><span class="line">    let x = await 10;</span><br><span class="line">    console.log(x); //10</span><br><span class="line"></span><br><span class="line">    let y = await Promise.resolve(20);</span><br><span class="line">    console.log(y); //20</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        let z = await Promise.reject(30); //await后面的promise如果是失败的，则当前函数中await下面的代码都不会执行</span><br><span class="line">        console.log(z);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        // 基于try catch异常捕获，可以捕获到await后面的promise实例是失败状态下的失败信息(浏览器控制台不会再报错了)</span><br><span class="line">        console.log(err); //30</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="await中的异步"><a href="#await中的异步" class="headerlink" title="await中的异步"></a>await中的异步</h3><blockquote><p>很多人认为async/await是同步操作，其实这种理解是正确的，await修饰的操作虽然是同步执行的，但是他在asnyc修饰的上下文中还会有一个特殊的操作，那就是将await下面的代码全部转成微任务，并添加到Event Queue中的微任务中。这么说可能有的小伙伴不是非常的理解，我们通过一道字节跳动的面试题来讲解</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&apos;async1 start&apos;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&apos;async1 end&apos;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0)</span><br><span class="line">async1();</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/c192cc20-055e-11eb-8ff1-d5dcf8779628.png"><blockquote><p>代码执行结果：’script start’ ‘async1 start’ ‘async2’ ‘promise1’ ‘script end’ ‘async1 end’ ‘promise2’ ‘setTimeout’</p></blockquote><h2 id="同步异步编程综合"><a href="#同步异步编程综合" class="headerlink" title="同步异步编程综合"></a>同步异步编程综合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function func1()&#123;</span><br><span class="line">    console.log(&apos;func1 start&apos;);</span><br><span class="line">    return new Promise(resolve=&gt;&#123;</span><br><span class="line">        resolve(&apos;OK&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function func2()&#123;</span><br><span class="line">    console.log(&apos;func2 start&apos;);</span><br><span class="line">    return new Promise(resolve=&gt;&#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            resolve(&apos;OK&apos;);</span><br><span class="line">        &#125;,10);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(1);</span><br><span class="line">setTimeout(async () =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    await func1();</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;, 20);</span><br><span class="line">for (let i = 0; i &lt; 90000000; i++) &#123;&#125; //循环大约要进行80MS左右</span><br><span class="line">console.log(4);</span><br><span class="line">func1().then(result=&gt;&#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;);</span><br><span class="line">func2().then(result=&gt;&#123;</span><br><span class="line">    console.log(6);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(7);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(8);</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/9fe82e20-0578-11eb-9dfb-6da8e309e0d8.png"><blockquote><p>代码的执行结果：1 4 ‘func1 start’ ‘func2 start’ 8 5 2 ‘func1 start’ 3 7 6</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式全解</title>
      <link href="/2020/09/27/2020-09-27-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A8%E8%A7%A3-md/"/>
      <url>/2020/09/27/2020-09-27-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A8%E8%A7%A3-md/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>RegExp(regular expression)：正则表达式是用来处理字符串的规则</p></blockquote><ul><li>只能处理字符串</li><li>规则：可以验证字符串是否符合某个规则(test)，也可以把字符串中符合规则的内容捕获到(exec、match)</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;good good study , day day up&quot;;</span><br><span class="line"></span><br><span class="line">// 指定规则:是否包含数字</span><br><span class="line">let reg = /\d+/;</span><br><span class="line">reg.test(str);  // false</span><br><span class="line"></span><br><span class="line">str = &quot;2019-08-12&quot;;</span><br><span class="line">reg.exec(str);  // [&quot;2019&quot;,index:0,input:&quot;原始字符串&quot;]</span><br></pre></td></tr></table></figure><h3 id="编写正则表达式"><a href="#编写正则表达式" class="headerlink" title="编写正则表达式"></a>编写正则表达式</h3><blockquote><p>字面量创建方式,两个斜杠之间包起来的，都是用来描述规则的元字符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let reg1 = /\d+/;</span><br></pre></td></tr></table></figure><blockquote><p>构造函数模式创建,两个参数：[元字符字符串]，[修饰符字符串]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let reg2 = new RegExp(&quot;\\d+&quot;);</span><br></pre></td></tr></table></figure><h3 id="正则表达式的两种组成部分"><a href="#正则表达式的两种组成部分" class="headerlink" title="正则表达式的两种组成部分"></a>正则表达式的两种组成部分</h3><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><blockquote><p>常见的元字符</p></blockquote><ol><li>量词元字符：设置出现的次数</li></ol><table><thead><tr><th align="left">元字符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">零到多次</td></tr><tr><td align="left">+</td><td align="left">零次或一次</td></tr><tr><td align="left">?</td><td align="left">零次或一次</td></tr><tr><td align="left">{n}</td><td align="left">出现n次</td></tr><tr><td align="left">{n,}</td><td align="left">出现n次到多次</td></tr><tr><td align="left">{n,m}</td><td align="left">出现n次到m次</td></tr></tbody></table><ol start="2"><li>特殊元字符：单个或者组合在一起代表的含义</li></ol><table><thead><tr><th align="left">元字符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义字符(普通-&gt;特殊-&gt;普通)</td></tr><tr><td align="left">.</td><td align="left">除\n(换行)以外的任意字符</td></tr><tr><td align="left">^</td><td align="left">规定以哪一个元字符作为开始</td></tr><tr><td align="left">$</td><td align="left">规定以哪一个元字符作为结束</td></tr><tr><td align="left">\n</td><td align="left">换行符</td></tr><tr><td align="left">\d</td><td align="left">0-9之间的数字</td></tr><tr><td align="left">\D</td><td align="left">非0-9之间的数字</td></tr><tr><td align="left">\w</td><td align="left">数字、字母、下划线中的任意字母</td></tr><tr><td align="left">\s</td><td align="left">一个空白字符(空格、制表符、换行符)</td></tr><tr><td align="left">\t</td><td align="left">一个制表符(Tab健)</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词的边界</td></tr><tr><td align="left">x</td><td align="left">y</td></tr><tr><td align="left">[xyz]</td><td align="left">x或者y或者z中的一个字符</td></tr><tr><td align="left">[^xy]</td><td align="left">除x或者y以外的任意字符</td></tr><tr><td align="left">[a-z]</td><td align="left">a-z范围之间的任意字符</td></tr><tr><td align="left">[^a-z]</td><td align="left">除了a-z范围之间的任意字符</td></tr><tr><td align="left">()</td><td align="left">正则中的分组符号</td></tr><tr><td align="left">(?:)</td><td align="left">只匹配不捕获</td></tr><tr><td align="left">(?=)</td><td align="left">正向预查</td></tr><tr><td align="left">(?!)</td><td align="left">负向预查</td></tr></tbody></table><ol start="3"><li>普通元字符：本身的含义</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/BSmall/  这个正则就是捕获BSmall</span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ul><li>i (ignoreCase) 忽略单词大小写匹配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/A/.test(&apos;BSmall&apos;);     // false</span><br><span class="line">/A/i.test(&apos;BSmall&apos;);    // true</span><br></pre></td></tr></table></figure><ul><li>m (multiline) 可以进行多行匹配</li><li>g (global) 全局匹配</li></ul><h3 id="元字符详细解析"><a href="#元字符详细解析" class="headerlink" title="元字符详细解析"></a>元字符详细解析</h3><blockquote><p>^ $</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let reg = /^\d/;</span><br><span class="line">reg.test(BSmall);       // false</span><br><span class="line">reg.test(2020BSmall);   // true</span><br><span class="line">reg.test(BSmall2020);   // false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let reg = /\d$/;</span><br><span class="line">reg.test(BSmall);       // false</span><br><span class="line">reg.test(2020BSmall);   // false</span><br><span class="line">reg.test(BSmall2020);   // true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let reg1 = /\d+/;    //字符串中包含符合规则的内容即可</span><br><span class="line">let reg2 = /^\d+$/;  //只能是以数字开头以数字结尾</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 最简单的验证手机号码的正则（以1开头，11位数字）</span><br><span class="line">let reg = /^1\d&#123;10&#125;$/;</span><br></pre></td></tr></table></figure><blockquote><p>\</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let reg = /^2.3$/   // 匹配2.3？？   点不是小数点，它代表除换行的任意字符</span><br><span class="line">reg.test(&quot;2.3&quot;);    // true</span><br><span class="line">reg.test(&quot;2i3&quot;);    // true</span><br><span class="line">reg.test(23);       // false</span><br><span class="line"></span><br><span class="line">reg = /^2\.3$/      // 基于转义字符，让 . 只代表小数点</span><br><span class="line">reg.test(&quot;2.3&quot;);    // true</span><br><span class="line">reg.test(&quot;2i3&quot;);    // false</span><br><span class="line">reg.test(23);       // false</span><br></pre></td></tr></table></figure><p>字符串中的 \ ，在字符串中两个\才代表是一个斜杠</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;BS\nmall&apos;);</span><br><span class="line">//=&gt; BS</span><br><span class="line">//   mall</span><br><span class="line"></span><br><span class="line">console.log(&apos;BS\\nmall&apos;);</span><br><span class="line">//=&gt; BS\nmall</span><br></pre></td></tr></table></figure><blockquote><p>x|y</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let reg = /^18|29$/     //直接使用 | 一般存在非常混乱的优先级，所以通常和()一起使用</span><br><span class="line">reg.test(&quot;18&quot;);      //true</span><br><span class="line">reg.test(&quot;29&quot;);      //true</span><br><span class="line">reg.test(&quot;129&quot;);     //true</span><br><span class="line">reg.test(&quot;189&quot;);     //true</span><br><span class="line">reg.test(&quot;1829&quot;);    //true</span><br><span class="line">reg.test(&quot;829&quot;);     //true</span><br><span class="line">reg.test(&quot;182&quot;);     //true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let reg = /^(18|29)$/   //使用()改变默认的优先级，只能是18或者29</span><br><span class="line">reg.test(&quot;18&quot;);      //true</span><br><span class="line">reg.test(&quot;29&quot;);      //true</span><br><span class="line">reg.test(&quot;129&quot;);     //false</span><br><span class="line">reg.test(&quot;189&quot;);     //false</span><br><span class="line">reg.test(&quot;1829&quot;);    //false</span><br><span class="line">reg.test(&quot;829&quot;);     //false</span><br><span class="line">reg.test(&quot;182&quot;);     //false</span><br></pre></td></tr></table></figure><blockquote><p>[]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 中括号中出现的字符一般都代表本身的含义</span><br><span class="line">let reg = /^[@+]$/;    //就是代表@或+</span><br><span class="line">reg.test(&quot;@&quot;);     //true</span><br><span class="line">reg.test(&quot;+&quot;);     //true</span><br><span class="line">reg.test(&quot;@+&quot;);    //false</span><br><span class="line"></span><br><span class="line">// 中括号中的\d还是0-9</span><br><span class="line">reg = /^[\d]$/; </span><br><span class="line">reg.test(&quot;\\&quot;);     //false</span><br><span class="line">reg.test(&quot;d&quot;);      //false</span><br><span class="line">reg.test(&quot;5&quot;);      //true</span><br><span class="line"></span><br><span class="line">// 中括号中不存在多位数</span><br><span class="line">reg = /^[18]$/; </span><br><span class="line">reg.test(&quot;1&quot;);      //true</span><br><span class="line">reg.test(&quot;8&quot;);      //true</span><br><span class="line">reg.test(&quot;18&quot;);     //false</span><br><span class="line"></span><br><span class="line">reg = /^[10-29]$/;  // 1 或者 0-9 或者 9</span><br><span class="line">reg = /^[(10-29)]$/;  // ( 或者 1 或者 0-9 或者 9 或者 )</span><br></pre></td></tr></table></figure><h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><ol><li>验证是否为有效数字</li></ol><blockquote><p>规则分析</p></blockquote><ul><li>可能出现 + - 号，也可能不出现 <code>[+-]?</code></li><li>一位数字 0-9 都可以，多位数首位不能为0  <code>(\d|([1-9]\d+))</code></li><li>小数部分可能有可能没有，小数点后面必须加数字 <code>(\.\d+)?</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;</span><br></pre></td></tr></table></figure><ol start="2"><li>验证密码</li></ol><blockquote><p>规则分析</p></blockquote><ul><li>数字字符下划线</li><li>6-16位</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let reg = /^\w&#123;6,16&#125;$/</span><br></pre></td></tr></table></figure><ol start="3"><li>验证真实姓名</li></ol><ul><li>汉字 <code>/^[\u4E00-u9FA5]$/</code></li><li>长度2-10位</li><li>可能译名中有 · </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let reg = /^[\u4E00-u9FA5]&#123;2,10&#125;(·([\u4E00-u9FA5]&#123;2,10&#125;)*$/</span><br></pre></td></tr></table></figure><ol start="4"><li>验证邮箱</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;</span><br></pre></td></tr></table></figure><blockquote><p>\w+((-\w+)|(\.\w+))*</p></blockquote><ul><li><code>w+</code> 以数字字母下划线开头（1到多位）</li><li><code>((-\w+)|(\\.\w+))*</code> 还可以是-后接一到多个数字下划线、.后接一到多个数字下划线，整体零到多次</li><li>邮箱的名字由“数字、字母、下划线、-、.”几部分组成，但是-或.不能连续出现、不能作为开头</li></ul><blockquote><p>@[A-Za-z0-9]+</p></blockquote><ul><li>@ 后面紧跟数字、字母 （1到多位）</li></ul><blockquote><p>((\.|-)[A-Za-z0-9]+)*</p></blockquote><ul><li>以 . 或 - 开头接一到多个数字、字母，整体0到多次</li><li>不是为了匹配末尾的 .com ,是用来匹配@和.com之间的 . 或 - </li></ul><blockquote><p>\.[A-Za-z0-9]+</p></blockquote><ul><li>匹配最后的 .com .cn .vip .org .edu .net 等域名</li></ul><ol start="5"><li>身份证号码</li></ol><blockquote><p>规则分析</p></blockquote><ul><li>一共18位</li><li>最后一位可能是X</li><li>身份证前六位：省市县</li><li>中间8位：年月日</li><li>最后四位：<ul><li>最后一位：x或者数字</li><li>倒数第二位：偶数-女，奇数-男</li><li>所在公安局编码</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 小括号分组的第二个作用：分组捕获，不仅可以把正则匹配匹配的信息捕获到，还可以单独捕获到每个小分组的内容</span><br><span class="line">let reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(\d|x)$/</span><br><span class="line">reg.exec(&quot;130828199012040617&quot;); //=&gt;[&quot;130828199012040617&quot;,&quot;130828&quot;,&quot;1990&quot;,&quot;12&quot;,&quot;04&quot;,&quot;1&quot;,&quot;7&quot;...]</span><br><span class="line">//捕获结果是一个数组，包含每一个小分组单独获取的内容</span><br></pre></td></tr></table></figure><h2 id="深入了解正则"><a href="#深入了解正则" class="headerlink" title="深入了解正则"></a>深入了解正则</h2><h3 id="正则两种创建方式的区别"><a href="#正则两种创建方式的区别" class="headerlink" title="正则两种创建方式的区别"></a>正则两种创建方式的区别</h3><blockquote><p>构造函数因为传入的是字符串，\需要写两个才代表一个斜杠</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let reg = /\d+/g;</span><br><span class="line">let reg2 = new RegExp(&quot;\\d+&quot;,&quot;g&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>正则表达式中的部分内容是变量存储的值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//两个斜杠之间的都是元字符, 如果正则中药包含摩尔个变量的值，则不能使用字面量方式创建</span><br><span class="line">let type = &quot;BSmall&quot;</span><br><span class="line">let reg = /^@&quot;+type+&quot;@$/;</span><br><span class="line">reg.test(&quot;@BSmall@&quot;);   //false</span><br><span class="line"></span><br><span class="line">let reg2 = new RegExp(&quot;^@&quot;+type+&quot;@$&quot;);</span><br><span class="line">reg2.test(&quot;@BSmall@&quot;);   //true</span><br></pre></td></tr></table></figure><h3 id="正则的捕获"><a href="#正则的捕获" class="headerlink" title="正则的捕获"></a>正则的捕获</h3><h4 id="实现正则捕获的方法"><a href="#实现正则捕获的方法" class="headerlink" title="实现正则捕获的方法"></a>实现正则捕获的方法</h4><ul><li>正则 RegExp.prototype<ul><li>exec</li><li>test</li></ul></li><li>字符串String.prototype上支持正则的方法<ul><li>replace</li><li>match</li><li>splite</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 需求：获取当前字符串中的数字</span><br><span class="line">let str = &quot;BSmall1213shidbdj2364yudbdf23&quot;</span><br><span class="line"></span><br><span class="line">let reg = /^\d+$/;</span><br><span class="line">reg.test(str);  //false</span><br><span class="line">reg.exec(str);  //null      //实现正则捕获的前提是：当前正则要和字符串匹配，如果不匹配捕获的结果是null</span><br><span class="line"></span><br><span class="line">reg = /\d+/;</span><br><span class="line">reg.exec(str);  //[&quot;1213&quot;,index:6,input:&quot;BSmall1213shidbdj2364yudbdf23&quot;]</span><br></pre></td></tr></table></figure><p>基于exec实现正则捕获</p><ul><li>捕获到的结果是null或一个数组<ul><li>第一项：本次捕获的内容</li><li>其余项：对应小分组单独捕获的内容</li><li>index：当前捕获结果在字符串中的起始索引</li><li>input：原始字符串</li></ul></li><li>每次执行exec只能捕获一个符合正则规则的，但是默认情况下，不管执行多少遍，都只能捕获第一个，其余的都捕获不到，这就是正则捕获的<code>“懒惰性”</code></li></ul><h4 id="正则的懒惰性原因和解决办法"><a href="#正则的懒惰性原因和解决办法" class="headerlink" title="正则的懒惰性原因和解决办法"></a>正则的懒惰性原因和解决办法</h4><blockquote><p>reg.lastIndex：当前正则下一次匹配的其实索引位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;BSmall1213shidbdj2364yudbdf23&quot;</span><br><span class="line">let reg = /\d+/;</span><br><span class="line">console.log(reg.lastIndex);     // 0  正则捕获从0开始</span><br><span class="line">console.log(reg.exec(str));     </span><br><span class="line">console.log(reg.lastIndex);     // 0  正则捕获完成之后，lastIndex值并没有修改，所以之后再执行exec方法还是从头开始查找</span><br></pre></td></tr></table></figure><blockquote><p>懒惰性的原因：默认情况下lastIndex的值不会被修改，每一次都是从字符串开始位置查找，所以找到的永远都是第一个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;BSmall1213shidbdj2364yudbdf23&quot;</span><br><span class="line">let reg = /\d+/;</span><br><span class="line">console.log(reg.exec(str))</span><br><span class="line">reg.lastIndex = 10;</span><br><span class="line">console.log(reg.lastIndex);     // 0 </span><br><span class="line">console.log(reg.exec(str));     // [&quot;1213&quot;,index:6,input:&quot;BSmall1213shidbdj2364yudbdf23&quot;] </span><br><span class="line">//还是第一个，说明手动修改值，是无效的</span><br></pre></td></tr></table></figure><blockquote><p>解决办法：g 全局修饰符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;BSmall1213shidbdj2364yudbdf23&quot;</span><br><span class="line">let reg = /\d+/g;</span><br><span class="line">console.log(reg.exec(str));     // [&quot;1213&quot;...]</span><br><span class="line">console.log(reg.lastIndex);     // 10</span><br><span class="line">console.log(reg.exec(str));     // [&quot;2364&quot;...]</span><br><span class="line">console.log(reg.lastIndex);     // 21</span><br><span class="line">console.log(reg.exec(str));     // [&quot;23&quot;...]</span><br><span class="line">console.log(reg.lastIndex);     // 29</span><br><span class="line">console.log(reg.exec(str));     // null 当捕获到最后一次，再次捕获的时候，捕获结果是null,同时初始化lastIndex的值</span><br><span class="line">console.log(reg.lastIndex);     // 0</span><br><span class="line">console.log(reg.exec(str));     // [&quot;1213&quot;...]</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let reg = /\d+/g;</span><br><span class="line">if(reg.test(str))&#123;</span><br><span class="line">    console.log(reg.lastIndex);     // 10 基于test验证时，已经将lastIndex值修改了，所以下次捕获不会从头开始</span><br><span class="line">    console.log(reg.exec(str)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需求：编写一个方法execAll，执行一次可以把所有的匹配结果都获取到（前提是正则有g修饰符）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    function execAll(str=&quot;&quot;)&#123;</span><br><span class="line">        //str:要匹配的字符串</span><br><span class="line">        //this:当前操作的正则实例</span><br><span class="line">        // 进来后验证正则中是否包含 g ,如果没有g会进入死循环</span><br><span class="line">        if(!this.global) return this.exec(str);</span><br><span class="line">        </span><br><span class="line">        let ary = [],</span><br><span class="line">            res = this.exec(str);</span><br><span class="line">        while(res)&#123;     //只要捕获的结果是null,就不继续捕获</span><br><span class="line">            ary.push(res[0]);       //将捕获到的数组的第一项添加到ary中</span><br><span class="line">            res = this.exec(str);</span><br><span class="line">        &#125;</span><br><span class="line">        return ary.lenght === 0 ? null: ary ;</span><br><span class="line">    &#125;</span><br><span class="line">    RegExp.prototype.execAll = execAll;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><blockquote><p>正则中没有捕获到所有结果的方法，但是字符串的match方法中可以实现，而且上面的需求就是match的源码，只是在不同原型上</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.match(reg)</span><br></pre></td></tr></table></figure><h4 id="分组捕获"><a href="#分组捕获" class="headerlink" title="分组捕获"></a>分组捕获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;130828199012040112&quot;;</span><br><span class="line">let reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(?:\d|x)$/;</span><br><span class="line">reg.exec(str);      //[&quot;130828199012040112&quot;,&quot;130828&quot;,&quot;1990&quot;,&quot;12&quot;,&quot;04&quot;,&quot;1&quot;,index:0,input:&quot;130828199012040112&quot;]</span><br><span class="line">str.match(reg);     //[&quot;130828199012040112&quot;,&quot;130828&quot;,&quot;1990&quot;,&quot;12&quot;,&quot;04&quot;,&quot;1&quot;,index:0,input:&quot;130828199012040112&quot;]</span><br></pre></td></tr></table></figure><ul><li>第一项：大正则匹配的结果</li><li>其余项：每个小分组匹配捕获的结果</li><li>可以基于(?: )来实现只改变优先级，不捕获</li></ul><blockquote><p>需求：下面的字符串既要捕获{2020}又要捕获2020</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;&#123;2020&#125;年&#123;09&#125;月&#123;30&#125;日&quot;;</span><br><span class="line"></span><br><span class="line">let reg = /\&#123;(\d+)\&#125;/;</span><br><span class="line">// 在不设置 g 的情况下，exec和match的匹配结果是一样的（既有正则匹配的结果，又有分组匹配的结果）</span><br><span class="line">reg.exec(str);</span><br><span class="line">str.match(reg);</span><br><span class="line"></span><br><span class="line">reg = /\&#123;(\d+)\&#125;/g;</span><br><span class="line">str.match(reg);     //[&quot;&#123;2020&#125;&quot;,&quot;&#123;09&#125;&quot;,&quot;&#123;30&#125;&quot;] 在设置了 g 的情况下，使用match匹配只能拿到正则匹配的结果</span><br><span class="line"></span><br><span class="line">let aryBig = [],</span><br><span class="line">    arySmall = [],</span><br><span class="line">    res1 = res.exec(str);</span><br><span class="line">while(res1)&#123;</span><br><span class="line">    let [big,small] = res1;</span><br><span class="line">    aryBig.push(big);</span><br><span class="line">    arySmall.push(small);</span><br><span class="line">    res1 = reg.exec(str);</span><br><span class="line">&#125;</span><br><span class="line">consolr.log(aryBig,arySmall);   //分开获取想要的值</span><br></pre></td></tr></table></figure><h4 id="分组引用"><a href="#分组引用" class="headerlink" title="分组引用"></a>分组引用</h4><blockquote><p>分组引用就是通过”\数字”让其代表和对应分组出现一模一样的内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;book&quot;;       //&quot;good&quot; &quot;look&quot; &quot;moon&quot; &quot;foot&quot;</span><br><span class="line">let reg = /^[a-zA-Z]([a-zA-Z])\1[a-zA-Z]$/</span><br><span class="line">reg.test(str);      //true</span><br><span class="line">reg.test(hear);     //false</span><br></pre></td></tr></table></figure><h4 id="正则捕获的贪婪性"><a href="#正则捕获的贪婪性" class="headerlink" title="正则捕获的贪婪性"></a>正则捕获的贪婪性</h4><blockquote><p>正则捕获的贪婪性：默认情况下，正则捕获是按照当前正则所能捕获的最长结果。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;BS2020-0930mall&quot;</span><br><span class="line">let reg = /\d+/g;</span><br><span class="line">str.match(reg);     //[&quot;2020&quot;,&quot;0930&quot;] 贪婪性体现在 2或者0或者9或者3都是符合\d+的，但是正则是直接返回最长的结果</span><br><span class="line"></span><br><span class="line">// 在量词元字符后面设置 ?  取消捕获的时候的贪婪性(按照正则匹配的最短结果来获取)</span><br><span class="line">reg = /\d+?/g;</span><br><span class="line">str.match(reg);     //[&quot;2&quot;,&quot;0&quot;,&quot;2&quot;,&quot;0&quot;,&quot;0&quot;,&quot;9&quot;,&quot;3&quot;,&quot;0&quot;]</span><br></pre></td></tr></table></figure><h4 id="号在正则中的五种含义"><a href="#号在正则中的五种含义" class="headerlink" title="? 号在正则中的五种含义"></a>? 号在正则中的五种含义</h4><ul><li>问号左边是非量词元字符：代表量词元字符，出现0-1次</li><li>问号左边是量词元字符：取消正则捕获时的贪婪性</li><li>(?: ) 只匹配不捕获</li><li>(?= ) 正向预查</li><li>(?! ) 负向预查</li></ul><h4 id="正则的其他捕获方法"><a href="#正则的其他捕获方法" class="headerlink" title="正则的其他捕获方法"></a>正则的其他捕获方法</h4><ol><li>test(本意是匹配)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;&#123;2020&#125;年&#123;09&#125;月&#123;30&#125;日&quot;;</span><br><span class="line">let reg =  /\&#123;(\d+)\&#125;/g;</span><br><span class="line">reg.test(str);              //true</span><br><span class="line">console.log(RegExp.$1);     //=&gt; &apos;2020&apos;</span><br><span class="line">reg.test(str);              //true</span><br><span class="line">console.log(RegExp.$1);     //=&gt; &apos;09&apos;</span><br><span class="line">reg.test(str);              //true</span><br><span class="line">console.log(RegExp.$1);     //=&gt; &apos;30&apos;</span><br><span class="line">reg.test(str);              //false</span><br><span class="line">console.log(RegExp.$1);     //=&gt; &apos;30&apos;  上一次捕获的结果</span><br></pre></td></tr></table></figure><blockquote><p>RegExp.$1~$9 获取当前正则匹配到的第一到九的分组信息,放在类上，操作其他实例的时候会被覆盖 </p></blockquote><ol start="2"><li>replace 字符串中实现替换的方法（一般都是伴随着正则一起使用）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不使用正则</span><br><span class="line">let str =&quot;BSmall2020-BSmall2020&quot;;</span><br><span class="line">str = str.replace(&quot;BSmall&quot;,&quot;Hello&quot;);    //Hello2020-BSmall2020</span><br><span class="line">str = str.replace(&quot;BSmall&quot;,&quot;Hello&quot;);    //Hello2020-Hello2020  每次执行之后替换一个</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//使用正则</span><br><span class="line">let str =&quot;BSmall2020-BSmall2020&quot;;</span><br><span class="line">str = str.replace(/BSmall/g,&quot;Hello&quot;);    //Hello2020-Hello2020</span><br></pre></td></tr></table></figure><blockquote><p>需求：BSmallhaha2020-BSmallhaha2020</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str =&quot;BSmall2020-BSmall2020&quot;;</span><br><span class="line">str = str.replace(&quot;BSmall&quot;,&quot;Hello&quot;);    //BSmallhaha2020-BSmall2020</span><br><span class="line">str = str.replace(&quot;BSmall&quot;,&quot;Hello&quot;);    //BSmallhahahaha2020-BSmall2020 </span><br><span class="line">//基于replace在这种情况下，和正则的懒惰性一样，会从第一个开始找，这就导致了上述问题</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//使用正则就可以使用</span><br><span class="line">let str =&quot;BSmall2020-BSmall2020&quot;;</span><br><span class="line">str = str.replace(/BSmall/g,&quot;BSmallhaha&quot;);    //BSmallhaha2020-BSmallhaha2020</span><br></pre></td></tr></table></figure><p>案例：处理一个时间字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let time = &quot;2020-09-30&quot;;       //=&gt;变成 2020年09月30日</span><br><span class="line">let reg = /^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)$/;</span><br><span class="line">time = time.replace(reg,&quot;$1年$2月$3日&quot;)；</span><br><span class="line">console.log(time);      //2020年09月30日</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 上述代码的实现原理：</span><br><span class="line"> * replace([str],[function])</span><br><span class="line"> * </span><br><span class="line"> * replace(reg,(...arg)=&gt;&#123;</span><br><span class="line"> *     let [,$1,$2,$3] = arg;</span><br><span class="line"> *     return $1+&quot;年&quot;+$2+&quot;月&quot;+$3+&quot;日&quot;;</span><br><span class="line"> * &#125;)</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>首先拿reg和time进行匹配，能匹配到几次就会把传递的函数执行几次（而且是匹配一次就执行一次）</li><li>不仅把方法执行，而且replace还给方法传递了实参信息（和exec捕获的内容一致的信息：正则捕获的内容和分组捕获的内容）</li><li>函数的返回值，会替换当前的匹配项</li></ul><blockquote><p>单词首字母大写</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;good good study,day day up!&quot;</span><br><span class="line">let reg = /\b([a-zA-Z])[a-zA-Z]*\b/g</span><br><span class="line"></span><br><span class="line">// 函数被执行了六次，每次都把正则匹配信息传递给函数</span><br><span class="line">str = str.replace(reg,(...arg)=&gt;&#123;</span><br><span class="line">    let [content,$1] = arg;</span><br><span class="line">    $1 = $1.toUpperCase();</span><br><span class="line">    content = content.substring(1)</span><br><span class="line">    return $1+content;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>获取出现次数最多的字母，及出现次数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;zhdjfbvzvdbvfnbdhhinbf&quot;,</span><br><span class="line">    max = 0,</span><br><span class="line">    res = [],</span><br><span class="line">    flag = false;</span><br><span class="line">str = str.split(&quot;&quot;).sort((a,b)=&gt;a.localeCompare(b)).join(&quot;&quot;);</span><br><span class="line">for(let i = str.length ; i &gt;0 ; i--)&#123;</span><br><span class="line">    let reg = new RegExp(&quot;[a-zA-Z]\\1&#123;&quot;+(i+1)+&quot;&#125;&quot;,&quot;g&quot;);</span><br><span class="line">    str.replace(reg,(content,$1)=&gt;&#123;</span><br><span class="line">        res.push($1);</span><br><span class="line">        max = i;</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;);</span><br><span class="line">    if(flag) break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向String原型上拓展方法"><a href="#向String原型上拓展方法" class="headerlink" title="向String原型上拓展方法"></a>向String原型上拓展方法</h3><blockquote><p>时间字符串格式化</p></blockquote><blockquote><p>获取URL地址问号信息及参数信息</p></blockquote><blockquote><p>千分符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">let time = &quot;2019-8-13 16:51:3&quot;;     //服务器返回的时间还有可能是 2019/8/13 16:51:3</span><br><span class="line">let url = &quot;http://www.BSmall.com/?name=ls&amp;from=zfb#video&quot;;</span><br><span class="line">let num = 265532655568656;</span><br><span class="line"></span><br><span class="line">(function&#123;</span><br><span class="line">    /*</span><br><span class="line">     *  formatTime:时间字符串格式化处理</span><br><span class="line">     *  @parmas</span><br><span class="line">     *      template:[string] 期望的日期格式模板</span><br><span class="line">     *      模板规则：&#123;0&#125;-&#123;5&#125; 分别代表 年月日 时分秒</span><br><span class="line">     *  @return</span><br><span class="line">     *      [string] 格式化后的时间字符串</span><br><span class="line">     */</span><br><span class="line">    function formatTime(template= &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;)&#123;</span><br><span class="line">        //获取时间字符串上的年月日及时分秒</span><br><span class="line">        let timeAry = this.match(/\d+/g);</span><br><span class="line">        return template = template.replace(/\&#123;(\d+)\&#125;/,(...[,$1])=&gt;&#123;</span><br><span class="line">            let time = time[$1] || &quot;00&quot;;</span><br><span class="line">            return time.lenght &lt; 2? &quot;0&quot;+time : time;;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     *  queryURLParmas:获取URL地址问号信息及参数信息</span><br><span class="line">     *  @parmas</span><br><span class="line">     *  @return</span><br><span class="line">     *      [object] 把所有问号信息以键值对的方式存储起来并返回</span><br><span class="line">     */</span><br><span class="line">    function queryURLParmas()&#123;</span><br><span class="line">        let obj = &#123;&#125;;</span><br><span class="line">        this.replace( /([^?=&amp;#]+)=([^?=&amp;#]+)/g,(...[,$1,$2])=&gt;obj[$1] = $2);</span><br><span class="line">        this.replace(/#([^?=&amp;#]+)/g,(...[,$1])=&gt; obj[&quot;HASH&quot;] = $1);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     *  millimeter:实现大数字的千分符处理</span><br><span class="line">     *  @parmas</span><br><span class="line">     *  @return</span><br><span class="line">     *      [string] 千分符后的字符串</span><br><span class="line">     */</span><br><span class="line">    function millimeter()&#123;</span><br><span class="line">        return this.replace(/\d&#123;1,3&#125;(?=\d&#123;3&#125;)+$/g,content=&gt;content+&apos;,&apos;);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* 拓展方法到内置类 String.prototype 上 */</span><br><span class="line">    [&quot;formatTime&quot;,&quot;queryURLParmas&quot;，&quot;millimeter&quot;].forEach(item=&gt;&#123;</span><br><span class="line">        String.prototype[item] = eval(item)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">time.formatTime();</span><br><span class="line">url.queryURLParmas();</span><br><span class="line">num.millimeter();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack--优化篇</title>
      <link href="/2020/09/26/2020-09-26-webpack-%E4%BC%98%E5%8C%96%E7%AF%87-md/"/>
      <url>/2020/09/26/2020-09-26-webpack-%E4%BC%98%E5%8C%96%E7%AF%87-md/</url>
      
        <content type="html"><![CDATA[<h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install eslint eslint-loader -D</span><br><span class="line">$ npx eslint --init  //初始化配置文件</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;development&apos;,</span><br><span class="line">    entry:&apos;./src/main.js&apos;,</span><br><span class="line">    //多入口 key:value</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;[name].[hash].min.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname,&apos;build&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.js$/,</span><br><span class="line">                use:&quot;eslint-loader&quot;,</span><br><span class="line">                enforce:&apos;pre&apos;   //优先加载</span><br><span class="line">            &#125;</span><br><span class="line">            //...</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>eslintrc.json 文件用来配置校验规则，直接到官网勾选要求的校验规则，下载过来使用即可</p></blockquote><blockquote><p>eslintrc.js文件是我们init 初始化的配置文件，也可以使用json格式的文件</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/737c89a0-01fc-11eb-9dfb-6da8e309e0d8.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    env:&#123;</span><br><span class="line">        browser:true,</span><br><span class="line">        es2021:true</span><br><span class="line">    &#125;,</span><br><span class="line">    extends:[</span><br><span class="line">        &apos;airbnb-base&apos;</span><br><span class="line">    ],</span><br><span class="line">    parserOptions:&#123;</span><br><span class="line">        ecmaVersion:12,</span><br><span class="line">        sourceType:&apos;module&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    rules:&#123;</span><br><span class="line">        &quot;no-console&quot;:2,</span><br><span class="line">        &quot;no-debugger&quot;:2     //将需要的规则设置成2就会生效</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去除无用的CSS"><a href="#去除无用的CSS" class="headerlink" title="去除无用的CSS"></a>去除无用的CSS</h2><blockquote><p><code>purgecss-webpack-plugin</code> ：去除无用的css</p></blockquote><blockquote><p><code>glob</code> 设置查找文件的路径和匹配的文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install purgecss-webpack-plugin glob</span><br></pre></td></tr></table></figure><h2 id="CDN加载文件"><a href="#CDN加载文件" class="headerlink" title="CDN加载文件"></a>CDN加载文件</h2><blockquote><p>假设我在我的项目上引入了CDN下的jquery，但是我又 inport $ from ‘jquery’,就会报错。同时为了防止jquery被打包到我们最终的文件中，这种情况下直接在配置文件中添加<code>externals</code>配置项高速webpack它是外部的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    externals:&#123; &quot;jquery&quot;:&quot;$&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tree-shaking-amp-scope-hosting"><a href="#Tree-shaking-amp-scope-hosting" class="headerlink" title="Tree-shaking &amp; scope-hosting"></a>Tree-shaking &amp; scope-hosting</h2><blockquote><p><code>Tree-shaking</code>将没用的内容晃掉，通常用在生产环境下。需要在package.json文件中配置<code>sideEffects:false</code>字段</p></blockquote><p>注意：入口文件导入的css可能会被晃掉,所以需要把css文件排除掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;sideEffects&quot;:[</span><br><span class="line">    &quot;**/*.css&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>开发环境下，Tree-shaking是不会生效的但是他会生成提醒注释,需要在package.json文件中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;      //开发环境下配置标识</span><br><span class="line">    usedExports:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>scope-hosting</code> 作用域提升，减少一些没有必要的函数，减少内存。它是webpack在生产环境下自动帮你做的事情，不需要手动配置</p></blockquote><h2 id="配置代理proxy"><a href="#配置代理proxy" class="headerlink" title="配置代理proxy"></a>配置代理proxy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在devServer中配置</span><br><span class="line">proxy:&#123;</span><br><span class="line">    &quot;/api&quot;:&#123;</span><br><span class="line">        target:&quot;http://localhost:9999&quot;,     //请求服务的地址</span><br><span class="line">        secure:false,       //true表示https，false表示http</span><br><span class="line">        changeOrigin:true,  //把请求头中的host地址改成服务器地址</span><br><span class="line">        pathRewrite:&#123;&quot;/api&quot;:&quot;&quot;&#125;     //重写请求头接口地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="devSever的中间件"><a href="#devSever的中间件" class="headerlink" title="devSever的中间件"></a>devSever的中间件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        port:3000,</span><br><span class="line">        compress:true,</span><br><span class="line">        progress:true,</span><br><span class="line">        contentBase:path.resolve(__dirname,&quot;dist&quot;),</span><br><span class="line">        open:false,</span><br><span class="line">        hot:true,</span><br><span class="line">        before:function(app,server)&#123;    //借助于devServer的中间件，以同域的方式来模拟数据</span><br><span class="line">            app.get(&quot;/api/user&quot;,function(req,res)=&gt;&#123;</span><br><span class="line">                //...</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DLLPlugin-amp-DLLReferencePlugin-设置动态链接库"><a href="#DLLPlugin-amp-DLLReferencePlugin-设置动态链接库" class="headerlink" title="DLLPlugin &amp; DLLReferencePlugin 设置动态链接库"></a>DLLPlugin &amp; DLLReferencePlugin 设置动态链接库</h2><blockquote><p><code>DLLPlugin</code>设置动态链接库，<code>DLLReferencePlugin</code>引入动态链接库,开发环境下提升构建速度</p></blockquote><p>第三方库或者框架单独打包成动态链接库（保存），每次再次打包整个项目的时候，不需要在打包第三方库或者框架，只需要引入即可</p><blockquote><p>新建一个配置文件，webpack.dll.js,并在package.json文件script中配置命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dll&quot;:&quot;webpack --config webpack.dll.js&quot;</span><br></pre></td></tr></table></figure><blockquote><p><code>webpack.dll.js</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&quot;development&quot;,</span><br><span class="line">    entry:[&quot;react&quot;,&quot;react-dom&quot;],</span><br><span class="line">    output:&#123;</span><br><span class="line">        library:&quot;react&quot;,     //用来接收打包后自执行函数返回值</span><br><span class="line">        libraryTarget:&quot;commonjs2&quot;,      //用哪种方式来接收自治性函数的返回值 commonjs commonjs2 this var umd  默认是通过var的方式</span><br><span class="line">        path:path.resolve(__dirname,&quot;dll&quot;),</span><br><span class="line">        filename:&quot;react-dll.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugin:[</span><br><span class="line">        new DLLPlugin(&#123;</span><br><span class="line">            name:&quot;react&quot;,</span><br><span class="line">            path: path.resolve(__dirname,&quot;dll/mainfest.json&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>add-asset-html-webpack-plugin</code> 把js文件添加到html中，在公用文件中配置就好</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const AddAssetHtmlPlugin = require(&quot;add-asset-html-webpack-plugin&quot;)</span><br><span class="line">const DLLReferencePlugin = require(&quot;webpack&quot;).DLLReferencePlugin;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugin:[</span><br><span class="line">        new DLLReferencePlugin(&#123;</span><br><span class="line">            mainfest: path.resolve(__dirname,&quot;dll/mainfest.json&quot;)</span><br><span class="line">        &#125;),</span><br><span class="line">        new AddAssetHtmlPlugin(&#123;</span><br><span class="line">            filepath: path.resolve(__dirname,&quot;dll/react.dll.js&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">        //...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//同步加载</span><br><span class="line">//import sum from &quot;./sum&quot;;</span><br><span class="line"></span><br><span class="line">//动态加载 异步</span><br><span class="line">btn.addEventListener(&quot;click&quot;,()=&gt;&#123;</span><br><span class="line">    import(/*webpackChunkName:&apos;sum&apos;*/,&quot;./sum&quot;)     //返回一个promise实例</span><br><span class="line">    .then(data=&gt;&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>webpackChunkName</code> 动态加载文件的名称<br><code>webpackPrefetch</code> 预加载，利用浏览器空闲时间，把动态模块加载完成并引入<br><code>webpackPreload</code> 预拉取，跟主模块同时加载，并行的下载文件，vue使用的是这个</p><blockquote><p>output中的chunkFilename也可以设置动态加载文件的名称</p></blockquote><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p><code>hot:true</code> 在devServer中添加该字段即可</p><p>js开启热更新，可以使用module.hot.accept强制文件支持热更新</p><h2 id="sourceMap-代码排查工具"><a href="#sourceMap-代码排查工具" class="headerlink" title="sourceMap(代码排查工具)"></a>sourceMap(代码排查工具)</h2><blockquote><p>开发环境下 cheap-module-eval-source-map</p></blockquote><blockquote><p>生产环境下 cheap-module-source-map</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    devtool:&quot;cheap-module-eval-source-map&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包文件分析工具-webpack-bundle-analyzer"><a href="#打包文件分析工具-webpack-bundle-analyzer" class="headerlink" title="打包文件分析工具 webpack-bundle-analyzer"></a>打包文件分析工具 webpack-bundle-analyzer</h2><blockquote><p>打包文件分析工具只能在开发环境下使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; BundleAnalyzerPlugin &#125; = reqiure(&quot;webpack-bundle-analyzer&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugin:[</span><br><span class="line">        new BundleAnalyzerPlugin();</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="splitChunks（生产环境，第三方模块打包）"><a href="#splitChunks（生产环境，第三方模块打包）" class="headerlink" title="splitChunks（生产环境，第三方模块打包）"></a>splitChunks（生产环境，第三方模块打包）</h2><blockquote><p>在编译的时候抽离第三方模块（不要和DLLPlugin同时使用）</p></blockquote><blockquote><p>webpack.config.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &apos;async&apos;,  //all同步加异步  async异步</span><br><span class="line">      minSize: 20000,   //分割文件的最小大小</span><br><span class="line">      minRemainingSize: 0,</span><br><span class="line">      maxSize: 0,</span><br><span class="line">      minChunks: 1,     //引用次数</span><br><span class="line">      maxAsyncRequests: 30,     //最大的异步请求</span><br><span class="line">      maxInitialRequests: 30,   //最大的初始化请求</span><br><span class="line">      automaticNameDelimiter: &apos;~&apos;,      //抽离模块命名的分隔符</span><br><span class="line">      enforceSizeThreshold: 50000,      </span><br><span class="line">      cacheGroups: &#123;            </span><br><span class="line">        defaultVendors: &#123;</span><br><span class="line">          test: /[\\/]node_modules[\\/]/,</span><br><span class="line">          priority: -10     //值大的 先抽离</span><br><span class="line">        &#125;,</span><br><span class="line">        default: &#123;</span><br><span class="line">          minChunks: 2,</span><br><span class="line">          priority: -20,</span><br><span class="line">          reuseExistingChunk: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>编写多个optimization会导致覆盖</p></blockquote><blockquote><p>使用 splitChunks 抽离模块的时候把externals去掉</p></blockquote><h2 id="费时分析"><a href="#费时分析" class="headerlink" title="费时分析"></a>费时分析</h2><blockquote><p>speed-measure-webpack-plugin</p></blockquote><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><blockquote><p>extensions：指定之后，可以不在require或import后加文件后缀名，会按照你写的顺序依次匹配查找</p></blockquote><blockquote><p>alias：设置别名，加快模块查找顺序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        extensions:[&quot;.js&quot;,&quot;.jsx&quot;,&quot;json&quot;,&quot;css&quot;],</span><br><span class="line">        alias:&#123;</span><br><span class="line">            &quot;@&quot;:path.resolve(__dirname,&quot;src&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">    noParse:/jquery/,   //设置哪些模块不需要解析</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h2><blockquote><p>用于忽略某些模块，让webpack不打包进去</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new webpack.IgnorePlugin(/^\.\/local/,/moment$/)</span><br></pre></td></tr></table></figure><h2 id="多线程打包"><a href="#多线程打包" class="headerlink" title="多线程打包"></a>多线程打包</h2><blockquote><p>happypack</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">    plugin:[</span><br><span class="line">        new HappyPack(&#123;</span><br><span class="line">            id:&apos;style&apos;,</span><br><span class="line">            threads:2,      //开启2个线程</span><br><span class="line">            loader:[&apos;style-loader&apos;,&apos;css-loader&apos;,&quot;less-loader&quot;]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>thread-loader</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack--核心篇</title>
      <link href="/2020/09/25/2020-09-25-webpack-%E6%A0%B8%E5%BF%83%E7%AF%87-md/"/>
      <url>/2020/09/25/2020-09-25-webpack-%E6%A0%B8%E5%BF%83%E7%AF%87-md/</url>
      
        <content type="html"><![CDATA[<h2 id="多入口的打包配置"><a href="#多入口的打包配置" class="headerlink" title="多入口的打包配置"></a>多入口的打包配置</h2><blockquote><p>单页面、单入口通常是单页面应用开发，但是我们常常会存在多个页面模板和多个入口文件的情况，所以我们需要掌握基于webpack来指定多入口的处理</p></blockquote><p>假定以下是我们的文件结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* |- public</span><br><span class="line"> *     |- index.html</span><br><span class="line"> *     |- login.html</span><br><span class="line"> * |- src</span><br><span class="line"> *     |- login.js</span><br><span class="line"> *     |- index.html</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>webpack.config.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123;CleanWebpackPlugin&#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">//配置多页面模板</span><br><span class="line">const htmlPlugin = [&apos;index&apos;,&apos;login&apos;].map(item=&gt;&#123;</span><br><span class="line">    return new Html-webpack-plugin(&#123;</span><br><span class="line">            template:`./public./$&#123;item&#125;.html`，</span><br><span class="line">            filename:`$&#123;item&#125;.html`，</span><br><span class="line">            //多入口的配置文件，用于在HTML导入对应js文件</span><br><span class="line">            //chunks:[&apos;jquery&apos;,item],  //指定当前页面的依赖项 依赖优先级从左到右</span><br><span class="line">            chunks:[item], </span><br><span class="line">            minify:&#123;</span><br><span class="line">                collapseWhitespace: true, </span><br><span class="line">                removeComments: true,   </span><br><span class="line">                removeAttributeQuotes:true, </span><br><span class="line">                removeEmptyAttributes:true  </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;development&apos;,</span><br><span class="line">    // entry:&apos;./src/main.js&apos;,</span><br><span class="line">    //多入口 key:value</span><br><span class="line">    entry:&#123;</span><br><span class="line">        index: &apos;./src/main.js&apos;，</span><br><span class="line">        login: &apos;./src/login.js&apos;，</span><br><span class="line">        jquery: &apos;jquery&apos;    //公共依赖项</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        //[name]多入口配置的属性名 index/login</span><br><span class="line">        filename:&apos;[name].[hash].min.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname,&apos;build&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">     plugin:[</span><br><span class="line">        //直接将模板展开在plugin中</span><br><span class="line">        ...htmlPlugin,</span><br><span class="line">        new CleanWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack的加载器loader"><a href="#webpack的加载器loader" class="headerlink" title="webpack的加载器loader"></a>webpack的加载器loader</h2><h3 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h3><blockquote><p>真实项目中，入口js文件会引入项目所需的大部分资源文件，如样式资源、JS资源、各种模块…,好处是写在入口文件的资源会按照依赖关系进行合并打包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./static/css/reset.min.css&apos;;</span><br><span class="line">require(&apos;./static/css/index.less&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install style-loader css-loader less less-loader autoprefixer postcss-loader --save-dev</span><br></pre></td></tr></table></figure><ul><li><code>css-loader</code></li><li><code>less-loader</code></li><li><code>autoprefixer</code></li><li><code>postcss-loader</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    //配置加载器loader</span><br><span class="line">    module:&#123;</span><br><span class="line">        // 设置规则和处理方案（默认执行顺序：从右到左、从下向上）</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:/\.(css|less)$/i,  //匹配规则，匹配.css或.less结尾的文件</span><br><span class="line">            use:[</span><br><span class="line">                &quot;style-loader&quot;,     //将处理好的css文件插入到页面中</span><br><span class="line">                &quot;css-loader&quot;,       //处理@import/URL这种语法</span><br><span class="line">                &quot;postcss-loader&quot;,   //设置css前缀（处理兼容 需要搭配autoprefixer一起使用 需要额外的配置文件来配置信息）</span><br><span class="line">                &quot;less-loader&quot;       //将less编译成css</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>postcss-loader 和 autoprefixer 搭配使用需要在项目的根目录下创建一个<code>post.config.js</code>的配置文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    plugin:[</span><br><span class="line">        require(&quot;autoprefixer&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在package.json文件中添加以下代码，设置兼容浏览器的范围,具体规则可以到<a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">https://github.com/browserslist/browserslist</a>中查看</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;:[</span><br><span class="line">    &quot;&gt; 0.1%&quot;,</span><br><span class="line">    &quot;last 10 version&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>以上方式虽然实现了文件的编译，但是css样式是采用的内链式的方式插入的，而不是我们常用的外链式插入，这样会使得HTML模板文件的体积增大，那么如何使他以外链的形式插入呢？这就需要下面介绍的插件来处理。</p></blockquote><h3 id="mini-css-extract-plugin抽离样式内容"><a href="#mini-css-extract-plugin抽离样式内容" class="headerlink" title="mini-css-extract-plugin抽离样式内容"></a>mini-css-extract-plugin抽离样式内容</h3><blockquote><p>将解析完后的css文件抽离出来，单独生成一个指定文件，并以外链的形式插入模板文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mini-css-extract-plugin --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugin:[</span><br><span class="line">        //...</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            //设置编译后的文件名字</span><br><span class="line">            filename:&apos;[name].[hash].css&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:/\.(css|less)$/i,  //匹配规则，匹配.css或.less结尾的文件</span><br><span class="line">            use:[</span><br><span class="line">                &quot;style-loader&quot;,     //将处理好的css文件插入到页面中</span><br><span class="line">                &quot;css-loader&quot;,       //处理@import/URL这种语法</span><br><span class="line">                &quot;postcss-loader&quot;,   //设置css前缀（处理兼容 需要搭配autoprefixer一起使用 需要额外的配置文件来配置信息）</span><br><span class="line">                &quot;less-loader&quot;       //将less编译成css</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置优化项压缩css-js"><a href="#设置优化项压缩css-js" class="headerlink" title="设置优化项压缩css/js"></a>设置优化项压缩css/js</h3><blockquote><p>通过以上的配置，我们虽然生成了外链css但是css文件并没有帮我们压缩，那么我们怎么实现css压缩呢。</p></blockquote><h4 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h4><blockquote><p>实现css压缩的时候会发现js默认不压缩了，所以我们这里需要使用插件将js同时压缩了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install optimize-css-assets-webpack-plugin terser-webpack-plugin ugLifyjs-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const UgLifyjsWebpackPlugin = require(&apos;ugLifyjs-webpack-plugin&apos;);</span><br><span class="line">const TerserPlugin = require(&apos;terser-webpack-plugin&apos;);      //以上两种都是用来压缩JS文件的，现在下面这种用的多一点</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);   //css压缩插件</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    //设置优化项</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        //设置压缩方式</span><br><span class="line">        minimizer:&#123;</span><br><span class="line">            //压缩css（必须指定JS的压缩方式）</span><br><span class="line">            new OptimizeCssAssetsWebpackPlugin(),</span><br><span class="line">            //压缩js</span><br><span class="line">             new TerserPlugin()</span><br><span class="line">            // new UgLifyjsWebpackPlugin(&#123;</span><br><span class="line">            //    cache:true,         //是否使用缓存</span><br><span class="line">            //    parallel:true,      //是否并发编译</span><br><span class="line">            //    sourceMap:true      //启动源码映射</span><br><span class="line">            // &#125;)</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webpack中图片的处理"><a href="#webpack中图片的处理" class="headerlink" title="webpack中图片的处理"></a>webpack中图片的处理</h3><blockquote><p>图片在项目中出现的情景：css中设置背景图、js中动态创建图片、HTML中的img直接导入图片</p></blockquote><ul><li><code>file-loader</code></li><li><code>url-loader</code></li><li><code>html-withimg-loader</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install file-loader url-loader html-withimg-loader --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line"></span><br><span class="line">module.exoprts = &#123;</span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">     module:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            //处理css</span><br><span class="line">            test:/\.(css|less)$/i,</span><br><span class="line">            use:[</span><br><span class="line">                &quot;style-loader&quot;,</span><br><span class="line">                &quot;css-loader&quot;, </span><br><span class="line">                &quot;postcss-loader&quot;, </span><br><span class="line">                &quot;less-loader&quot; </span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            //处理图片</span><br><span class="line">            test:/\.(png|jpe?g|gif)$/i,</span><br><span class="line">            use:[</span><br><span class="line">               loader: &quot;url-loader&quot;</span><br><span class="line">               options:&#123;</span><br><span class="line">                   limit: 200*1024,     //指定指定大小内的图片base64 不在指定范围中的采用file-loader处理</span><br><span class="line">                   name: &apos;image/[name].[hash].[ext]&apos;    //添加 image/ 编译时，将所有的图片统一放在/image文件夹下</span><br><span class="line">                   //outputPath: &apos;image&apos;,    //编译时，将所有的图片统一放在/image文件夹下</span><br><span class="line">                   esModule：false          //图片不按模块导入</span><br><span class="line">               &#125;</span><br><span class="line">            ],</span><br><span class="line">            // include: path.resolve(__dirname,&apos;src&apos;)       //指定处理的文件</span><br><span class="line">            // exclude: /node_modules/                      //排除处理的文件</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            //字体图标  file-loader 就是编译图片的加载器</span><br><span class="line">            test:/\.(svg|eot|ttf|woff|woff2)$/i,</span><br><span class="line">            use:[</span><br><span class="line">                loader&quot;file-loader&quot;,</span><br><span class="line">                options:&#123;</span><br><span class="line">                   name: &apos;image/[name].[hash].[ext]&apos;    //添加 image/编译时，将所有的图片统一放在/image文件夹下</span><br><span class="line">               &#125;</span><br><span class="line">                ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            //处理HTML页面中的图片 html-withimg-loader，并按照上述的图片处理机制来处理</span><br><span class="line">            test:/\.html$/i,</span><br><span class="line">            use:[&quot;html-withimg-loader&quot;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在JS中动态创建图片</p></blockquote><ul><li>如果使用的是一个外网的绝对地址，直接使用即可（编译后还是外网地址，联网即可加载）</li><li>如果设置的是相对地址，则需要基于require将图片导入进来使用，否则编译后的地址是找不到的，需要使用rquire导入，并在配置文件中设置 <code>esModule：false</code> 不按模块导出图片</li></ul><h2 id="JS的兼容处理和词法检测"><a href="#JS的兼容处理和词法检测" class="headerlink" title="JS的兼容处理和词法检测"></a>JS的兼容处理和词法检测</h2><blockquote><p>我们之前对js的处理只是将各模块的代码合并压缩，对于js并没有做其他处理，所以会遇到使用ES6代码不能在低版本浏览器运行的情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-loader @babel/core @babel/preset-env --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line"></span><br><span class="line">module.exoprts = &#123;</span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">     module:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            //...</span><br><span class="line">            &#123;</span><br><span class="line">                test:/.js$/i,</span><br><span class="line">                use:[&#123;</span><br><span class="line">                    loader:&quot;babel-loader&quot;,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        //把ES6转成ES5</span><br><span class="line">                        presets:[</span><br><span class="line">                            &quot;@babel/preset-env&quot;</span><br><span class="line">                        ],</span><br><span class="line">                        //基于插件处理ES6/ES7中class特殊语法</span><br><span class="line">                        plugins:[</span><br><span class="line">                            [&quot;@babel/plugin-proposal-decorators&quot;,&#123;</span><br><span class="line">                                &quot;legacy&quot;:true</span><br><span class="line">                            &#125;],</span><br><span class="line">                            [&quot;@babel/plugin-proposal-class-properties&quot;,&#123;</span><br><span class="line">                                &quot;loose&quot;:true</span><br><span class="line">                            &#125;],</span><br><span class="line">                            &quot;@babel/plugin-transform-runtime&quot;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,&quot;eslint-loader&quot;],     //开启词法检测</span><br><span class="line">                include: path.resolve(__durname,&apos;src&apos;),</span><br><span class="line">                exclude: /node_modules/</span><br><span class="line">            &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@babel/polyfill</code>和其他的webpack加载器和插件不同，其它是编译时处理（编译代码时处理），而polyfill是运行时处理，也就是在运行时将ES7等特殊代码进行兼容处理</p></blockquote><ul><li>需要安装在生产依赖 <code>@babel/polyfill</code>和<code>@babel/runtime</code></li><li>需要一个插件的支持 <code>@babel/plugin-transform-runtime</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//直接在文件中导入</span><br><span class="line">require(&apos;@babel/polyfill&apos;);</span><br></pre></td></tr></table></figure><blockquote><p><code>eslint-loader</code>词法检测，检测编写的代码是否符合代码规范</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack--入门篇</title>
      <link href="/2020/09/25/2020-09-25-webpack-%E5%85%A5%E9%97%A8%E7%AF%87-md/"/>
      <url>/2020/09/25/2020-09-25-webpack-%E5%85%A5%E9%97%A8%E7%AF%87-md/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack零配置操作"><a href="#webpack零配置操作" class="headerlink" title="webpack零配置操作"></a>webpack零配置操作</h2><p><strong>安装</strong></p><blockquote><p>为了防止全局安装webpack导致版本冲突，真实项目中以安装到本地为主</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y       //创建package.json文件 项目目录中是不能包含中文、数字以及特殊符号的</span><br><span class="line">$ npm install webpack webpack-cli --save-dev    //下载webpack及脚手架  --save/-S/不加 是生产依赖  --save-dev/-D是开发依赖</span><br><span class="line">$ yarn webpack webpack-cli -D</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>零配置</strong></p><blockquote><p>基于webpack4.0以上的版本,可以直接零配置使用webpack</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 默认打包 src 目录下的JS文件（默认入口是index.js）</span><br><span class="line"> * 打包完之后的文件会默认放在 dist/main.js</span><br><span class="line"> * webpack默认支持CommonJS和ES6Module模块规范，以此来进行依赖打包</span><br><span class="line"> */</span><br><span class="line">$ npx webpack</span><br></pre></td></tr></table></figure><ul><li><code>src</code>：当前项目的源代码</li><li><code>dist</code>：编译后的文件（未来部署到服务器的代码）</li></ul><h2 id="webpack自定义基础配置（环境区分）"><a href="#webpack自定义基础配置（环境区分）" class="headerlink" title="webpack自定义基础配置（环境区分）"></a>webpack自定义基础配置（环境区分）</h2><blockquote><p>webpack的默认配置文件<code>webpack.config.js</code>或<code>webpackfile.js</code>,文件必须放在项目的根目录下。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// webpack本身是基于Node.js开发的，所以配置项的模块处理规则参照CommonJS规范来完成</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //设置编译模式 development(开发)/production(生产：默认)</span><br><span class="line">    mode:&apos;development&apos;,</span><br><span class="line">    //设置编译的入口文件</span><br><span class="line">    entry:&apos;./src/main.js&apos;,</span><br><span class="line">    //设置编译的出口文件</span><br><span class="line">    output:&#123;</span><br><span class="line">        //编译后的出口文件名</span><br><span class="line">        filename:&apos;bundle.js&apos;,</span><br><span class="line">        //输出的目录（需要是绝对路径）</span><br><span class="line">        path: path.resolve(__dirname,&apos;build&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>浏览器缓存策略问题：页面在第一次加载的时候会缓存在浏览器内存中，如果我们只是修改了代码没有修改文件名，但是由于缓存策略，拿不到修改后的代码，还是用的之前缓存的文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 真实项目中，为了在文件更新之后，清除缓存的影响，我们通常会在导入的源文件的文件名中添加随机数或者哈希值</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    output:&#123;</span><br><span class="line">        // 编译的时候会在名字中添加唯一的hash值，保证每次编译出的文件是不同的</span><br><span class="line">        filename:&apos;bundle.[hash].js&apos;,</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种在文件中添加hash值的方法叫做<code>文件指纹</code>:文件指纹有三种，分别是：<code>hash</code>、``、<code>contexthash</code></p></blockquote><h2 id="自定义配置文件名"><a href="#自定义配置文件名" class="headerlink" title="自定义配置文件名"></a>自定义配置文件名</h2><blockquote><ul><li>在package.json中配置可执行的脚本命令（区分开发环境）</li><li>$ npm webpack –config webpack config development.js</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 新建不同的webpack配置文件，基于webpack命令用我们自己的配置文件</span><br><span class="line">&quot;script&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;:&quot;webpack --config webpack.config development.js&quot;,</span><br><span class="line">    &quot;build&quot;:&quot;webpack --config webpack.config production.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了自己定义的不同环境的配置文件，还可以自定义一个webpack.config.base.js文件来保存公用配置模块</p></blockquote><h2 id="配置HTML页面模板"><a href="#配置HTML页面模板" class="headerlink" title="配置HTML页面模板"></a>配置HTML页面模板</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><blockquote><ol><li>为js入口文件添加了文件指纹，每次生成的js文件名字都不同，每次手动引入都比较麻烦，所以我们可以借助插件：<code>html-webpack-plugin</code>帮我们实现自动化插入js文件</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//下载插件</span><br><span class="line">$ npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const Html-webpack-plugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;development&apos;,</span><br><span class="line">    entry:&apos;./src/main.js&apos;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;bundle.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname,&apos;build&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    //在webpack中使用插件</span><br><span class="line">    plugin:[</span><br><span class="line">        //配置指定的HTML模板（后期将编译好的资源文件自动导入页面模板中）</span><br><span class="line">        new Html-webpack-plugin(&#123;</span><br><span class="line">            //模板路径</span><br><span class="line">            template:&apos;./public./index.html&apos;，</span><br><span class="line">            //编译后生成的文件名</span><br><span class="line">            filename:&apos;index.html&apos;，</span><br><span class="line">            //是否把编译的资源文件导入页面中，设置hash值（清除强缓存，和output文件加文件指纹是一样的目的）,hash是？传参的方式引入</span><br><span class="line">            hash:true,  //和文件指纹只保留一种即可</span><br><span class="line">            // 把模板中的HTML代码进行压缩编译的配置规则</span><br><span class="line">            //https://github.com/kangax/html-minifier</span><br><span class="line">            minify:&#123;</span><br><span class="line">                collapseWhitespace: true,   //清除标签之间的空格和换行</span><br><span class="line">                removeComments: true,   //去掉注释</span><br><span class="line">                removeAttributeQuotes:true, //去掉属性的双引号</span><br><span class="line">                removeEmptyAttributes:true  //去除空标签</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><blockquote><ol start="2"><li>每一次打包的时候都把之前的内容清除，只是保留最新的打包文件，使用<code>clean-webpack-plugin</code></li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//下载插件</span><br><span class="line">$ npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123;CleanWebpackPlugin&#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugin:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">        //...</span><br><span class="line">        &#125;),</span><br><span class="line">        //每一次打包都把之前的文件清空</span><br><span class="line">        new CleanWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><blockquote><ol start="3"><li>每次生成将代码更改，都需要打包，然后再使用VSCode的live server来创建服务，这样非常浪费时间。所以我们需要使用插件<code>webpack-dev-server</code>来帮我们做以下事情。</li></ol></blockquote><ul><li>自动监听代码的改变，如果代码改变自动编译（除更改配置项，需要重新执行）</li><li>自动帮我们打开浏览器渲染页面</li><li>重新编译后自动刷新浏览器看到最新效果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        //端口</span><br><span class="line">        port:3000,</span><br><span class="line">        //Gzip压缩</span><br><span class="line">        compress:true,</span><br><span class="line">        //显示编译进度</span><br><span class="line">        progress:true,</span><br><span class="line">        //指定访问资源路径</span><br><span class="line">        contentBase:path.resolve(__dirname,&quot;dist&quot;),</span><br><span class="line">        //是否自动打开浏览器</span><br><span class="line">        open:false,</span><br><span class="line">        //开启热更新</span><br><span class="line">        hot:true,</span><br><span class="line">        //跨域请求代理</span><br><span class="line">        proxy:&#123;</span><br><span class="line">            &quot;/&quot;:&#123;</span><br><span class="line">                target:&quot;http://localhost:8888&quot;,</span><br><span class="line">                secure:false,//true=&gt;https,false=&gt;http</span><br><span class="line">                changeOrigin:true//把请求头中的host值改为服务器地址</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugin:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">        //...</span><br><span class="line">        &#125;),</span><br><span class="line">        new CleanWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在package.json文件中添加命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;sctipt&quot;:&#123;</span><br><span class="line">    &quot;serve&quot;:&quot;webpack-dev-server&quot;,   //开发模式下预览：直接编译到计算机内存中</span><br><span class="line">    &quot;bulid&quot;:&quot;webpack&quot;       //项目上线的命令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>npm run serve</code> 编译后的文件会存在浏览器的内存中，不会放到dist文件，它只是在开发模式下随时编译并预览的，在项目上线的时候还是要编译到dist文件下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入JS四种数据类型检测的方式及原理</title>
      <link href="/2020/09/24/2020-09-24-%E6%B7%B1%E5%85%A5JS%E5%9B%9B%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86-md/"/>
      <url>/2020/09/24/2020-09-24-%E6%B7%B1%E5%85%A5JS%E5%9B%9B%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86-md/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型检测的四种方案"><a href="#数据类型检测的四种方案" class="headerlink" title="数据类型检测的四种方案"></a>数据类型检测的四种方案</h2><ul><li>typeof    检测数据类型的运算符</li><li>instanceof    检测该实例是否为该类的实例</li><li>constructor   检测实例的构造函数</li><li>Object.prototype.toSring.call  打印数据的类型</li></ul><a id="more"></a><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote><p>返回的结果是一个字符串，字符串中对应的数据类型有”number、string、boolean、undefined、symbol、bigint、object、function”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof typeof xxx //=&gt;结果都是:&quot;string&quot;</span><br></pre></td></tr></table></figure><p>typeof原理：它是按照数据在计算机底层存储的二进制结果来进行检测的。</p><ul><li>bug: typeof null 的结果是”Object” 是因为null在底层的二进制是：000000,对象在底层的二进制是：000xxx；所以使用typeof检测null的时候会打印出对象。这个BUG在现代浏览器中已经被修复了，但是为了兼容老版本，所以打印出来的结果还是null</li><li>所有形式的对象都是以000开头，所以基于typeof检测对象类型的结果都是“Object”，这就是为什么typeof无法细分对象和数组</li></ul><h3 id="intanceof"><a href="#intanceof" class="headerlink" title="intanceof"></a>intanceof</h3><blockquote><p>为了解决typeof不能够区分具体对象的缺点，于是就把instanceof这个方法拉过来检测对象数据类型</p></blockquote><ul><li>并不是检测数据类型的，是用来检测当前实例是否属于这个类，只是被拉过来做“临时工”</li><li>用它来检测，一般只应用于普通对象/数组对象/正则对象/日期对象等的具体细分的</li><li>“临时工”不是专业的，所以存在很多问题</li></ul><blockquote><p>结果为true也不一定是Object的实例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr =[];</span><br><span class="line">arr instanceof Array;       //true</span><br><span class="line">arr instanceof Object;      //true</span><br><span class="line">arr instanceof RegExp;      //false</span><br></pre></td></tr></table></figure><blockquote><p>instanceof 无法应用于基本数据类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let n = 10;</span><br><span class="line">let m = new Number(10);</span><br><span class="line">//能够调用Number原型上的方法，那么它一定是Number类的实例</span><br><span class="line">console.log(n.toFix(2));  //&quot;10.00&quot;  =&gt; 基本类型值在调用原型上的方法时，浏览器会将基本类型值Object(n)处理一下，然后他就可以基于原型链查找方法了</span><br><span class="line">console.log(m.toFix(2));  //&quot;10.00&quot; </span><br><span class="line"></span><br><span class="line">n instanceof Number;    //false</span><br><span class="line">m instanceof Number;    //true</span><br></pre></td></tr></table></figure><blockquote><p>手动修改原型链，会影响instanceof的检测结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype = Array.prototype;</span><br><span class="line">let p1 = new Person;</span><br><span class="line">console.log(p1); //虽然p1可以基于__proto__找到Array.prototype，但是它不具备数组的任何特征(length/索引都没有的)，所以断定这一定不是一个数组，但是</span><br><span class="line">p1 instanceof Array; //true</span><br></pre></td></tr></table></figure><h4 id="instanceof原理"><a href="#instanceof原理" class="headerlink" title="instanceof原理"></a>instanceof原理</h4><p>打印出Function的原型</p><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/380fa040-fd84-11ea-b244-a9f5e5565f30.png"><blockquote><p>基于” 实例 instanceof 类” 检查数据类型的时候，浏览器底层会将它处理成 “类.hasInstance(实例)” 的方式。（所有类都是Function的实例）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">arr instanceof Array;               //true</span><br><span class="line">Array[Symbol.hasInstance](arr);     //true</span><br><span class="line"></span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">arr instanceof obj;     //对象不是function的实例，他没有这个属性</span><br></pre></td></tr></table></figure><blockquote><p>Symbol.hasInstance方法执行的原理</p></blockquote><ul><li>根据当前实例的原型链上(__proto__)是否存在这个类的原型(prototype)</li><li>arr.__proto__===Array.prototype   =&gt; arr instanceof Array  : true</li><li>arr.__proto__.__proto__===Object.prototype =&gt; arr instanceof Object : true</li></ul><h4 id="重写instanceof"><a href="#重写instanceof" class="headerlink" title="重写instanceof"></a>重写instanceof</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  [parmas1] obj 要检测的实例</span><br><span class="line"> *  [patmas2] constructor 要检查的类</span><br><span class="line"> */</span><br><span class="line">function instance_of(obj,constructor)&#123;</span><br><span class="line">    // 参数校验</span><br><span class="line">    if(obj ==  null || !/^(Object|Function)$/i.test(typeof obj)) return false;</span><br><span class="line">    if(typeof constructor !== &apos;function&apos;) throw new TypeError(&quot;Right-hand side of &apos;instanceof&apos; is not callable&quot;);</span><br><span class="line">    </span><br><span class="line">     // obj.__proto__ === Object.getPrototypeOf(obj) 这里使用兼容写法</span><br><span class="line">    let proto = Object.getPropertyOf(obj),</span><br><span class="line">        prototype = constructor.prototype;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        if( proto === null ) return false;</span><br><span class="line">        if( proto === prototype ) return true;</span><br><span class="line">        proto = Object.getPropertyOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><blockquote><p>constructor是原型上一个指向构造函数的属性，它同样是被临时拉过来做数据类型检测的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">console.log(arr.constructor === Array); //true  在constructor不被修改的情况下，这样区分是数组还是普通对象</span><br><span class="line">console.log(arr.constructor === Object); //false</span><br><span class="line">console.log(arr.constructor === RegExp); //false</span><br></pre></td></tr></table></figure><blockquote><p>原型重定向</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype = Array.prototype;</span><br><span class="line">let p1 = new Person;</span><br><span class="line">console.log(p1.constructor === Array); //true 一但原型重定向，constructor也改了，所以也就不准了</span><br></pre></td></tr></table></figure><blockquote><p>检查基本数据类型，相较于instanceof来说对基本数据类型检查的支持更好</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let n = 10;</span><br><span class="line">let m = new Number(10);</span><br><span class="line">console.log(n.constructor === Number); //true</span><br><span class="line">console.log(m.constructor === Number); //true</span><br></pre></td></tr></table></figure><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><blockquote><p>专业的检测数据类型的方法，除了代码长，可以说是零瑕疵</p></blockquote><blockquote><p>Number、String、Boolean、Symbol、BigInt、Function、Array、RegExp、Date、Object…的原型上都有toString，除了Object.prototype.toString不是转换字符串的，其余都是，Object.prototype.toString是用来检测数据类型的</p></blockquote><blockquote><p>返回结果”[object  对象[Symbol.toStringTag] || 对象.constructor || Object]” </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let class2type = &#123;&#125;,</span><br><span class="line">    toString = class2type.toString; //Object.prototype.toString</span><br><span class="line">toString.call(10);   //[object Number]</span><br><span class="line">toString.call(&apos;A&apos;);  //[object String]</span><br><span class="line">toString.call(true);  //[object Boolean]</span><br><span class="line">toString.call(null);  //[object Null]</span><br><span class="line">toString.call(undefined);  //[object Undefined]</span><br><span class="line">toString.call(Symbol());  //[object Symbol]</span><br><span class="line">toString.call(/^$/);  //[object RegExp]</span><br><span class="line">toString.call(function());  //[object Function]</span><br><span class="line">toString.call(function* ());  //[object GeneratorFunction]</span><br></pre></td></tr></table></figure><blockquote><p>将constructor修改也不会影响到最后的返回值</p></blockquote><p>所以可以借用Symbol.toStringTag来修改自定义类的检测结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // 只要获取实例的[Symbol.toStringTag]属性值，则调用这个方法</span><br><span class="line">    get[Symbol.toStringTag]() &#123;</span><br><span class="line">        return &quot;Person&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Person; </span><br><span class="line">toString.call(p1) =&gt; &quot;[object Person]&quot;</span><br></pre></td></tr></table></figure><h2 id="封装一个数据类型检查的通用方法"><a href="#封装一个数据类型检查的通用方法" class="headerlink" title="封装一个数据类型检查的通用方法"></a>封装一个数据类型检查的通用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var class2type = &#123;&#125;;</span><br><span class="line">var toString = class2type.toString;  </span><br><span class="line"></span><br><span class="line">[&quot;Boolean&quot;,&quot;Number&quot;,&quot;String&quot;,&quot;Function&quot;,&quot;Array&quot;,&quot;Date&quot;,&quot;RegExp&quot;,&quot;Object&quot;,&quot;Error&quot;,&quot;Symbol&quot;].forEach(name =&gt; &#123;</span><br><span class="line">    class2type[`[object $&#123;name&#125;]`] = name..toLowerCase();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function toType(obj) &#123;</span><br><span class="line">    if (obj == null) &#123;</span><br><span class="line">        return obj + &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?</span><br><span class="line">        class2type[toString.call(obj)] || &quot;object&quot; :</span><br><span class="line">        typeof obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack--前置篇</title>
      <link href="/2020/09/23/2020-09-23-webpack--%E5%89%8D%E7%BD%AE%E7%AF%87-md/"/>
      <url>/2020/09/23/2020-09-23-webpack--%E5%89%8D%E7%BD%AE%E7%AF%87-md/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><blockquote><p>webpack是一款基于node.js实现的，现代JavaScript应用程序的静态模块打包工具。</p></blockquote><p>官网图片<br><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/6f3171d0-fd6f-11ea-8ff1-d5dcf8779628.jpg"></p><a id="more"></a><p>功能：</p><ul><li>代码转换：TypeScript编译成JavaScript、less/sass编译成css、ES6编译成ES5、虚拟DOM编译成真实DOM</li><li>文件优化：压缩JS、CSS、HTML代码，合并压缩图片，图片base64</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码</li><li>模块合并：在采用模块化的项目李会有很多个模块和文件，需要构建模块分类合并成一个文件</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器</li><li>代码校验：Eslint代码规范校验和检查、单元测试</li><li>自动发布：自动构建出线上发布代码并传给发布系统（基于webpack的二次开发）</li></ul><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><blockquote><p>JavaScript本身是弱化命名空间概念的，只有全局作用域和私有作用域（ES6新增块级作用域），而模块化开发从某种意义上来说，强调了命名空间的概念</p></blockquote><p>这里简单介绍一下ES6Module和CommonJS两种规范，其它规范可以参见我之前的一片文章—<a href="https://lizhutao.github.io/2020/04/13/2020-04-13-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91-md/" target="_blank" rel="noopener">模块化开发</a></p><h3 id="ES6Module"><a href="#ES6Module" class="headerlink" title="ES6Module"></a>ES6Module</h3><blockquote><p>ES6Module是ES6中提供的模块化规范，主要是为了实现浏览器端的模块化开发,主要是通过<code>import</code>和<code>export</code>来规定模块的导入导出。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, add &#125;;   //使用export导出的结果需要使用&#123; &#125;解构赋值的方式接收</span><br><span class="line">// export default 用于定义默认输出，导出的结果可以不用使用大括号来接收</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from &apos;./math&apos;;     // 用于接收export的结果</span><br><span class="line">// 还可以使用 import * as math from &apos;./math&apos; 来接收，使用的时候只需要math.add()即可</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><blockquote><p>node.js是基于CommonJS规范实现的，所以我们在操作与node相关的模块例如webpack都要使用CommonJS的语法规范，它使用<code>module.export</code>实现模块导出以及<code>require</code>实现模块的导入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var basicNum = 0;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在这里写上需要向外暴露的函数、变量</span><br><span class="line">module.exports = &#123; add,basicNum &#125;</span><br></pre></td></tr></table></figure><p>引用自定义的模块时，参数包含路径，可省略.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var math = require(&apos;./math&apos;);</span><br><span class="line">math.add(2, 5);</span><br></pre></td></tr></table></figure><p>引用核心模块时，不需要带路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createService(...).listen(3000);</span><br></pre></td></tr></table></figure><h2 id="NPM基本操作"><a href="#NPM基本操作" class="headerlink" title="NPM基本操作"></a>NPM基本操作</h2><blockquote><p>想要熟练使用webpack，npm的操作是必不可少的，所以在学习webpack之前我们需要了解一些npm的基本操作。</p></blockquote><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install xxx       //本地安装</span><br><span class="line">$ npm i xxx -g          //全局安装</span><br><span class="line">$ npm i xxx@xx.xx       //安装指定版本</span><br><span class="line">$ npm i xxx@latest      //安装最新版本</span><br><span class="line">$ npm uninstall xxx / -g    //卸载指定文件</span><br><span class="line"></span><br><span class="line">$ npm root -g           //查看全局安装目录</span><br><span class="line">$ npm view xxx version &gt; xxx.version.json       //查看文件的版本号，并指定文件接收</span><br></pre></td></tr></table></figure><h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><ul><li>所有项目都能够使用</li><li>一般都是基于命令来完成操作（全局下安装的模块会生成xxx.cmd的可执行命令文件）</li><li>容易导致版本冲突</li><li>不能在项目中导入对应模块</li></ul><h4 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h4><ul><li>只能在本地项目中使用</li><li>默认不支持命令操作指令（可以基于package.json或者npx[npm &gt; 5.2]）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//基于 npm init -y 创建的package.json文件实现本地命令操作</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    // &quot;自定义属性名&quot;：&quot;要执行的命令&quot;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li>不会导致版本冲突</li><li>可以在本地代码中导入对应模块</li></ul><h3 id="优化速度"><a href="#优化速度" class="headerlink" title="优化速度"></a>优化速度</h3><ul><li>nrm<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nrm ls        //可以查看可以使用的源</span><br><span class="line">$ nrm use yarn  //切换源</span><br></pre></td></tr></table></figure></li><li>yarn</li><li>cnpm</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><blockquote><p>生成package.json文件</p></blockquote><ol><li>npm init -y</li><li>记录当前项目所需要的开发环境和生产依赖项的模块清单</li><li>可以配置可执行的脚本文件</li><li>配置其他信息供node或者webpack编译的时候使用</li></ol><blockquote><p>项目开发中我们会使用很多模块，有些模块在项目部署的时候是不需要的，例如：less。有些模块是在项目开发和部署时都需要，例如jquery。</p></blockquote><h3 id="跑环境"><a href="#跑环境" class="headerlink" title="跑环境"></a>跑环境</h3><blockquote><p>通常我们将项目上传到git上是不会将node_module文件夹上传的，使用<code>.gitignore</code>文件来配置不上传的额文件。那么我的依赖没有上传，别人把我的代码拉下来怎么运行呢，这就需要“跑环境”了  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//跑环境就是按照package.json配置清单将需要的模块都下载一遍</span><br><span class="line">$ npm i                 //安装全部依赖</span><br><span class="line">$ npm i --production    //安装生产依赖</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组对象的深浅拷贝</title>
      <link href="/2020/09/19/2020-09-19-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D-md/"/>
      <url>/2020/09/19/2020-09-19-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D-md/</url>
      
        <content type="html"><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>浅克隆只是对第一个级别进行克隆，如果第一级别中存在引用数据类型，那么只会复制他的引用地址。</p></blockquote><p>浅克隆的实现原理</p><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/063ed480-fa75-11ea-81ea-f115fe74321c.png"><a id="more"></a><blockquote><p>实现对象浅克隆的几种方案</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: 100,</span><br><span class="line">    b: [10,20,30],</span><br><span class="line">    c: &#123; x:10 &#125;,</span><br><span class="line">    d: /^\d+$/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//方案一：利用assign进行数组合并，&#123;&#125;放在第一个参数的位置，复制之后使用的是第一个参数的堆内存地址</span><br><span class="line">let newObj1 = Object.assign(&#123;&#125;,obj);</span><br><span class="line">//方案二：利用ES6中的 ...  展开运算符</span><br><span class="line">let newObj2 = &#123; ...obj &#125;</span><br><span class="line">//方案三：循环遍历数组，并将属性以及属性值赋值到新的数组中</span><br><span class="line">let new Obj3 = &#123;&#125;;</span><br><span class="line">for(let key in obj)&#123;</span><br><span class="line">    if(!obj.hasOwnProperty(key)) break;</span><br><span class="line">    newObj[key] = obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for in</code> 循环遍历对象的时候，遍历的是当前对象的可枚举的属性</p><ul><li>私有属性（除一些特殊的内置属性不可枚举）</li><li>公有属性（大部分都是不可枚举的，但是自己在原型上扩展的是可枚举的）</li><li>所以一般使用for in循环都会添加判断</li></ul><p><code>for of</code> 循环时不会遍历到原型上的方法</p><blockquote><p>数组实现浅克隆，数组本质上也是对象，所以实现对象浅克隆的方式数组也能使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newArr = arr.cancat([]);</span><br></pre></td></tr></table></figure><h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><blockquote><p>深克隆的本质是将对象的每一个层级都遍历出来，在遇到引用数据类型时会开辟新的堆内存来存储数据，所以改变新数组中的属性是一定不会影响到原有对象的。数组和对象的深克隆实现方式也几乎一样</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/1666b990-fa75-11ea-8a36-ebb87efcf8c0.png"><p><strong>方案一</strong>：整体变为字符串，再重新变为对象，这样浏览器会重新开辟全套的内存空间存储信息 JSON.stringify/JSON.parse</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: 100,</span><br><span class="line">    b: [10, 20, 30],</span><br><span class="line">    c: &#123;</span><br><span class="line">        x: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    d: /^\d+$/,</span><br><span class="line">    e: Symbol(&apos;AA&apos;),</span><br><span class="line">    f: new Date(),</span><br><span class="line">    g: function () &#123;&#125;,</span><br><span class="line">    h: undefined,</span><br><span class="line">    i: null</span><br><span class="line">&#125;;</span><br><span class="line">let arr = [10, [100, 200], &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    y: 20</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">let newArr = JSON.parse(JSON.stringify(arr));</span><br><span class="line">let newObj = JSON.parse(JSON.stringify(obj));</span><br></pre></td></tr></table></figure><blockquote><p><strong>缺陷</strong> 这种办法存在BUG:把对象中的某些属性值变为字符串，会存在问题</p></blockquote><ul><li>正则变为{}</li><li>日期对象变为日期字符串</li><li>Symbol/BigInt/function/undefined等会消失</li><li>所以这种办法适用于数据中只有:“number/string/boolean/null/普通对象/数组对象” 等内容的时候</li></ul><p><strong>方案二</strong>：自己单独一层层遍历处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function cloneDeep(obj)&#123;</span><br><span class="line">    // 如果传递的不是对象类型，直接返回对应的值（基本类型/函数/Symbol/BigInt）</span><br><span class="line">    let type = typeOf obj;</span><br><span class="line">    if( obj === null ) return null;</span><br><span class="line">    if( type !== &apos;Object&apos;) return obj;</span><br><span class="line">    // 获取当前值的构造函数：获知它的类型</span><br><span class="line">    let constuctor = obj.constuctor;</span><br><span class="line">    // 如果是正则或者日期函数，我们则创建一个值类似但是不同实例的结果出来</span><br><span class="line">    if(/^(RegExp|Date)$/i.test(constuctor.name)) return new constuctor(obj);</span><br><span class="line">    </span><br><span class="line">    // 创造对象的新实例:新数组或者新对象</span><br><span class="line">    let clone = new constuctor;</span><br><span class="line">    for(key in obj)&#123;</span><br><span class="line">        if(!obj.hasOwnProperty(key)) break;</span><br><span class="line">        clone[key] = cloneDeep(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class以及JS常见的继承方式</title>
      <link href="/2020/09/18/2020-09-18-class%E4%BB%A5%E5%8F%8AJS%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F-md/"/>
      <url>/2020/09/18/2020-09-18-class%E4%BB%A5%E5%8F%8AJS%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F-md/</url>
      
        <content type="html"><![CDATA[<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><blockquote><p>class是ES6中为我们提供定义类的方法，class的本质其实还是function，所有我们可以将它看做一个语法糖，目的是为了让JS中的面向对象编程更加清晰。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Model&#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    //ES7中支持以下方式,相当于this.n = 100,即在构造函数之外给实例设置私有属性和方法</span><br><span class="line">    n = 100;</span><br><span class="line">    m = function()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    //定义原型上的公共方法,不用加逗号，这不是对象</span><br><span class="line">    //公共属性不能在class中直接定义</span><br><span class="line">    //getX:()=&gt;&#123;&#125; 原生不支持，在react中，可以基于babel-preset-react-app语法包进行识别</span><br><span class="line">    getX()&#123;&#125;</span><br><span class="line">    getY()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    //将类当做普通对象，设置&quot;静态&quot;属性和方法</span><br><span class="line">    static n = 200;</span><br><span class="line">    static setNumber()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//原型上的公共属性只能单独提取出来设置</span><br><span class="line">Model.prototype.z = 300</span><br></pre></td></tr></table></figure><blockquote><p>使用class创建的类是不能被直接执行的，只能被new执行。</p></blockquote><h3 id="JS中实现继承的几种方式"><a href="#JS中实现继承的几种方式" class="headerlink" title="JS中实现继承的几种方式"></a>JS中实现继承的几种方式</h3><blockquote><p>在JS中实现继承的主要目的是，子类的实例能够使用父类的公共属性和方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Parent()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getX = getX()&#123;</span><br><span class="line">    return this.x;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">function Child()&#123;</span><br><span class="line">    this.y = 200;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.getX = getX()&#123;</span><br><span class="line">    return this.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类的实例</span><br><span class="line">let c1 = new Child();</span><br><span class="line">console.log(c1)</span><br></pre></td></tr></table></figure><h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><blockquote><p>第一种方式，通过改写子类的原型链，来创建两个类之间的联系。即将子类的原型改写成为父类的实例，那么就可以通过父类的实例来访问父类原型上的方法以及父类实例上的属性。</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/d9d9d2d0-f981-11ea-8a36-ebb87efcf8c0.png"><ul><li>父类中私有和公有的属性方法，最后都会成为子类的公有属性方法</li><li>和其他语言不同，原型继承并不会将父类的属性及方法“拷贝”给子类，而是子类基于原型链属性查找</li><li>缺点：<ul><li>子类能够通过原型链属性改写原型的公共属性方法</li></ul></li></ul><h4 id="call继承"><a href="#call继承" class="headerlink" title="call继承"></a>call继承</h4><blockquote><p>利用call属性来改写this的方式实现继承</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getX = getX()&#123;</span><br><span class="line">    return this.x;</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line">    //将Parent当做普通函数执行，并让this指向child的实例，相当于给子类的实例添加私有属性x=100</span><br><span class="line">    Parent.call(this);</span><br><span class="line">    this.y = 200;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.getX = getX()&#123;</span><br><span class="line">    return this.y;</span><br><span class="line">&#125;</span><br><span class="line">let c1 = new Child();</span><br><span class="line">console.log(c1)</span><br></pre></td></tr></table></figure><blockquote><p>call继承只能继承父类中私有的，不能继承父类中公有的</p></blockquote><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><blockquote><p>call继承只能继承私有属性，那么我们怎么将公有属性也能够继承过来能？结合原型继承即可以实现了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getX = getX()&#123;</span><br><span class="line">    return this.x;</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line">    Parent.call(this);</span><br><span class="line">    this.y = 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将子类原型的原型链指向父类原型</span><br><span class="line">//Child.prototype.__proto__ = Parent.prototype;</span><br><span class="line">Child.prototype = Object.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line">Child.prototype.getX = getX()&#123;</span><br><span class="line">    return this.y;</span><br><span class="line">&#125;</span><br><span class="line">let c1 = new Child();</span><br><span class="line">console.log(c1)</span><br></pre></td></tr></table></figure><h4 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h4><blockquote><p>ES6中不但给我们提供了<code>class</code>来创建类，还提供了<code>extends</code>来实现类的继承</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    x=100;</span><br><span class="line">    getX()&#123;return this.x;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.y=200;</span><br><span class="line">    &#125;</span><br><span class="line">    getY()&#123;return this.y;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用extends来实现继承要在constructor的首行加上super(),super()的作用类似于寄生组合式继承中call的作用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕call、apply、bind源码</title>
      <link href="/2020/09/16/2020-09-16-%E6%89%8B%E6%92%95call%E3%80%81apply%E3%80%81bind%E6%BA%90%E7%A0%81-md/"/>
      <url>/2020/09/16/2020-09-16-%E6%89%8B%E6%92%95call%E3%80%81apply%E3%80%81bind%E6%BA%90%E7%A0%81-md/</url>
      
        <content type="html"><![CDATA[<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><blockquote><p>函数.call([context],parmas1,parmas2,…)</p></blockquote><blockquote><p>函数执行，将函数的this指向[context],并将parmas1、parmas2…作为实参传递给函数</p></blockquote><a id="more"></a><ul><li>首先fn会基于原型链__proto__,找到Function.prototype.call方法，并将call方法执行</li><li>call方法中的this就是当前操作的实例fn，传递给call方法的第一个实参是未来this的指向也就是新的执行主体，然后剩余的参数都是未来要传给fn的参数信息</li><li>call方法执行的过程中，实现了这样的操作：<ul><li>把fn（call中的this）执行，让fn中的this指向[context]</li><li>将parmas1,parmas2…作为实参传递给fn</li><li>接收fn执行的返回结果，在将返回值return外界</li></ul></li><li>call的本质是call执行，fn在call中执行</li><li>call执行不传参数或者传递的是null/undefined，例如fn.call()，在非严格模式下，this都是指向window（在严格模式下不传的时候指向undefined，传null或者undefined时this会指向对应值）</li></ul><h4 id="手写call方法"><a href="#手写call方法" class="headerlink" title="手写call方法"></a>手写call方法</h4><blockquote><p>实现对象和函数的联系思路：给对象添加私有属性，在调用完之后，再将属性delete</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.fn = fn;</span><br><span class="line">obj.fn(1,2);</span><br><span class="line">delete obj.fn;</span><br></pre></td></tr></table></figure><blockquote><p>借用上面的思路就可以实现call方法了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call = function call(context,...parmas)&#123;</span><br><span class="line">    //this =&gt; 当前执行的函数实例</span><br><span class="line">    //context =&gt; 给函数要改变的this ,类型处理：基本类型值无法添加自定义属性</span><br><span class="line">    //...parmas =&gt; 给函数出入的参数信息</span><br><span class="line">    </span><br><span class="line">    context == null ? context = window : null;</span><br><span class="line">    !/^(Function|Object)$/i.test(typeOf context) ? context = Object(context) : null;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    let result，</span><br><span class="line">        key = Symbol(&apos;key&apos;);</span><br><span class="line">    context[key] = this;</span><br><span class="line">    result = context[key](...parmas);</span><br><span class="line">    delete context[key];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过一个面试题，深入理解call"><a href="#通过一个面试题，深入理解call" class="headerlink" title="通过一个面试题，深入理解call"></a>通过一个面试题，深入理解call</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;Bsmall&apos;;</span><br><span class="line">function A(x,y)&#123;</span><br><span class="line">    var res=x+y;</span><br><span class="line">    console.log(res,this.name);</span><br><span class="line">&#125;</span><br><span class="line">function B(x,y)&#123;</span><br><span class="line">    var res=x-y;</span><br><span class="line">    console.log(res,this.name);</span><br><span class="line">&#125;</span><br><span class="line">B.call(A,40,30);    // 10 A</span><br><span class="line">B.call.call.call(A,20,10);  // NaN undefined</span><br><span class="line">Function.prototype.call(A,60,50);   // undefined</span><br><span class="line">Function.prototype.call.call.call(A,80,70); //undefined</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/308f85c0-f7f2-11ea-81ea-f115fe74321c.png"><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><blockquote><p>apply和call没有本质上的区别，他们唯一的区别是传参的形式不同，apply需要将传入的参数以数组的形式传入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call = function call(context,parmas)&#123;</span><br><span class="line">    //this =&gt; 当前执行的函数实例</span><br><span class="line">    //context =&gt; 给函数要改变的this ,类型处理：基本类型值无法添加自定义属性</span><br><span class="line">    //...parmas =&gt; 给函数出入的参数信息</span><br><span class="line">    </span><br><span class="line">    context == null ? context = window : null;</span><br><span class="line">    !/^(Function|Object)$/i.test(typeOf context) ? context = Object(context) : null;</span><br><span class="line">    !(typeOf parmas == &apos;Array&apos;) ? Array.from(parmas) : null;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    let result，</span><br><span class="line">        key = Symbol(&apos;key&apos;);</span><br><span class="line">    context[key] = this;</span><br><span class="line">    result = context[key](...parmas);</span><br><span class="line">    delete context[key];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><blockquote><p>call和apply在执行的时候，会立即执行要操作的函数，而bind不同，它是预先处理，执行bind只是把函数中需要改变的this先存储起来（预设），但此时函数不执行，执行bind会返回一个匿名函数，后期执行匿名函数的时候在把之前需要执行的函数更新，并且改变this为预设值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = fn.bind(obj,1,2)        //这里fn不执行</span><br><span class="line">a();                            //fn执行</span><br></pre></td></tr></table></figure><p><strong>需求：</strong> 1s后执行fn，并将fn中的this变为obj，传递1，2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(fn, 1000); //1000ms后执行fn，但是this-&gt;window，x/y都是undefined</span><br><span class="line">setTimeout(fn.call(obj, 10, 20), 1000); //这样处理不行，因为在设置定时器的时候，基于call方法，就把fn已经执行了，虽然this和参数都是我们想要的，但是并不是在1000ms后执行的 =&gt;把fn执行的返回结果绑定给定四期，1000ms后执行的是返回结果</span><br><span class="line"></span><br><span class="line">//方案一</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    fn.call(obj, 10, 20);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">//方案二</span><br><span class="line">setTimeout(fn.bind(obj, 10, 20), 1000);</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.body.onclick = fn;     //点击时执行的是fn</span><br><span class="line">document.body.onclick = fn();   //点击时执行的是fn的返回结果</span><br></pre></td></tr></table></figure><h4 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h4><blockquote><p>柯里化函数编程思想</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function bind(context,...parmas)&#123;</span><br><span class="line">    //this =&gt; 最后要执行的函数</span><br><span class="line">    //context =&gt; 函数要改变的this</span><br><span class="line">    //parmas =&gt; 给函数换地的参数</span><br><span class="line">    return (...args)=&gt;&#123;</span><br><span class="line">    // args =&gt; ev 触发执行，传递给匿名函数的信息，例如：事件对象。</span><br><span class="line">    fn.call(context,...parmas,...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>返回的匿名函数中的this是绑定的元素，不是执行的函数，这里可以使用箭头函数的方式处理，或者将外层函数的this存在that中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的三种角色以及原型链的终极方案</title>
      <link href="/2020/09/14/2020-09-14-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%92%E8%89%B2%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88-md/"/>
      <url>/2020/09/14/2020-09-14-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%92%E8%89%B2%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88-md/</url>
      
        <content type="html"><![CDATA[<h3 id="Function内置类"><a href="#Function内置类" class="headerlink" title="Function内置类"></a>Function内置类</h3><blockquote><p>所有函数都是Function内置类的实例，Function.prototype和其他构造函数的原型不同，它指向的不是一个对象，而是提个匿名的空函数。</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/0f45b3e0-f634-11ea-b997-9918a5dda011.jpg"><p>虽然函数的原型指向的不是一个对象，但是这个匿名空函数的表现却和对象是一样的，没有任何区别，而且这个函数没有函数自带的属性prototype却存在对象的__proto__属性。</p><a id="more"></a><p>虽然Function.prototype指向的是一个匿名的空函数，但是我们却同样能够通过函数的实例来调用Function原型上的公共属性和方法，从这我们能够看出函数其实也是一种对象。</p><h3 id="函数的三种角色"><a href="#函数的三种角色" class="headerlink" title="函数的三种角色"></a>函数的三种角色</h3><blockquote><ol><li>普通函数–&gt; 函数形成、释放、闭包作用域</li></ol></blockquote><blockquote><ol start="2"><li>构造函数–&gt; new执行、类和实例</li></ol></blockquote><blockquote><ol start="3"><li>普通对象–&gt; 键值对</li></ol></blockquote><p><strong>函数的三种角色之间没有必然的联系</strong></p><h3 id="终极版原型链"><a href="#终极版原型链" class="headerlink" title="终极版原型链"></a>终极版原型链</h3><blockquote><p>从函数的第三种角色我们知道，所有的函数都是一个对象，那么函数就会带有对象自带的属性__proto__,既然每个函数都有原型链属性，那么在整个JS原型链生态中必然会有函数的参与。</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/72f71440-f63b-11ea-81ea-f115fe74321c.png"><ol><li>所有的内置类都是Function的实例（包括Object）</li><li>Function本身，既是Object的实例也是Function的实例</li><li>Object本身，既是Object的实例也是Function的实例</li><li>Object.__proto__.__proto__ === Object.prototype</li><li>Function.__proto__ === Function.prototype</li><li>在Function.prototype上有call、apply、bind三种改变this的方法，所有函数都能调用者三个方法</li><li>JS中万物皆对象</li></ol><p><strong>例题</strong>：阿里面试题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName = function () &#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">    &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = function () &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = function () &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;;</span><br><span class="line">var getName = function () &#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;;</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName();          // 2</span><br><span class="line">getName();              // 4</span><br><span class="line">Foo().getName();        // 1</span><br><span class="line">getName();              // 1</span><br><span class="line">new Foo.getName();      // 2</span><br><span class="line">new Foo().getName();    // 3</span><br><span class="line">new new Foo().getName();    //3</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/c3426dd0-f63d-11ea-8a36-ebb87efcf8c0.png">]]></content>
      
      
      <categories>
          
          <category> JavaScript面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于内置类向原型拓展方法</title>
      <link href="/2020/09/13/2020-09-13-%E5%9F%BA%E4%BA%8E%E5%86%85%E7%BD%AE%E7%B1%BB%E5%90%91%E5%8E%9F%E5%9E%8B%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95-md/"/>
      <url>/2020/09/13/2020-09-13-%E5%9F%BA%E4%BA%8E%E5%86%85%E7%BD%AE%E7%B1%BB%E5%90%91%E5%8E%9F%E5%9E%8B%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS中内置类的原型上存储了大量能够供我们在实际项目中调用的属性和方法，但是这些方法和属性不一定能够满足我们在业务开发中的所有需求。例如当我们要给数组去重时，原型上是没有对应的方法来实现的，通常我们都是定义一个去重函数再将数组作为参数传入，这种方法调用起来比较麻烦。这个时候我们就可以基于内置类直接拓展来实现。</p></blockquote><a id="more"></a><ul><li>写在内置类原型上的方法，实例在调用的时候“实例.xxx()”<ul><li>xxx()方法执行</li><li>执行主体this是要操作的实例</li></ul></li><li>向内置类原型上拓展方法的目的是，将一些公共的属性和方法拓展到内置类的原型上，这样调用起来就比较的方便</li><li>自定义属性或方法名一定要与原型上本来就存在的属性和方法名区分开来，避免自己的方法将原型的方法覆盖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,1,2,3,4,2,3,1,4,4]</span><br><span class="line"></span><br><span class="line">function unique(arr)&#123;</span><br><span class="line">    return Array.from(new Set(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique(arr)    //=&gt;[1,2,3,4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,1,2,3,4,2,3,1,4,4]</span><br><span class="line"></span><br><span class="line">Array.prototype.unique = function unique()&#123;</span><br><span class="line">    //保证this是一个数组</span><br><span class="line">    if(!Array.isArray(this)) throw new TypeError(&apos;确保操作的是一个数组&apos;)；</span><br><span class="line">    return Array.from(new Set(this));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.unique();   //=&gt;[1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>例题1</strong>： 实现以下效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let n = 10;</span><br><span class="line">let m = n.plus(10).minus(5);</span><br><span class="line">console.log(m)  //=&gt;15 (10+10+-5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.plus = function plus(num)&#123;</span><br><span class="line">    return this + num;</span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.minus = function minus(num)&#123;</span><br><span class="line">    return this - num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JS中创建值的两种方案：不管是哪一种方法创建出来的值，都是所属类的实例</p></blockquote><ul><li>字面量方式</li><li>构造函数方式</li></ul><blockquote><p>基本数据类型值</p></blockquote><ul><li>字面量创建出来的是基本数据类型</li><li>构造函数创建出来的是引用数据类型</li><li>Symbol和BigInt不是构造函数，不能使用new来创建值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let n = 10;</span><br><span class="line">let m = Number(10);</span><br><span class="line">n.toFixed(2);     //=&gt;浏览器在处理基本数据类型值调用原型上方法的时候，内部会见基本类型值变为对象实例模式，再调用</span><br><span class="line">m.toFixed(2);</span><br></pre></td></tr></table></figure><h3 id="Number、String、Boolean以及Date的原始值"><a href="#Number、String、Boolean以及Date的原始值" class="headerlink" title="Number、String、Boolean以及Date的原始值"></a>Number、String、Boolean以及Date的原始值</h3><blockquote><p>对象+数值：大部分情况下会变成字符串拼接，除 {}+num 及 当前对象有原始值<code>[[PrimitiveValue]]</code></p></blockquote><ul><li>将对象转化成数字，首先是调用一个对象的<code>Symbol.toPrimitive</code>属性，如果没有这个属性则调用valueOf来获取实例的原始值（number、string、boolean、Date），如果有原始值，则直接获取到原始值的结果，并将获取到的结果参与到后续运算</li><li>如果没有原始值，则继续调用toString先转换为字符串，后续再基于Number转换为数字</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解读Promise，承诺模式</title>
      <link href="/2020/09/11/2020-09-11-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBPromise%EF%BC%8C%E6%89%BF%E8%AF%BA%E6%A8%A1%E5%BC%8F-md/"/>
      <url>/2020/09/11/2020-09-11-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBPromise%EF%BC%8C%E6%89%BF%E8%AF%BA%E6%A8%A1%E5%BC%8F-md/</url>
      
        <content type="html"><![CDATA[<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><blockquote><p>Promise是ES6中新增的内置类：承诺模式，主要作用是用来规划异步编程的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * let p1 = new Promise([executor])</span><br><span class="line"> *  + Promise 是一个内置类</span><br><span class="line"> *  + p1 是类的一个实例</span><br><span class="line"> *  + [executor] 可执行的回调函数（必须传递）</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>回调地狱:</strong> 回调函数嵌套回调函数</p><blockquote><p>回调函数：把一个函数作为值，传递给另一个函数，在另一个函数执行的时候，再把传递进来的函数进行处理</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 基于JQ中的$.ajax从服务器中获取数据</span><br><span class="line">// 当多个请求之间有相互依赖的关系时，上一个请求完成才能执行下一个请求，“AJAX串行”</span><br><span class="line">// 回调地狱</span><br><span class="line"></span><br><span class="line">let data = &#123;&#125;;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &apos;/api/info&apos;,</span><br><span class="line">    success: function (result) &#123;</span><br><span class="line">        // 获取数据成功后执行回调函数</span><br><span class="line">        // result就是从服务器获取的结果</span><br><span class="line">        data = result;</span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: `/api/score?id=$&#123;data.id&#125;`,</span><br><span class="line">            success: function (result) &#123;</span><br><span class="line"></span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: `/api/paiming?val=$&#123;result.chinese&#125;`,</span><br><span class="line">                    success: function (result) &#123;</span><br><span class="line">                </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// ajax从服务器中获取数据通常是异步的，他也可以是同步的</span><br></pre></td></tr></table></figure><blockquote><p>基于Promise和async/await解决回调地狱的问题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">function queryInfo() &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &apos;/api/info&apos;,</span><br><span class="line">            success: function (result) &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function queryScore(id) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: `/api/score?id=$&#123;id&#125;`,</span><br><span class="line">            success: function (result) &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function queryPaiMing(val) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: `/api/paiming?val=$&#123;val&#125;`,</span><br><span class="line">            success: function (result) &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基于Promise解决回调地狱</span><br><span class="line">queryInfo().then(result =&gt; &#123;</span><br><span class="line">    return queryScore(result.id);</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">    return queryPaiMing(result.chinese);</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">    // 获取的排名信息</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 基于async/await看起来更舒服一些</span><br><span class="line">(async function () &#123;</span><br><span class="line">    let result = await queryInfo();</span><br><span class="line">    result = await queryScore(result.id);</span><br><span class="line">    result = await queryPaiMing(result.chinese);</span><br><span class="line">    // 获取的排名信息</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="promise是异步的？"><a href="#promise是异步的？" class="headerlink" title="promise是异步的？"></a>promise是异步的？</h3><blockquote><p>如果Promise是异步的，那么下面的例子中执行的结果就是 “2 1” ,但是执行结果却是”1 2”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;1&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;2&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>从上述代码我们可以总结出，<code>Promise本身是同步的</code>，但是他是用来<code>管理异步编程</code>的，new Promise的时候会<code>立即将executor函数执行</code></p></blockquote><p>那为什么有些人会认为Promise是异步的呢？</p><blockquote><p>我们将p1在控制台中打印出来，会发现这个Promise实例上除了原型链之外还有两个私有属性，分别是[[PromiseState]]以及[[PromiseResult]]</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/1fedd4d0-f368-11ea-8a36-ebb87efcf8c0.jpg"><p><strong>实例属性</strong></p><ul><li><code>[[PromiseState]]</code>:用于存储Promise实例状态<ul><li>pending 初始状态</li><li>fulfilled/resolved 成功状态（一般指的是异步请求成功，在不同浏览器版本中，成功返回的值不同，但是不会影响结果）</li><li>rejected 失败状态（一般指的是异步请求失败）</li></ul></li><li><code>[[PromiseResult]]</code>:Promise结果或者值<ul><li>初始值是undefined</li><li>不论成功的结果还是失败的原因都会存储在这个值里面</li></ul></li></ul><p><strong>executor接收的回调函数</strong></p><ul><li>第一个参数：<code>resolve函数</code>–函数执行会修改Promise实例的状态为成功（fulfilled/resolve）</li><li>第二个参数：<code>reject函数</code>–函数执行会修改Promise实例的状态为失败（reject）</li><li>通常在executor函数中管理一个异步操作，异步操作成功执行resolve函数，让实例状态修改成成功，并且获取成功的结果；异步操作失败，执行reject函数，让实例状态修改成失败，并获取失败原因</li><li>只要Promise实例的状态从pending变为fulfilled或者rejected,则状态就不能再改变了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(10)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/074b14c0-f36c-11ea-8bd0-2998ac5bbf7e.jpg"><h4 id="Promise-prototype"><a href="#Promise-prototype" class="headerlink" title="Promise.prototype"></a>Promise.prototype</h4><ul><li><code>then([A],[B])</code>：基于then方法存放两个回调函数A/B，当Promise状态为成功时执行A，状态为失败时执行B，并将<code>[[PromiseResult]]</code>的值传递给对应函数</li><li><code>catch</code></li><li><code>finally</code></li></ul><p><strong><code>then</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">   resolve(&apos;OK&apos;)</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(result=&gt;&#123;</span><br><span class="line">    console.log(`成功--$&#123;result&#125;`);</span><br><span class="line">&#125;,reason=&gt;&#123;</span><br><span class="line">    console.log(`失败--$&#123;result&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>then方法也是同步操作，但是then的callback函数是异步的，then方法执行可以理解为将then中的callback函数存储在p1实例中，在Promise中resolve函数执行之后会通知存储在p1实例中对应的方法执行</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/e19c85d0-f3f5-11ea-8ff1-d5dcf8779628.png"><blockquote><p>执行then方法会返回一个新的Promise实例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">   setTimeout(()=&gt;&#123;</span><br><span class="line">        let ran = Math.random();</span><br><span class="line">        ran &lt; 0.5 ? reject(&quot;NO&quot;) : resolve(&quot;OK&quot;);</span><br><span class="line">   &#125;,1000);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = p1.then(A=&gt;&#123;</span><br><span class="line">    console.log(`成功--$&#123;A&#125;`);</span><br><span class="line">    return A + &quot;1&quot;</span><br><span class="line">&#125;,B=&gt;&#123;</span><br><span class="line">    console.log(`失败--$&#123;B&#125;`);</span><br><span class="line">    return B + &quot;0&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>执行then方法是为了将当前实例成功执行的A,失败执行的B存储起来</li><li>同时返回一个新的Promise实例 p2<ul><li>新实例p2的状态是由上一个实例基于then方法存放的A/B函数所决定</li><li>不论是A还是B执行，只要执行不报错，则p2的状态都是成功，只要报错状态就是失败</li><li>p2的结果是A/B函数执行的返回值，或者是报错的失败原因</li><li><strong>特殊情况</strong>：如果A/B返回的是一个新的Promise实例，则返回的Promise实例的成功失败以及结果，直接决定p2的状态和结果</li></ul></li><li>p1的成功和失败也会收到executor执行是否报错影响，执行报错，则p1的状态是失败的，PromiseResult的值就是失败的原因；如果执行不报错，再看执行的是resolve还是reject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // resolve(10);         //=&gt;执行resolve函数时输出  10  100  1000</span><br><span class="line">    reject(20);             //=&gt;执行reject函数时的输出  20  2  20</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">    console.log(`成功了 -&gt; $&#123;result&#125;`);</span><br><span class="line">    return result * 10;</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">    console.log(`失败了 -&gt; $&#123;reason&#125;`);</span><br><span class="line">    return reason / 10;</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">    console.log(`成功了 -&gt; $&#123;result&#125;`);</span><br><span class="line">    return Promise.reject(result * 10);</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">    console.log(`失败了 -&gt; $&#123;reason&#125;`);</span><br><span class="line">    return reason / 10;</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">    console.log(`成功了 -&gt; $&#123;result&#125;`);</span><br><span class="line">    return result * 10;</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">    console.log(`失败了 -&gt; $&#123;reason&#125;`);</span><br><span class="line">    return reason / 10;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>resolve函数执行时会一直执行then中传入的第一个函数，而reject函数执行的时候将Promise实例的状态修改成失败，所以在第一个then中会执行传入的第二个函数，而第二个函数没有报错，则会直接将新的Promise实例的状态修改成成功，而后的所有then方法都是执行传入的第一个callback</p></blockquote><p><strong>Promise的顺延</strong></p><blockquote><p>then([A],[B]):如果其中一个函数没有传递，则会<code>顺延</code>，即[A]函数没有传递则顺着then链找下一个then的[A];，即[B]函数没有传递则顺着then链找下一个then的[B];</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(10).then(null, reason =&gt; &#123;</span><br><span class="line">    console.log(`失败了 -&gt; $&#123;reason&#125;`);</span><br><span class="line">    return reason / 10;</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">    console.log(`成功了 -&gt; $&#123;result&#125;`);     //=&gt; 成功了 -&gt; 10</span><br><span class="line">    return result * 10;</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">    console.log(`失败了 -&gt; $&#123;reason&#125;`);</span><br><span class="line">    return reason / 10;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>当then中[A]没有传递，他会默认 result=&gt;{ return result; },当then中[B]没有传递，他会默认 reason=&gt;{ return Promise.reject(reason); }</p></blockquote><p><strong><code>catch</code></strong></p><blockquote><p>明白了顺延之后,catch就相当于 then( null , reason=&gt;{ … } )，也就是then不传第一个参数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 真实项目中：then只是处理成功的  catch处理失败(一般写在最后)</span><br><span class="line">Promise.reject(10).then(result =&gt; &#123;</span><br><span class="line">    console.log(`成功了 -&gt; $&#123;result&#125;`);</span><br><span class="line">&#125;).catch(reason =&gt; &#123;</span><br><span class="line">    console.log(`失败了 -&gt; $&#123;reason&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>在then链中只要报错的位置，和catch之间的then中没有传递第二个callback，都会直接将错误的原因顺延到catch，所以我们在真实项目中一般不会在then中传递第二个callback，防止传递之后将异常拦截，造成后期没必要的麻烦</p></blockquote><p><strong>返回失败但是没有失败处理</strong></p><blockquote><p>浏览器会在控制台报错，但是该错误不会阻塞代码的执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(10).then(result=&gt;&#123;</span><br><span class="line">    console.log(`成功了--$&#123;result&#125;`);</span><br><span class="line">    return result * 10;</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure><blockquote><p>直接在then链的尾部加一个catch(reson=&gt;{})就可以解决这个报错</p></blockquote><h4 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a>Promise的静态方法</h4><ul><li><code>resolve</code> 返回一个状态为成功的Promise实例</li><li><code>reject</code> 返回一个状态为失败的Promise实例</li><li><code>all</code> 管理多个promise实例<ul><li>当所有实例都为成功，Promise.all返回的总状态的实例才是成功的，结果是一个数组，按照顺序依次存储每一个实例成功的结果</li><li>当有一个实例的结果是失败的，总实例的结果也是失败的，结果是当前实例失败的原因</li></ul></li><li><code>race</code> 管理多个promise实例，以返回运行最快的那个实例的结果，不过是成功还是失败</li></ul><h3 id="实现-Promise-A"><a href="#实现-Promise-A" class="headerlink" title="实现 Promise A+"></a>实现 Promise A+</h3><blockquote><p>简易版的MyPromise</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">function MyPromise(executor)&#123;</span><br><span class="line">    //验证传入的executor是否为一个函数</span><br><span class="line">    if(typeof executor !== &quot;function&quot;) throw new TypeError(&quot;myPromise resolver undefined is not a function&quot;);</span><br><span class="line">    </span><br><span class="line">    //实例上挂载的属性</span><br><span class="line">    this.MyPromiseState = &quot;pending&quot;;</span><br><span class="line">    this.MyPromiseValue = undefined;</span><br><span class="line">    this.resolveFunc = function resolveFunc()&#123;&#125;;</span><br><span class="line">    this.rejectFunc = function rejectFunc()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var _this = this;</span><br><span class="line">    var change = function change(state,value)&#123;</span><br><span class="line">        //实例的状态不为pending的时候才修改状态</span><br><span class="line">        if(_this.MyPromiseState !== &quot;pending&quot;) return;</span><br><span class="line">        _this.MyPromiseState = state;</span><br><span class="line">        _this.MyPromiseValue = value;</span><br><span class="line">        let timer = setTimeout(()=&gt;&#123;</span><br><span class="line">            _this.MyPromiseState === &quot;fulfilled&quot; ?</span><br><span class="line">            _this.resolveFunc(_this.MyPromiseValue):</span><br><span class="line">            _this.rejectFunc(_this.MyPromiseValue);</span><br><span class="line">        &#125;,0)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var resolve = function resolve(result)&#123;</span><br><span class="line">        change(&quot;fulfilled&quot;,result);</span><br><span class="line">    &#125;;</span><br><span class="line">    var reject = function reject(reson)&#123;</span><br><span class="line">        change(&quot;rejected&quot;,reson);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        executor(resolve,reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype = &#123;</span><br><span class="line">    constructor: MyPromise,</span><br><span class="line">    then:function then(resolveFunc,rejectFunc)&#123;</span><br><span class="line">        if(typeof resolveFunc !== &quot;function&quot;)&#123;</span><br><span class="line">            resolveFunc = function resolveFunc(result)&#123;</span><br><span class="line">                return MyPromise.resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof rejectFunc !== &quot;function&quot;)&#123;</span><br><span class="line">            rejectFunc = function rejectFunc(reason)&#123;</span><br><span class="line">                return MyPromise.reject(reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.resolveFunc = resolveFunc;</span><br><span class="line">        this.rejectFunc = rejectFunc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.resolve = function resolve(result)&#123;</span><br><span class="line">    return new MyPromise(resolve=&gt;&#123;</span><br><span class="line">        resolve(result);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.reject = function reject(reason)&#123;</span><br><span class="line">    return new MyPromise((_,reject)=&gt;&#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述的代码已经实现了Promise的基本的逻辑，但是还没有实现连续的<code>.then</code>调用，下面着重的来实现then链的原理</p></blockquote><p>上述的代码没有实现then链的效果是由于，我们then内部的代码在执行的时候没有返回一个Promise实例，所以我们需要保证每次then中的代码执行返回的是一个Promise实例。</p><p>需求分析：</p><ul><li>每一次执行then方法都会返回一个新的Promise实例</li><li>上一个Promise实例的resolve/reject的执行，控制新返回的实例的成功和失败 </li></ul><p>问题：</p><ul><li>上一个Promise执行执行then预设的代码是异步的，而我们返回的新的Promise实例是同步的</li><li>函数执行发生在定时器里面，返回新的Promise实例发生在then中，两个函数毫无关系，怎么让定时器通知then返回实例的状态</li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/7a42e7c0-0bc5-11eb-8a36-ebb87efcf8c0.png"><blockquote><p>为了解决上述问题，可以用函数包装的方式实现</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/d4496970-0c50-11eb-b680-7980c8a877b8.png"><p><strong>改写then方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype = &#123;</span><br><span class="line">    constructor: MyPromise,</span><br><span class="line">    then:function then(resolveFunc,rejectFunc)&#123;</span><br><span class="line">        //实现顺延效果</span><br><span class="line">        if(typeof resolveFunc !== &quot;function&quot;)&#123;</span><br><span class="line">            resolveFunc = function resolveFunc(result)&#123;</span><br><span class="line">                return MyPromise.resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof rejectFunc !== &quot;function&quot;)&#123;</span><br><span class="line">            rejectFunc = function rejectFunc(reason)&#123;</span><br><span class="line">                return MyPromise.reject(reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // this.resolveFunc = resolveFunc;</span><br><span class="line">        // this.rejectFunc = rejectFunc;</span><br><span class="line"></span><br><span class="line">        return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">             //执行不报错，返回新实例的状态是成功的（如果返回值是新Promise实例，则该实例的状态的成功和失败决定了返回实例的状态）</span><br><span class="line">             _this.resolveFunc = function(result)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    var x = resolveFunc(result);</span><br><span class="line">                    x instanceof Promise ?</span><br><span class="line">                        x.then(resolve,reject) :</span><br><span class="line">                        resolve(x);</span><br><span class="line">                &#125; catch (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _this.rejectFunc = function(reason)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    var x = rejectFunc(reason);</span><br><span class="line">                    x instanceof Promise ?</span><br><span class="line">                        x.then(resolve,reject) :</span><br><span class="line">                        resolve(x);</span><br><span class="line">                &#125; catch (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他方法的实现"><a href="#其他方法的实现" class="headerlink" title="其他方法的实现"></a>其他方法的实现</h4><blockquote><p>catch</p></blockquote><p>catch就相当于 xxx.catch([function]) =&gt; xxx.then(null,[function])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype = &#123;</span><br><span class="line">    constructor: MyPromise,</span><br><span class="line">    then:function then(resolveFunc,rejectFunc)&#123;&#125;,</span><br><span class="line">    catch:function catch(rejectFunc)&#123;</span><br><span class="line">        return this.then(null,rejectFunc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MyPromise.all</p></blockquote><p>MyPromise.all返回的也是MyPromise实例p</p><ul><li>数组中的每个MyPromise实例都是成功的，最后p才是成功的</li><li>数组中只要有一个实例是失败的，最后p都是失败的</li><li>如果最后都是成功，p的MyPromiseValue存储的也是一个数组：按照之前存放MyPromise实例的顺序，存储每一个实例的结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.all = function all(promiseAry)&#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        var results = [],   //存储结果</span><br><span class="line">            index = 0;      //成功计数</span><br><span class="line">            </span><br><span class="line">        var fire()&#123;</span><br><span class="line">            if(index &gt;= promiseAry.length)&#123;</span><br><span class="line">                resolve(results)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(var i = 0; i &lt; promiseAry.length ; i++)&#123;</span><br><span class="line">            var item = promiseAry[i];</span><br><span class="line">            if(!(item instanceof Promise))&#123;</span><br><span class="line">                results[i] = item;</span><br><span class="line">                index++;</span><br><span class="line">                fire();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item.then(function(result)&#123;</span><br><span class="line">            results[i] = result;</span><br><span class="line">            index++;</span><br><span class="line">            fire();</span><br><span class="line">        &#125;,function(reason)&#123;</span><br><span class="line">            //只要一个函数是失败的则整体是失败的</span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    // 构造函数</span><br><span class="line">    function MyPromise(executor) &#123;</span><br><span class="line">        if (typeof executor !== &quot;function&quot;) throw new TypeError(&apos;MyPromise resolver undefined is not a function&apos;);</span><br><span class="line"></span><br><span class="line">        // 每一个MyPromise实例应该具备这几个属性</span><br><span class="line">        this.MyPromiseState = &quot;pending&quot;;</span><br><span class="line">        this.MyPromiseValue = undefined;</span><br><span class="line">        this.resolveFunc = function () &#123;&#125;;</span><br><span class="line">        this.rejectFunc = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        // 修改它的状态/值，并且通知指定的方法执行</span><br><span class="line">        var _this = this;</span><br><span class="line">        var change = function change(state, value) &#123;</span><br><span class="line">            if (_this.MyPromiseState !== &quot;pending&quot;) return;</span><br><span class="line">            _this.MyPromiseState = state;</span><br><span class="line">            _this.MyPromiseValue = value;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                state === &quot;fulfilled&quot; ?</span><br><span class="line">                    _this.resolveFunc(_this.MyPromiseValue) :</span><br><span class="line">                    _this.rejectFunc(_this.MyPromiseValue);</span><br><span class="line">            &#125;, 0);</span><br><span class="line">        &#125;;</span><br><span class="line">        var resolve = function resolve(result) &#123;</span><br><span class="line">            change(&apos;fulfilled&apos;, result);</span><br><span class="line">        &#125;;</span><br><span class="line">        var reject = function reject(reason) &#123;</span><br><span class="line">            change(&apos;rejected&apos;, reason);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">            change(&apos;rejected&apos;, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构造函数原型</span><br><span class="line">    MyPromise.prototype = &#123;</span><br><span class="line">        constructor: MyPromise,</span><br><span class="line">        then: function (resolveFunc, rejectFunc) &#123;</span><br><span class="line">            var _this = this;</span><br><span class="line"></span><br><span class="line">            // 参数不传递：顺延</span><br><span class="line">            if (typeof resolveFunc !== &quot;function&quot;) &#123;</span><br><span class="line">                resolveFunc = function resolveFunc(result) &#123;</span><br><span class="line">                    return MyPromise.resolve(result);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (typeof rejectFunc !== &quot;function&quot;) &#123;</span><br><span class="line">                rejectFunc = function rejectFunc(reason) &#123;</span><br><span class="line">                    return MyPromise.reject(reason);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 每一次执行THEN方法都会返回一个新的MyPromise实例</span><br><span class="line">            //   + resolve/reject 是控制新返回实例的成功和失败的</span><br><span class="line">            //   + 把传递进来的需要执行的A:resolveFunc/B:rejectFunc进行包装处理</span><br><span class="line">            return new MyPromise(function (resolve, reject) &#123;</span><br><span class="line">                _this.resolveFunc = function (result) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 执行不报错，则新返回的实例是成功的（特殊：方法返回的是一个新的MyPromise实例，则新实例的状态和结果决定返回实例的状态和结果）</span><br><span class="line">                        var x = resolveFunc(result);</span><br><span class="line">                        x instanceof MyPromise ?</span><br><span class="line">                            x.then(resolve, reject) :</span><br><span class="line">                            resolve(x);</span><br><span class="line">                    &#125; catch (err) &#123;</span><br><span class="line">                        // 执行报错，则新返回的实例是失败的</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                _this.rejectFunc = function (reason) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        var x = rejectFunc(reason);</span><br><span class="line">                        x instanceof MyPromise ?</span><br><span class="line">                            x.then(resolve, reject) :</span><br><span class="line">                            resolve(x);</span><br><span class="line">                    &#125; catch (err) &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        catch: function (rejectFunc) &#123;</span><br><span class="line">            // xxx.catch([function]) =&gt; xxx.then(null,[function])</span><br><span class="line">            return this.then(null, rejectFunc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 普通对象</span><br><span class="line">    MyPromise.resolve = function resolve(result) &#123;</span><br><span class="line">        return new MyPromise(function (resolve) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    MyPromise.reject = function reject(reason) &#123;</span><br><span class="line">        return new MyPromise(function (_, reject) &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    MyPromise.all = function all(promiseArr) &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        return new MyPromise(function (resolve, reject) &#123;</span><br><span class="line">            var index = 0, //记数</span><br><span class="line">                results = []; //结果集合</span><br><span class="line"></span><br><span class="line">            // 都成功后控制返回的实例也是成功</span><br><span class="line">            var fire = function () &#123;</span><br><span class="line">                if (index &gt;= promiseArr.length) &#123;</span><br><span class="line">                    resolve(results);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            // 循环依次处理每一个实例</span><br><span class="line">            for (var i = 0; i &lt; promiseArr.length; i++) &#123;</span><br><span class="line">                // 基于闭包机制存放每一轮循环的索引</span><br><span class="line">                (function (i) &#123;</span><br><span class="line">                    var item = promiseArr[i];</span><br><span class="line">                    if (!(item instanceof MyPromise)) &#123;</span><br><span class="line">                        results[i] = item;</span><br><span class="line">                        index++;</span><br><span class="line">                        fire();</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    item.then(function (result) &#123;</span><br><span class="line">                        results[i] = result;</span><br><span class="line">                        index++;</span><br><span class="line">                        fire();</span><br><span class="line">                    &#125;).catch(function (reason) &#123;</span><br><span class="line">                        // 只要有一个是失败的，整体都是失败的</span><br><span class="line">                        reject(reason);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;)(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 让其支持浏览器导入和CommonJS/ES6Module模块导入规范</span><br><span class="line">    if (typeof window !== &quot;undefined&quot;) &#123;</span><br><span class="line">        window.MyPromise = MyPromise;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) &#123;</span><br><span class="line">        module.exports = MyPromise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义类的原型重定向</title>
      <link href="/2020/09/09/2020-09-09-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%87%8D%E5%AE%9A%E5%90%91-md/"/>
      <url>/2020/09/09/2020-09-09-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%87%8D%E5%AE%9A%E5%90%91-md/</url>
      
        <content type="html"><![CDATA[<h3 id="原型重定向的弊端"><a href="#原型重定向的弊端" class="headerlink" title="原型重定向的弊端"></a>原型重定向的弊端</h3><blockquote><p>为什么要原型重定向？为了方便我们批量给原型拓展属性和方法</p></blockquote><p>原型重定向带来的问题</p><ul><li>新定向的原型对象上，没有constructor属性，结构不完善</li><li>浏览器默认生成的原型对象会因为缺少引用而被释放掉，可能会导致原始加入的属性和方法丢失掉</li><li>内置对象是不允许被重定向的，防止把内置对象的方法丢失</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Fn()&#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.getX = function()&#123;&#125;;</span><br><span class="line">Fn.prototype = &#123;        //重定向的新对象，没有constructor，也没有getX了</span><br><span class="line">    getY:function()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let f1 = new Fn;</span><br></pre></td></tr></table></figure><blockquote><p>上述函数中，先在原型上添加了getX方法，然后再Fn.prototype = { }，使得原型重定向了，原先给原型添加的方法会丢失。</p></blockquote><p>那原型重定向给我们带来了这么多弊端，那我们为什么还要做原型重定向呢？</p><h3 id="给原型批量添加方法"><a href="#给原型批量添加方法" class="headerlink" title="给原型批量添加方法"></a>给原型批量添加方法</h3><blockquote><p>通常我们为原型添加方法会选用以下方式来添加，但是，当我们需要添加的属性和方法比较多时，这种方法会显得计较繁琐，因为每添加一个都要加上Fn.prototype</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Fn()&#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.getX = function()&#123;&#125;;</span><br><span class="line">Fn.prototype.getY = function()&#123;&#125;;</span><br><span class="line">Fn.prototype.getZ = function()&#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>笔者也在很多的插件源码中看到别人用下述方法来添加，但是，这种方式始终是治标不治本,只是视觉上的代码减少</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fn()&#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">let A = Fn.prototype</span><br><span class="line">A.getX = function()&#123;&#125;;</span><br><span class="line">A.getY = function()&#123;&#125;;</span><br><span class="line">A.getZ = function()&#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在这里我推荐使用Object.assign()合并对象的方式来做原型重定向,这种方式不但解决了重定向原型上没有constructor属性的问题，同时在重定向之前给原型添加的属性和方法都会保存下来。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Fn()&#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fn.prototype.z = 300;</span><br><span class="line">Fn.prototype = Object.assign(Fn.prototype,&#123;</span><br><span class="line">    getX()&#123;&#125;,</span><br><span class="line">    getY()&#123;&#125;,</span><br><span class="line">    getZ()&#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>内置类的原型是不允许操作的，所以assign函数不能操作内置类</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new函数在执行时做了什么</title>
      <link href="/2020/09/05/2020-09-05-new%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88-md/"/>
      <url>/2020/09/05/2020-09-05-new%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88-md/</url>
      
        <content type="html"><![CDATA[<h3 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h3><blockquote><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*  基本语法</span><br><span class="line"> *  new constructor[([arguments])]</span><br><span class="line"> *  pramas:</span><br><span class="line"> *  [constructor]  一个指定对象实例的类型的类或函数</span><br><span class="line"> *  [arguments]    一个用于被 constructor 调用的参数列表</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> /* 函数执行时</span><br><span class="line">  * + new fn()    优先级 19</span><br><span class="line">  * + new fn      优先级 18</span><br><span class="line">  * 上述两种new执行的方式，fn都会执行，而且都会创建自己的实例。他们的区别是，是否传递参数以及优先级的不同。</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="new执行函数"><a href="#new执行函数" class="headerlink" title="new执行函数"></a>new执行函数</h3><blockquote><p>以以下函数执行为例，对比普通函数执行和通过new方法执行时的区别</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum(x,y)&#123;</span><br><span class="line">    let totle = x + y;</span><br><span class="line">    this.total = total;</span><br><span class="line">    return total;</span><br><span class="line">&#125;</span><br><span class="line">let res = sum(10,20);</span><br><span class="line">console.log(res);</span><br><span class="line">let res1 = new sum(10,20);</span><br><span class="line">console.log(res1);</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/9c0e92c0-ee95-11ea-9dfb-6da8e309e0d8.png"><blockquote><p>对比普通函数执行和通过new操作当做构造函数来执行，可以总结出new执行时做了什么</p></blockquote><ol><li>和普通函数执行一样，形成执行上下文EC、AO、作用域链…</li><li>new函数执行，会在函数执行之前，创建一个对象</li><li>在初始化this的阶段，会让this指向刚刚创建的对象</li><li>在代码执行阶段，遇到this.xxx = xxx,都是给实例对象设置的“私有”属性方法</li><li>return的时候，检测返回值，如果没有返回值或者返回值是一个原始数据类型则放回我们刚刚创建的对象；如果有返回值并且返回的事宜个引用数据类型，则返回该引用类型数据</li></ol><h3 id="重写new函数"><a href="#重写new函数" class="headerlink" title="重写new函数"></a>重写new函数</h3><blockquote><p>对比了普通函数和new函数执行时的区别，总结出new函数执行时的一些特点，然后就可以尝试着重写new函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  Func[function]:类</span><br><span class="line"> *  params[array]:基于剩余运算符获取传递的实参，都是给类传递的实参</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function _new(Func,...params)&#123;</span><br><span class="line">    //创建实例对象</span><br><span class="line">    let obj = &#123;&#125;；</span><br><span class="line">    obj.__proto__ = Func.prototype;</span><br><span class="line">    //将类作为一个普通函数执行，基于call方法强制改变上下文中this的指向，将this指向新创建的实例对象obj</span><br><span class="line">    let result = Func.call(obj,...pramas);</span><br><span class="line">    //当返回结果为引用数据类型时，则直接返回该返回值，否则返回实例对象obj</span><br><span class="line">    if(result !== null &amp;&amp; /^object|function$/i.test(typeof result)) return result;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><blockquote><p>IE浏览器中的<strong>proto</strong>是被保护起来的，所以这里可以使用Object.create([对象])，来进行重写。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  Object.create([对象A]):创建一个空对象，并将对象A作为他的原型 即 空对象.__proto__ === 对象A</span><br><span class="line"> */</span><br><span class="line">function _new(Func,...params)&#123;</span><br><span class="line">    let obj = obj.craete(Func.prototype);</span><br><span class="line">    let result = Func.call(obj,...pramas);</span><br><span class="line">    </span><br><span class="line">    if(result !== null &amp;&amp; /^object|function$/i.test(typeof result)) return result;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>create()函数的值必须要传.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.create());       //Uncaught TypeError: Object prototype may only be an Object or null: undefined</span><br><span class="line">console.log(Object.create(null));   //创建一个空对象，但是对象的__proto__等于null,所以该对象不是任何类的实例</span><br></pre></td></tr></table></figure><p><strong>实现Object.create()方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object.create = function create(obj)&#123;</span><br><span class="line">    if(obj===null || typeof obj !== &apos;object&apos;)&#123;</span><br><span class="line">        throw new TypeError(&apos;Object prototype may only be an Object&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function Amonyous()&#123;&#125;</span><br><span class="line">    Amonyous.prototype = obj;</span><br><span class="line">    return new Amonyous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型和原型链</title>
      <link href="/2020/09/04/2020-09-04-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-md/"/>
      <url>/2020/09/04/2020-09-04-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-md/</url>
      
        <content type="html"><![CDATA[<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><blockquote><p>1.所有类都是函数数据类型（包含内置类）</p></blockquote><ul><li>所有函数都天生自带一个属性：prototype 原型（显示原型）</li><li>prototype的属性值默认是一个对象数据类型【堆】</li><li>在对象中存储的是供实例调用的所有公共属性和方法</li><li>并且在类的原型对象上默认有个属性：constructor构造函数，属性值是当前类本身</li></ul><a id="more"></a><blockquote><p>所有对象数据类型值也天生自带一个属性：__proto__ 原型链（隐式原型）</p></blockquote><ul><li>__proto__属性的属性值：当前实例所属类的原型prototype，即=&gt; 实例.__proto__ === 类.prototype</li><li>对象数据类型的值有哪些<ul><li>普通对象、数组对象、正则对象、日期对象、类数组对象、DOM对象…</li><li>大部分实例也是对象数据类型（除一些基本数据类型）</li><li>类的原型prototype也是对象类型</li><li>函数也是对象–“函数的三种角色”</li><li>… （JS中万物皆对象）</li></ul></li></ul><blockquote><p>通过下面的例子分析原型、类、实例之间的关系</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Fn()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 200;</span><br><span class="line">    this.getX = function()&#123;</span><br><span class="line">        console.log(this.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.getX = function()&#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.getY = function()&#123;</span><br><span class="line">    console.log(this.y);</span><br><span class="line">&#125;</span><br><span class="line">let f1 = new Fn;</span><br><span class="line">let f2 = new Fn;</span><br><span class="line">console.log(f1.getX === f2.getX);</span><br><span class="line">console.log(f1.getY === f2.getY);</span><br><span class="line">console.log(f1.__proto__.getY === Fn.prototype.getY);</span><br><span class="line">console.log(f1.__proto__.getX === f2.getX);</span><br><span class="line">console.log(f1.getX === Fn.prototype.getX);</span><br><span class="line">console.log(f1.constructor);</span><br><span class="line">console.log(Fn.prototype.__proto__.constructor);</span><br><span class="line">f1.getX();</span><br><span class="line">f1.__proto__.getX();</span><br><span class="line">f2.getY();</span><br><span class="line">Fn.prototype.getY();</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/8ed06ee0-ee8f-11ea-b244-a9f5e5565f30.png"><blockquote><p>通过这个例子，可以总结出原型链具有以下特点：</p></blockquote><ul><li>函数执行时，用到某个属性，首先看是否是自己的私有属性，如果是自己的私有属性，那么久操作自己的私有属性</li><li>如果不是自己的私有属性，会默认基于__proto__找所属类的原型上的公共属性和方法</li><li>如果所属类的原型上也没有，则继续基于原型__proto__继续向上查找，直到找到Object.prototype上为止</li><li>这就是我们所说的原型链的查找机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包的高阶应用</title>
      <link href="/2020/08/29/2020-08-29-%E9%97%AD%E5%8C%85%E7%9A%84%E9%AB%98%E9%98%B6%E5%BA%94%E7%94%A8-md/"/>
      <url>/2020/08/29/2020-08-29-%E9%97%AD%E5%8C%85%E7%9A%84%E9%AB%98%E9%98%B6%E5%BA%94%E7%94%A8-md/</url>
      
        <content type="html"><![CDATA[<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><blockquote><p>在没有对象和函数情况下，编写代码，会出现<code>全局变量污染</code>,为了防止全局变量污染，我们可以使用以下方法来处理。</p></blockquote><p><strong>方案一： 闭包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//利用闭包的保护机制</span><br><span class="line">(function()&#123;</span><br><span class="line">    let name = &quot;张三&quot;；</span><br><span class="line">    let age = 21;</span><br><span class="line">    let sex = &quot;男&quot;；</span><br><span class="line">&#125;)()；</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>方案二： 对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//利用对象的分组功能，把描述同一事物的属性和方法放置在相同的堆内存空间中</span><br><span class="line">let person1 = &#123;</span><br><span class="line">    name:&quot;李四&quot;，</span><br><span class="line">    age:22,</span><br><span class="line">    sex:&quot;男&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例设计模式</strong></p><blockquote><p>在实际开发过程中，我们通常结合<code>闭包保护机制</code>和<code>对象的分组机制</code>，来实现闭包中方法的调用，而这种模式就是我们常说的单例设计模式。单例模式也是最早的模块规范。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let AModule = (function()&#123;</span><br><span class="line">    let name = &quot;张三&quot;；</span><br><span class="line">    function fn()&#123;console.log(1)&#125;;</span><br><span class="line">    function query()&#123;console.log(2)&#125;</span><br><span class="line">    </span><br><span class="line">    // 当我们想把私有的东西暴露给外界使用</span><br><span class="line">    //1. window.xxx = xxx  缺点：当方法暴露过多时，还是会引发全局变量污染</span><br><span class="line">    </span><br><span class="line">    //2. 基于对象分组的特性，把需要暴露的API，都放置在同一堆内存空间下。</span><br><span class="line">    return &#123;</span><br><span class="line">        fn,</span><br><span class="line">        query,</span><br><span class="line">        init()&#123;</span><br><span class="line">            //控制业务逻辑的执行顺序的“控制命令”</span><br><span class="line">            fn();</span><br><span class="line">            query();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)()；</span><br><span class="line"></span><br><span class="line">Amodule.query()     //2</span><br><span class="line">Amodule.fn()        //1</span><br><span class="line">Amodule.init()      //1  2</span><br></pre></td></tr></table></figure><h3 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h3><blockquote><p>能执行一次的，绝对不执行第二次。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getCss(element,attr)&#123;</span><br><span class="line">    if(window.getComputedStyle)&#123;</span><br><span class="line">        return window.getComputedStyle(element)[attr];</span><br><span class="line">    &#125;</span><br><span class="line">    //IE6~8</span><br><span class="line">    return element.currentStyle[attr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getCss(document.body,&apos;width&apos;));</span><br><span class="line">console.log(getCss(document.body,&apos;padding&apos;));</span><br><span class="line">console.log(getCss(document.body,&apos;margin&apos;));</span><br></pre></td></tr></table></figure><blockquote><p>上述函数在第一次执行时，会判断是否兼容，而后的每一次执行方法都会处理兼容。其实，这个操作在第二次执行时就已经没有必要了。</p></blockquote><p><strong>方案一</strong></p><blockquote><p>页面加载时，就把兼容处理了。后期基于变量的返回值即可直接判断</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let isCompatible = &apos;getComputStyle&apos; in window;</span><br><span class="line">function getCss(element,attr)&#123;</span><br><span class="line">    if(isCompatible)&#123;</span><br><span class="line">        return window.getComputedStyle(element)[attr];</span><br><span class="line">    &#125;</span><br><span class="line">    //IE6~8</span><br><span class="line">    return element.currentStyle[attr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案二</strong></p><blockquote><p>惰性思想解决：函数重构</p></blockquote><ul><li>getCss是全局函数</li><li>第一次执行会产生<code>闭包</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getCss(element,attr)&#123;</span><br><span class="line">    if(window.getComputedStlye)&#123;</span><br><span class="line">        //将全局的getCss重构</span><br><span class="line">        getCss = function(element,attr)&#123;</span><br><span class="line">            return window.getComputedStyle(element)[attr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        getCss = function(element,attr)&#123;</span><br><span class="line">            return element.currentStyle[attr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将会重构后的函数执行，确保第一次执行能够获得结果</span><br><span class="line">    return getCss(element,attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getCss(document.body,&apos;width&apos;));</span><br><span class="line">console.log(getCss(document.body,&apos;padding&apos;));      //函数第二次执行，执行重构后的函数，不需要做兼容判断</span><br><span class="line">console.log(getCss(document.body,&apos;margin&apos;));</span><br></pre></td></tr></table></figure><h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><blockquote><p>柯里化函数使用的是<code>预处理思想</code>，应用的也是<code>闭包的机制</code>。在第一次执行大函数，形成一个闭包，把一些信息存储在闭包中（传递的实参或者当前闭包中的声明的一些私有变量等信息），等到后面需要执行内部的匿名函数，在遇到非自己私有变量时，则向上级上下文中查找（也就是把之前存储在闭包中的信息获取）；</p></blockquote><p><strong>例题：</strong> 实现以下函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let res = fn(1,2)(3);</span><br><span class="line">console.log(res);  //=&gt; 6   1+2+3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(...outerArgs)&#123;</span><br><span class="line">    //outerArgs 用于存储外层函数传入的值</span><br><span class="line">    return function(...innerArgs)&#123;</span><br><span class="line">        //innerArgs 用于存储内层函数传入的值</span><br><span class="line">        let arr = [...outerArgs,...innerArgs];</span><br><span class="line">        return arr.reduce(function(total,item)&#123;</span><br><span class="line">            return total + item;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compose组合函数"><a href="#compose组合函数" class="headerlink" title="compose组合函数"></a>compose组合函数</h3><p><strong>例题：</strong> 实现以下函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">    在函数式编程当中有一个很重要的概念就是函数组合， 实际上就是把处理数据的函数像管道一样连接起来， 然后让数据穿过管道得到最终的结果。 例如：</span><br><span class="line">    const add1 = (x) =&gt; x + 1;</span><br><span class="line">    const mul3 = (x) =&gt; x * 3;</span><br><span class="line">    const div2 = (x) =&gt; x / 2;</span><br><span class="line">    div2(mul3(add1(add1(0)))); //=&gt;3</span><br><span class="line"></span><br><span class="line">    而这样的写法可读性明显太差了，我们可以构建一个compose函数，它接受任意多个函数作为参数（这些函数都只接受一个参数），然后compose返回的也是一个函数，达到以下的效果：</span><br><span class="line">    const operate = compose(div2, mul3, add1, add1)</span><br><span class="line">    operate(0) //=&gt;相当于div2(mul3(add1(add1(0)))) </span><br><span class="line">    operate(2) //=&gt;相当于div2(mul3(add1(add1(2))))</span><br><span class="line"></span><br><span class="line">    简而言之：compose可以把类似于f(g(h(x)))这种写法简化成compose(f, g, h)(x)，请你完成 compose函数的编写 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><blockquote><p>借用柯里化函数的思想，先将函数集合以数组的形式存储在外层函数的执行上下文中，再在内层函数中接收参数，并在内层函数中循环执行需要操作的函数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function compose(...args)&#123;</span><br><span class="line">    //args中存储的是需要操作的函数集合，存储在外层函数的上下文中</span><br><span class="line">    return function(val)&#123;</span><br><span class="line">        if(args.lenght === 0) return val;       //没有传函数参数</span><br><span class="line">        if(args.lenght === 1) return args[0](val);       //只传了一个函数参数</span><br><span class="line">        let arr = args.reverse();       //将数组翻转，便于后续操作</span><br><span class="line">        return arr.reduce((N,item)=&gt;&#123;</span><br><span class="line">            return item(N)</span><br><span class="line">        &#125;,val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>redux源码中compose的实现方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function compose(...funcs)&#123;</span><br><span class="line">    if(funcs.lenght === 0)&#123;</span><br><span class="line">        return arg =&gt; arg</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(funcs.lenght === 1)&#123;</span><br><span class="line">        return funcs[0]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return funcs.reduce((a,b)=&gt;(...args)=&gt;a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><blockquote><p>防止用户在短时间内多次触发，导致函数执行多次，函数防抖是指短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func,wait = 300,immediate = false)&#123;</span><br><span class="line">    let timer = null;</span><br><span class="line">    return function(...params)&#123;</span><br><span class="line">        let new = immediate &amp;&amp; !time;</span><br><span class="line">        clearTimeout(timer);            //触发函数清除定时器</span><br><span class="line">        timer = setTimeout(()=&gt;&#123;        //重新设置一个定时器，监听wait时间内是否发生二次触发</span><br><span class="line">            timer = null;       //手动回归到初始状态</span><br><span class="line">            !new? func.call(this,...params):null;</span><br><span class="line">        &#125;,wait)</span><br><span class="line">        </span><br><span class="line">        //immediate=true 执行第一次触发时返回的结果</span><br><span class="line">        new ? func.call(this,...params):null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><blockquote><p>函数节流可以想象成函数的冷却时间，指单位时间内只能执行一次，超过<code>冷却时间</code>才可以再一次执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func,wait = 300)&#123;</span><br><span class="line">    let timer = null,</span><br><span class="line">        previous = 0;       //记录上一次的操作时间</span><br><span class="line">    return function(...params)&#123;</span><br><span class="line">        let now = new Date(),</span><br><span class="line">            remaining = wait - (now - previous);     //记录还差多少时间触发函数</span><br><span class="line">        if(remaining &lt;= 0)&#123;     //两次操作时间间隔超过wait</span><br><span class="line">            window.clearTimeout(timer);</span><br><span class="line">            timer = null;</span><br><span class="line">            previous = new;</span><br><span class="line">            func.call(this,...params);</span><br><span class="line">        &#125;else if(!timer)&#123;       //!timer设置防止重复设置定时器</span><br><span class="line">            //两次操作时间间隔未超过wait,设置定时器，并传入剩余时间remaining</span><br><span class="line">            timer = setTimeout(()=&gt;&#123;</span><br><span class="line">                timer = null;</span><br><span class="line">                previous = new Date();</span><br><span class="line">                func.call(this,...params);</span><br><span class="line">            &#125;,remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this</title>
      <link href="/2020/08/24/2020-08-24-this-md/"/>
      <url>/2020/08/24/2020-08-24-this-md/</url>
      
        <content type="html"><![CDATA[<h3 id="THIS"><a href="#THIS" class="headerlink" title="THIS"></a>THIS</h3><blockquote><p>this:函数的执行主体，和执行上下文不是一个概念</p></blockquote><ul><li>全局的this是window，我们研究的都是函数中的this</li><li>this是谁和函数在哪里执行，以及在哪定义都没有必然联系</li></ul><a id="more"></a><p><strong>判断执行主体的方式：</strong></p><ol><li>给当前元素的某个<code>事件行为绑定方法</code>，<code>事件绑定</code>，<code>执行对应方法</code>，方法中的this是当前元素本身（排除：IE6~8基于attachEvent实现的DOM2事件绑定，绑定的方法中的this不是操作的元素，而是window）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.body.onclik = function()&#123;</span><br><span class="line">    //this:body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数执行，首先看函数名之前是否有‘点’，有‘点’，‘点’前面是谁this就是谁，没有‘点’this就是window（在JS的严格模式下，没有‘点’，方法中的this是undefined）<ul><li>自执行函数中的this一般都是window/undefined</li><li>回调函数中的this一般都是window/undefined（除非特殊处理）</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&apos;xxx&apos;,</span><br><span class="line">    fn:fn</span><br><span class="line">&#125;</span><br><span class="line">fn();       //this:window</span><br><span class="line">obj.fn();   //this:obj</span><br></pre></td></tr></table></figure><ol start="3"><li>构造函数中的this是当前实例</li><li>箭头函数没有自己的this，用到的this都是上下文中的this</li><li>基于call、apple、bind可以强制改变this的指向</li></ol><p><strong>实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    num: 20</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn = (function (num) &#123;</span><br><span class="line">    this.num = num * 3;</span><br><span class="line">    num++;</span><br><span class="line">    return function (n) &#123;</span><br><span class="line">        this.num += n;</span><br><span class="line">        num++;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(obj.num);</span><br><span class="line">var fn = obj.fn;</span><br><span class="line">fn(5);                          //22</span><br><span class="line">obj.fn(10);                     //23</span><br><span class="line">console.log(num, obj.num);      //65  30</span><br></pre></td></tr></table></figure><p>画图分析</p><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/f1f356c0-e5d6-11ea-b244-a9f5e5565f30.png">]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的底层运行机制（堆栈内存）</title>
      <link href="/2020/08/20/2020-08-20-JS%E7%9A%84%E5%BA%95%E5%B1%82%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%88%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%89-md/"/>
      <url>/2020/08/20/2020-08-20-JS%E7%9A%84%E5%BA%95%E5%B1%82%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%88%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%89-md/</url>
      
        <content type="html"><![CDATA[<h3 id="JS的底层运行机制"><a href="#JS的底层运行机制" class="headerlink" title="JS的底层运行机制"></a>JS的底层运行机制</h3><h4 id="JS的运行环境"><a href="#JS的运行环境" class="headerlink" title="JS的运行环境"></a>JS的运行环境</h4><ol><li>浏览器(引擎)</li><li>node(V8引擎)</li><li>webview(V8引擎)</li></ol><a id="more"></a><h4 id="代码执行的环境–ECStack"><a href="#代码执行的环境–ECStack" class="headerlink" title="代码执行的环境–ECStack"></a>代码执行的环境–ECStack</h4><ul><li>ECStack(Execution Context Stack)</li></ul><blockquote><p>ECStack(Execution Context Stack)执行环境栈=&gt;栈内存（从内存条中分配出来的一块内存）</p></blockquote><ul><li><p>EC(Execution context)</p><blockquote><p>在编程语言中，代码执行时，为了区分全局和函数所执行所处的不同的作用域（目的是为了区分每个词法作用域下代码的独立性），浏览器会创建EC(Execution context)执行上下文（代码所在的词法作用域，或代码执行的范围）</p></blockquote></li><li><p>GO(Global Object)</p><blockquote><p>浏览器会将供JS调用的属性和方法存放在GO中（内置对象），浏览器会创建一个名为window的变量指向这个对象。</p></blockquote></li><li><p>VO(Variable Object)</p><blockquote><p>代码执行时，会创建变量，VO就是用来存储这些变量的空间。VO通常用来存储全局变量(因为全局变量一般不释放)，而私有上下文中的变量存储在AO(active object)中，AO是VO的一种(AO活动对象，通常是指的进栈出栈创建比较频繁的对象)。</p></blockquote></li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/525fa4c0-e1ed-11ea-8bd0-2998ac5bbf7e.png"><h4 id="函数的创建和执行"><a href="#函数的创建和执行" class="headerlink" title="函数的创建和执行"></a>函数的创建和执行</h4><blockquote><p>函数创建时，会新建一个堆内存来存储代码块。在函数执行时，会取出存放在堆中的代码，同时创建一个EC（函数的执行上下文）来供代码执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x =[12,23]</span><br><span class="line">function fn(y)&#123;</span><br><span class="line">    y[0] = 100;</span><br><span class="line">    y = [100];</span><br><span class="line">    y[1] = 200;</span><br><span class="line">    console.log(y);</span><br><span class="line">&#125;</span><br><span class="line">fn(x);</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/aa97b860-e212-11ea-8ff1-d5dcf8779628.png"><p><strong>创建函数</strong></p><ol><li>开辟堆内存（16进制得到内存地址）</li><li>声明当前函数的作用域（函数创建的上下文才是他的作用域，和在那执行的无关）</li><li>把函数的代码以字符串的形式存储在堆内存中（函数再不执行的情况下，只是存储在堆内存中的字符串）</li><li>将函数堆的地址，放在栈中供变量调用（函数名）</li></ol><p><strong>执行函数</strong></p><ol><li>会形成一个全新的执行上下文EC(xx)（目的是供函数体中的代码执行），然后进栈（ECStack执行环境栈）执行</li><li>在私有上下文中有一个存放变量的变量对象AO(xx)</li><li>代码执行之前需要做的事<ul><li>初始化作用域链&lt;自己的上下文，函数的作用域&gt;</li><li>初始化this（箭头函数没有this）</li><li>初始化arguments实参集合（箭头函数没有arguments）</li><li>形参赋值（形参变量是函数的私有变量，需要存储在AO中）（<a href="">新版浏览器形参赋值的坑</a>）</li><li>变量提升（在私有上下文中声明的变量都是私有变量）</li><li>……</li></ul></li><li>代码执行（把之前在函数堆中存储的字符串拿过来在当前上下文中执行）</li></ol><blockquote><p>作用域链的查找机制，在代码执行过程中，遇到一个变量，首先查看是否是自己的私有变量，如果是自己的私有变量，就直接操作私有变量，如果不是自己的私有变量，则按照<code>scope-chain</code>,向上级上下文查找，如果上级有则拿过来操作，没有则一直向上查找，直到EC(G)</p></blockquote><ol start="5"><li>根据实际情况判断当前上下文是否出栈释放</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>parseInt的第二个参数</title>
      <link href="/2020/08/19/2020-08-19-parseInt%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0-md/"/>
      <url>/2020/08/19/2020-08-19-parseInt%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>parseInt([value],[radix])</p></blockquote><ul><li>[value]会被解析成字符串</li><li>[radix]表示要解析的数字的基数。该值介于2~36之间。如果radix省略或者传0，则将以10为基数来解析；如果以“0x”开头，以16为基数；如果redix小于2或者大于36，则parseInt()返回NaN。</li></ul><a id="more"></a><p><strong>实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let arr = [10.18,0,10,25,23]</span><br><span class="line">arr = arr.map(parseInt);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * arr = arr.map((item,index)=&gt;&#123;</span><br><span class="line">     //循环遍历数组中的每一项，触发回调函数</span><br><span class="line">     //每一次传递当前项和当前项的索引</span><br><span class="line"> &#125;)</span><br><span class="line"> =&gt;</span><br><span class="line"> parseInt(&apos;10.18&apos;,0)    =&gt;10</span><br><span class="line"> parseInt(&apos;0&apos;,1)        =&gt;NaN</span><br><span class="line"> parseInt(&apos;10&apos;,2)       =&gt;2</span><br><span class="line"> parseInt(&apos;25&apos;,3)       =&gt;2</span><br><span class="line"> parseInt(&apos;23&apos;,4)       =&gt;11</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><blockquote><p>parseFloat不接受第二个参数</p></blockquote><p><strong>参考文献</strong></p><p><a href="https://www.w3school.com.cn/jsref/jsref_parseInt.asp" target="_blank" rel="noopener">W3school</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型转换</title>
      <link href="/2020/08/15/2020-08-15-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-md/"/>
      <url>/2020/08/15/2020-08-15-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-md/</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型转换的核心"><a href="#数据类型转换的核心" class="headerlink" title="数据类型转换的核心"></a>数据类型转换的核心</h3><a id="more"></a><h4 id="把其他数据类型转换成-Number-类型"><a href="#把其他数据类型转换成-Number-类型" class="headerlink" title="把其他数据类型转换成 Number 类型"></a>把其他数据类型转换成 Number 类型</h4><p><strong>1. 特定需要转换为Number的</strong> </p><ul><li>Number([val])</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number(&apos;&apos;));            // 0</span><br><span class="line">console.log(Number(&apos;10&apos;));          // 10</span><br><span class="line">console.log(Number(&apos;10px&apos;));        // NaN</span><br><span class="line">console.log(Number(true));          // 1</span><br><span class="line">console.log(Number(false));         // 0</span><br><span class="line">console.log(Number(null));          // 0</span><br><span class="line">console.log(Number(undefined));     // NaN</span><br><span class="line">console.log(Number(Symbol(10));     // 报错</span><br><span class="line">console.log(Number(BigInt(10)));    // 10</span><br><span class="line">// 对象变为数字，应该先valueOf,没有原始值再toString变为字符串，最后把字符串转换为数字</span><br></pre></td></tr></table></figure><ul><li>parseInt/parseFloat([val])</li></ul><blockquote><p>parseInt机制：从字符串左侧第一个字符开始，查找有效字符（遇到非有效字符停止查找，不论后面是否还有数字字符），把找到的数字字符转化为数字，如果一个都没找到结果就是NaN（parseFloat多识别一个字符串）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;&quot;)    //NaN</span><br><span class="line">Number(&quot;&quot;)      // 0</span><br><span class="line">isNaN(&quot;&quot;)       //false</span><br><span class="line">parseInt(&quot;null&quot;)        //NaN</span><br><span class="line">Number(&quot;null&quot;)          // 0</span><br><span class="line">isNaN(&quot;null&quot;)           //false</span><br><span class="line">parseInt(&quot;12px&quot;)        //12</span><br><span class="line">Number(&quot;12px&quot;)          //NaN</span><br><span class="line">isNaN(&quot;12px&quot;)           //true</span><br><span class="line">parseFloat(&quot;1.6px&quot;) + parseInt(&quot;1.2px&quot;) + typeof parseInt(null)       //2.6number</span><br><span class="line">isNaN(Number(!!Number(parseInt(&quot;0.8&quot;))))        //false</span><br><span class="line">typeof !parseInt(null) + !isNaN(null)       //booleantrue</span><br></pre></td></tr></table></figure><p><strong>2. 隐式转换（浏览器内部默认先转换为Number在进行计算的）</strong></p><ul><li>isNaN([val])</li><li>数学运算（特殊情况：+ 在出现字符串的情况下不是数学运算，是字符串拼接）</li><li>在 == 比较的时候，有些值需要转换为数字再进行比较</li><li>…</li></ul><h4 id="把其他数据类型转换成-String-类型"><a href="#把其他数据类型转换成-String-类型" class="headerlink" title="把其他数据类型转换成 String 类型"></a>把其他数据类型转换成 String 类型</h4><p><strong>1. 可以使用的转换方法</strong></p><ul><li>toString()</li></ul><blockquote><p>把其他类型转换为字符串，一般都是直接用“”包起来，只有 { } 普通对象调取toString是调取Object.prototype.toString()方法，对象原型上的toString方法不是用来转换字符串的，而是用来检测数据类型的，返回结果为”[object Object]”</p></blockquote><ul><li>String()</li></ul><p><strong>2. 隐式转换（一般都是调用其toString）</strong></p><ul><li>加号运算的时候，如果某一边出现了字符串，则是字符串拼接</li><li>把对象转化为数字，需要先toString（）转为字符串，再转为数字</li><li>基于alert/confirm/prompt/document.write…这些方式输出内容，把内容先转化为字符串，然后在输出</li><li>…</li></ul><h4 id="把其他数据类型转换成-Boolean-串类型"><a href="#把其他数据类型转换成-Boolean-串类型" class="headerlink" title="把其他数据类型转换成 Boolean 串类型"></a>把其他数据类型转换成 Boolean 串类型</h4><p><strong>1. 可以使用的转换方法</strong></p><ul><li>! 转换成布尔值之后再取反</li><li>!! 转换成布尔值</li><li>Boolean([val])</li></ul><p><strong>2. 隐式转换（一般都是调用其toString）</strong></p><ul><li>在循环或条件判断中，条件处理的结果就是布尔类型值</li><li>…</li></ul><blockquote><p>只有‘0、NaN、null、undefined、空字符串’这几个值会变成布尔的false,其余值都是true</p></blockquote><h4 id="在等号转换过程中，数据转换的规则"><a href="#在等号转换过程中，数据转换的规则" class="headerlink" title="在等号转换过程中，数据转换的规则"></a>在等号转换过程中，数据转换的规则</h4><p><strong>1. 类型一样的几个特殊点</strong></p><ul><li>{} == {}   false  对象比较的是堆内存引用地址</li><li>[] == []   false</li><li>NaN == NaN false </li></ul><p><strong>2. 类型不一样的转换规则</strong></p><ul><li>null == undefined 的结果为true，但是换成===的结果是false（因为类型不一致），剩下null、undefined和其他任何数据类型值都不相等</li><li>字符串 == 对象 ，要把对象转换成字符串</li><li>剩下如果两边数据类型不一致，都需要转换为数字在进行比较</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>实例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">console.log([] == false);</span><br><span class="line">console.log(![] == false);</span><br><span class="line"></span><br><span class="line">// =&gt;  true true</span><br><span class="line"></span><br><span class="line">/*  console.log([] == false)</span><br><span class="line"> *  对象 == 布尔  类型不一致，都转换成数字比较</span><br><span class="line"> *  []对象转换成数字之前需要使用toString（）转换成字符串</span><br><span class="line"> *  即  [] =&gt; &apos;&apos; =&gt; 0 ，  false  =&gt; 0</span><br><span class="line"> *  所以结果为true</span><br><span class="line"> *</span><br><span class="line"> *  console.log(![] == false)</span><br><span class="line"> *  先计算 ![] 的值,将[]转为boolean再取反  =&gt; false</span><br><span class="line"> *  即  false == false</span><br><span class="line"> *  所以结果为true</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><strong>实例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let result = 10 + false +undefined + [] + &quot;Tencent&quot; + null + true + &#123;&#125;;</span><br><span class="line">console.log(result)</span><br><span class="line"></span><br><span class="line">// 10 + false =&gt; 10</span><br><span class="line">// 10 + undefined =&gt; NaN        任何数字加上NaN都是NaN</span><br><span class="line">// NaN + [] =&gt; &quot;NaN&quot;</span><br><span class="line">// &quot;NaN&quot; + &quot;Tencent&quot; =&gt; &quot;NaNTencent&quot;</span><br><span class="line">// 后面都是字符串拼接</span><br><span class="line">// &quot;NaNTencentnulltrue[object Object]&quot;</span><br></pre></td></tr></table></figure><p><strong>实例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//加号即使笔辩出现字符串或者对象，也不一定是字符串拼接： ++i/i++/+i 这种情况下是数学运算</span><br><span class="line">let n = &quot;10&quot;;</span><br><span class="line">console.log(++n);   // 11</span><br><span class="line">console.log(+n);    // 10</span><br><span class="line"></span><br><span class="line">// &#123;&#125; + 0</span><br><span class="line">// 在这中情况下，左边的&#123;&#125;会被识别成一个代码块，不参与运算</span><br><span class="line">// 类似于function fn()&#123;&#125; + 0</span><br><span class="line">// 运算值处理 +0 =&gt; 0</span><br><span class="line"></span><br><span class="line">// (&#123;&#125; + 0)参与到数学运算中 &quot;[object Object]0&quot;</span><br><span class="line"></span><br><span class="line">// 0+&#123;&#125; 是数学运算中 &quot;0[object Object]&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量提升</title>
      <link href="/2020/08/13/2020-08-13-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-md/"/>
      <url>/2020/08/13/2020-08-13-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-md/</url>
      
        <content type="html"><![CDATA[<h3 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h3><blockquote><p>变量提升是指，在当前上下文中（全局/私有/块级作用域），JS代码自上而下执行之前，浏览器会预处理一些代码（可以理解为此法解析的一个环节，此法解析一定发生在代码执行之前）,是 JavaScript 将所有声明提升到当前作用域顶部的默认行为。</p></blockquote><a id="more"></a><p>变量提升阶段，会将当前上下文中的所有带var和function关键字的语句进行提前的声明或者定义。</p><ul><li>带var关键字的语句只会提前声明</li><li>带function关键字的语句会提前声明加定义</li></ul><blockquote><p>在这里声明（declare）和定义（defined）的区别在于是否对提升的变量进行赋值操作。例如：“var a；”这个操作只是声明，而“var a = 1;”这个操作是指声明加定义。</p></blockquote><p><strong>通过几个实例来展示变量提升的常见场景</strong></p><h5 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h5><blockquote><p>带var关键字的语句提前声明</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//代码执行之前：全局上下文中的变量提升</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">var a = 12;</span><br><span class="line">a = 13;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">/* 上述代码在进行变量提升之后变成以下形式</span><br><span class="line"> *</span><br><span class="line"> *  var a;</span><br><span class="line"> *  console.log(a);  =&gt; undefined</span><br><span class="line"> *  a = 12;          //将a赋值为12</span><br><span class="line"> *  a = 13;          //将a赋值为13</span><br><span class="line"> *  console.log(a);  =&gt; 13</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h5><blockquote><p>带function关键字的语句提前声明加定义</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//代码执行之前：全局上下文中的变量提升</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line">function func()&#123;</span><br><span class="line">    var a = 12;</span><br><span class="line">    console.log(&quot;OK&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 上述代码在进行变量提升之后变成以下形式</span><br><span class="line"> *</span><br><span class="line"> *  function func()&#123;</span><br><span class="line"> *      var a;      //私有作用域中的变量提升</span><br><span class="line"> *      a = 12;</span><br><span class="line"> *      console.log(&quot;OK&quot;);</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  func();   =&gt;  OK</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><blockquote><p>在正式项目中，为了防止function提前定义，可以使用” var func = function(){ } “ 这种函数表达式的方式来创建函数。</p></blockquote><h5 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h5><blockquote><p>let和const声明的变量不会被提前</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)  //=&gt;Uncaught ReferenceError:Cannot access &apos;a&apos; before initialization  不能在let声明之前使用变量</span><br><span class="line">let a = 12;</span><br><span class="line">a = 13;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><h5 id="实例4"><a href="#实例4" class="headerlink" title="实例4"></a>实例4</h5><blockquote><p>基于var或者function在全局上下文中声明的变量（全局变量）会“映射“到全局对象window上。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 12;</span><br><span class="line">console.log(a);   //=&gt;12</span><br><span class="line">console.log(window.a);  //=&gt;12</span><br><span class="line"></span><br><span class="line">window.a = 13</span><br><span class="line">console.log(a);   //=&gt;13</span><br></pre></td></tr></table></figure><h5 id="实例5"><a href="#实例5" class="headerlink" title="实例5"></a>实例5</h5><blockquote><p>存在条件判断时，无论条件是否成立，都要进行变量提升，==新版本在条件体中的function提升的时候值声明不定义==</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func();     //=&gt; 新版本浏览器  undefined</span><br><span class="line">            //=&gt; 旧版本浏览器(ie10以下)  ok</span><br><span class="line">if(!(&quot;a&quot; in window))&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    function func()&#123;</span><br><span class="line">        console.log(&quot;ok&quot;)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">console.log(a);    //=&gt;undefined</span><br></pre></td></tr></table></figure><h5 id="实例6"><a href="#实例6" class="headerlink" title="实例6"></a>实例6</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line">function fn()&#123; console.log(1); &#125;</span><br><span class="line">fn();</span><br><span class="line">function fn()&#123; console.log(2); &#125;</span><br><span class="line">fn();</span><br><span class="line">var fn = function&#123; console.log(3); &#125;    //=&gt;执行上下文时，fn重新赋值</span><br><span class="line">fn();</span><br><span class="line">function fn()&#123; console.log(4); &#125;</span><br><span class="line">fn();</span><br><span class="line">function fn()&#123; console.log(5); &#125;</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line">//=&gt; 555333</span><br></pre></td></tr></table></figure><h5 id="实例7"><a href="#实例7" class="headerlink" title="实例7"></a>实例7</h5><blockquote><p>私有作用域下的变量提升</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line"></span><br><span class="line">function bar()&#123;</span><br><span class="line">    if(!foo)&#123;</span><br><span class="line">        var foo = 10;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();    //=&gt;10 </span><br><span class="line"></span><br><span class="line">/* 上述代码在进行变量提升之后变成以下形式</span><br><span class="line"> *  var foo;</span><br><span class="line"> *  function bar()&#123;</span><br><span class="line"> *      var foo;      //undefined</span><br><span class="line"> *      if(!foo)&#123;     //ture</span><br><span class="line"> *         foo = 10;</span><br><span class="line"> *      &#125;</span><br><span class="line"> *      console.log(foo);</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  foo = 1;</span><br><span class="line"> *  bar();    //=&gt;10</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><strong>参考文献</strong></p><ul><li><a href="https://ke.qq.com/course/list/%E7%8F%A0%E5%B3%B0" target="_blank" rel="noopener">珠峰教育公开课</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写简易的Promise</title>
      <link href="/2020/04/14/2020-04-14-Promise-md/"/>
      <url>/2020/04/14/2020-04-14-Promise-md/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><blockquote><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</p></blockquote><a id="more"></a><p><code>Promise</code> 是一个<strong>构造函数</strong>，接收一个函数作为参数，返回一个 <strong>Promise 实例</strong>。一个 Promise 实例有三种状态，分别是 <code>pending</code>、<code>fulfilled</code> 和 <code>rejected</code>，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 fulfilled 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 <code>then</code> 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。<strong>这个回调函数属于微任务</strong>，会在本轮事件循环的末尾执行。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><code>promise</code> 是一个包含了兼容promise规范then方法的对象或函数</p><p><code>thenable</code> 是一个包含then方法的对象或函数</p><p><code>value</code> 是任何的JavaScript值。（包括undefined、thenable、promise等）</p><p><code>exception</code> 是由<code>throw</code>表达式抛出来的值</p><p><code>reason</code> 是一个用于描述Promise被拒绝原因的一个值</p><h2 id="手写一个Promise"><a href="#手写一个Promise" class="headerlink" title="手写一个Promise"></a>手写一个Promise</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = &quot;pending&quot;;</span><br><span class="line">const RESOLVED = &quot;resolved&quot;;</span><br><span class="line">const REJECTED = &quot;rejected&quot;;</span><br><span class="line"></span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  // 保存初始化状态</span><br><span class="line">  var self = this;</span><br><span class="line"></span><br><span class="line">  // 初始化状态</span><br><span class="line">  this.state = PENDING;</span><br><span class="line"></span><br><span class="line">  // 用于保存 resolve 或者 rejected 传入的值</span><br><span class="line">  this.value = null;</span><br><span class="line"></span><br><span class="line">  // 用于保存 resolve 的回调函数</span><br><span class="line">  this.resolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 用于保存 reject 的回调函数</span><br><span class="line">  this.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 状态转变为 resolved 方法</span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br><span class="line">    if (value instanceof MyPromise) &#123;</span><br><span class="line">      return value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变，</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = RESOLVED;</span><br><span class="line"></span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.resolvedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 状态转变为 rejected 方法</span><br><span class="line">  function reject(value) &#123;</span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = REJECTED;</span><br><span class="line"></span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.rejectedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将两个方法传入函数执行</span><br><span class="line">  try &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // 遇到错误时，捕获错误，执行 reject 函数</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line">  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br><span class="line">  onResolved =</span><br><span class="line">    typeof onResolved === &quot;function&quot;</span><br><span class="line">      ? onResolved</span><br><span class="line">      : function(value) &#123;</span><br><span class="line">          return value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  onRejected =</span><br><span class="line">    typeof onRejected === &quot;function&quot;</span><br><span class="line">      ? onRejected</span><br><span class="line">      : function(error) &#123;</span><br><span class="line">          throw error;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  // 如果是等待状态，则将函数加入对应列表中</span><br><span class="line">  if (this.state === PENDING) &#123;</span><br><span class="line">    this.resolvedCallbacks.push(onResolved);</span><br><span class="line">    this.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果状态已经凝固，则直接执行对应状态的函数</span><br><span class="line"></span><br><span class="line">  if (this.state === RESOLVED) &#123;</span><br><span class="line">    onResolved(this.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (this.state === REJECTED) &#123;</span><br><span class="line">    onRejected(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECMAScript6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Ajax</title>
      <link href="/2020/04/14/2020-04-14-Ajax-md/"/>
      <url>/2020/04/14/2020-04-14-Ajax-md/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX"></a>什么是AJAX</h2><blockquote><p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p></blockquote><a id="more"></a><h2 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h2><blockquote><p>创建Ajax包括以下步骤：</p></blockquote><ol><li>实例化一个XMLHttpRequest对象</li><li>使用open方法创建一个http请求， <strong>open([请求方法],[请求地址],[是否异步和用户的认证信息])</strong></li><li>设置监听HTTP请求状态变化的函数</li><li>发送HTTP请求</li><li>获取异步调用返回的数据</li><li>使用JavaScript和DOM实现局部刷新</li></ol><p><strong>回调函数实现的方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const SERVER_URL = &quot;/server&quot;;</span><br><span class="line"></span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 创建 Http 请求</span><br><span class="line">xhr.open(&quot;GET&quot;, SERVER_URL, true);</span><br><span class="line"></span><br><span class="line">// 设置状态监听函数</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (this.readyState !== 4) return;</span><br><span class="line"></span><br><span class="line">  // 当请求成功时</span><br><span class="line">  if (this.status === 200) &#123;</span><br><span class="line">    handle(this.response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error(this.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 设置请求失败时的监听函数</span><br><span class="line">xhr.onerror = function() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 设置请求头信息</span><br><span class="line">xhr.responseType = &quot;json&quot;;</span><br><span class="line">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line"></span><br><span class="line">// 发送 Http 请求</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure><p><strong>基于promise封装实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line"></span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line"></span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line"></span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line"></span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h3><ol><li><code>get</code></li><li><code>post</code> </li><li><code>head</code></li><li><code>put</code></li><li><code>delete</code></li><li><code>connect</code></li><li><code>options</code></li><li><code>trace</code></li></ol><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul><li><code>200</code> <strong>服务器正常</strong></li><li><code>301</code> <strong>永久移动</strong></li><li><code>302</code> <strong>暂时移动</strong></li><li><code>304</code> <strong>未修改</strong></li><li><code>307</code> <strong>暂时重定向</strong></li><li><code>401</code> <strong>未授权</strong></li><li><code>403</code> <strong>禁止访问</strong></li><li><code>404</code> <strong>未发现指定网址</strong></li><li><code>500</code> <strong>服务器错误</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的防抖和节流</title>
      <link href="/2020/04/13/2020-04-13-%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81-md/"/>
      <url>/2020/04/13/2020-04-13-%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>函数的防抖和节流都是为了限制函数的执行次数，以解决函数触发频率过高导致浏览器的响应速度跟不上造成的卡顿和延迟现象，也就是前端所谓的性能优化。</p></blockquote><a id="more"></a><h2 id="函数的防抖"><a href="#函数的防抖" class="headerlink" title="函数的防抖"></a>函数的防抖</h2><blockquote><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//函数防抖的实现</span><br><span class="line">function(fn,wait)&#123;</span><br><span class="line">    var timer = null;</span><br><span class="line">    </span><br><span class="line">    return function()&#123;</span><br><span class="line">        var context = this,</span><br><span class="line">            args = arguments;</span><br><span class="line">        //如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">         if (timer) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的节流"><a href="#函数的节流" class="headerlink" title="函数的节流"></a>函数的节流</h2><blockquote><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。(游戏里的技能冷却)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 函数节流的实现;</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">    var preTime = Date.now();</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        var context = this,</span><br><span class="line">            args = arguments,</span><br><span class="line">            nowTime = Date.now();</span><br><span class="line"></span><br><span class="line">        // 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">        if (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">            preTime = Date.now();</span><br><span class="line">            return fn.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考文献</strong></p><p><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" target="_blank" rel="noopener">轻松理解JS函数节流和函数防抖</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化开发</title>
      <link href="/2020/04/13/2020-04-13-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91-md/"/>
      <url>/2020/04/13/2020-04-13-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91-md/</url>
      
        <content type="html"><![CDATA[<h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2><blockquote><p>现在的前端开发，不仅仅是完成浏览器的基本需求。并且通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程会加载越来越多的JavaScript代码。如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器快速、优雅的加载和更新，就需要一个模块化系统</p></blockquote><p>JavaScript本身是弱化命名空间概念的，只有全局和私有作用域（ES6新增块作用域），而模块化开发，从某种意义上来讲，是强化命名空间概念的</p><a id="more"></a><h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><blockquote><p>模块化是实现一组特定功能的一组方法</p></blockquote><p>最开始由于函数具有独立作用域的特点，所以使用<strong>函数</strong>来作为模块，但是这种方法容易造成全局变量污染，并且模块之间没有联系。后面提出了<strong>对象写法</strong>，通过函数作为一个对象的方法来实现，遮掩虽然解决了直接使用函数模块的缺点，但是这种方法会暴露所有的模块成员，从而导致外部代码可以修改内部代码。所以现在常用的时使用立即执行函数的写法，通过<strong>闭包</strong>来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</p><h3 id="JS常见的模块规范"><a href="#JS常见的模块规范" class="headerlink" title="JS常见的模块规范"></a>JS常见的模块规范</h3><h4 id="高级单例模式"><a href="#高级单例模式" class="headerlink" title="高级单例模式"></a>高级单例模式</h4><blockquote><p>高级单例模式：创建一个命名空间（模块名），接收一个闭包中返回的相关信息，实现把比保重的某些信息暴露出来，供其他闭包调用。（可以参考jQuery源码）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let module1 = (function()&#123;</span><br><span class="line">    let name = &quot;小明&quot;;</span><br><span class="line">    </span><br><span class="line">    function query()&#123;</span><br><span class="line">        console.log(&quot;query&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123; query:query &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">let module2 = (function()&#123;</span><br><span class="line">    function fn()&#123;</span><br><span class="line">        console.log(&quot;fn&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //调用module1中的query方法</span><br><span class="line">    module.query();</span><br><span class="line">    </span><br><span class="line">    return &#123; fn:fn &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><blockquote><p>Node.js 是 CommonJS 规范的主要实践者，在node.js中每个js文件就是一个模块，他有四个重要的环境变量：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，使用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接使用<code>exports</code>），用<code>require</code>加载模块。</p></blockquote><p><strong>定义模块math.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var basicNum = 0;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在这里写上需要向外暴露的函数、变量</span><br><span class="line">module.exports = &#123; </span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line">//ES6中对象的key和value相等可以简写为</span><br><span class="line">// module.exports = &#123; add,basicNum &#125;</span><br></pre></td></tr></table></figure><p><strong>引用自定义的模块时，参数包含路径，可省略.js</strong></p><blockquote><p>在第一次require的时候，会将module.exports导出的值拷贝一份，而第二次导入相同的值时，会直接获取第一次拷贝的值，而不会重新导入拷贝</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var math = require(&apos;./math&apos;);</span><br><span class="line">math.add(2, 5);</span><br><span class="line">math = require(&apos;./math&apos;);</span><br></pre></td></tr></table></figure><p><strong>引用核心模块时，不需要带路径</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createService(...).listen(3000);</span><br></pre></td></tr></table></figure><p>CommonJS 用同步的方法加载模块。在服务端，模块组件都存在本地磁盘，读取非常快。但是在浏览器端，由于网络的限制，所以使用异步加载更加合理。</p><h4 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h4><blockquote><p>AMD规范采用异步加载模块，模块的加载不影响它后面语句的执行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个会掉函数再执行。AMD规范的模块化是由<code>require.js</code>实现的。用<code>require.config()</code>指定应用路径、用<code>define()</code>定义模块、用<code>require()</code>加载模块。</p></blockquote><p><strong>网页中引入 require.js 及 main.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>main.js 入口文件/主模块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">    baseUrl:&quot;js/lib&quot;,</span><br><span class="line">    paths:&#123;</span><br><span class="line">        &quot;jquery&quot;:&quot;jquery.min&quot;,  //实际路径 js/lib/jquery.min.js</span><br><span class="line">        &quot;underscore&quot;:&quot;underscore.min&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//执行基本操作</span><br><span class="line">require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;</span><br><span class="line">    //code</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//定义math.js模块</span><br><span class="line">define(function()&#123;</span><br><span class="line">    var basicNum = 0;</span><br><span class="line">    var add = function(x,y)&#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        add:add,</span><br><span class="line">        basicNum:basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//定义提个依赖underscroe.js模块</span><br><span class="line">define([&apos;underscore&apos;],function()&#123;</span><br><span class="line">    var classify = function(list)&#123;</span><br><span class="line">    _.countBy(list,function(num)&#123;</span><br><span class="line">      return num &gt; 30 ? &apos;old&apos; : &apos;young&apos;;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 引用模块，将模块放在[]内</span><br><span class="line">require([&apos;jquery&apos;, &apos;math&apos;],function($, math)&#123;</span><br><span class="line">  var sum = math.add(10,20);</span><br><span class="line">  $(&quot;#sum&quot;).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h4><blockquote><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/** AMD写法 **/</span><br><span class="line">define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) &#123; </span><br><span class="line">     // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    a.doSomething();</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** CMD写法 **/</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var a = require(&apos;./a&apos;); //在需要时申明</span><br><span class="line">    a.doSomething();</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        var b = require(&apos;./b&apos;);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** sea.js **/</span><br><span class="line">// 定义模块 math.js</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var $ = require(&apos;jquery.js&apos;);</span><br><span class="line">    var add = function(a,b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    exports.add = add;</span><br><span class="line">&#125;);</span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([&apos;math.js&apos;], function(math)&#123;</span><br><span class="line">    var sum = math.add(1+2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h4><blockquote><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from &apos;./math&apos;;</span><br><span class="line">import * as math from &apos;./math&apos;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** export default **/</span><br><span class="line">//定义输出</span><br><span class="line">export default &#123; basicNum, add &#125;;</span><br><span class="line">//引入</span><br><span class="line">import math from &apos;./math&apos;;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = math.add(99 + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><p><strong>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></p><p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p><p><strong>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</strong></p><p>CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p><strong>参考文献</strong></p><p><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f" target="_blank" rel="noopener">浅谈模块化开发</a></p><p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">前端模块化</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new操作符</title>
      <link href="/2020/04/12/2020-04-12-new%E6%93%8D%E4%BD%9C%E7%AC%A6-md/"/>
      <url>/2020/04/12/2020-04-12-new%E6%93%8D%E4%BD%9C%E7%AC%A6-md/</url>
      
        <content type="html"><![CDATA[<h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><blockquote><p><strong>语法</strong></p></blockquote><pre><code>new constructor[([arguments])]</code></pre><p><strong>constructor</strong></p><p>  一个指定对象实例的类型的类或函数。</p><p><strong>arguments</strong></p><p>  一个用于被 constructor 调用的参数列表。</p><a id="more"></a><blockquote><p>创建一个用户自定义的对象一般有两个步骤：</p></blockquote><ol><li>通过编写函数来定义对象类型</li><li>通过 new 来创建对象实例。</li></ol><p><strong>如果你没有使用 new 运算符， 构造函数会像其他的常规函数一样被调用， 并不会创建一个对象。在这种情况下， this 的指向也是不一样的。</strong></p><h2 id="new-操作符具体干了什么？"><a href="#new-操作符具体干了什么？" class="headerlink" title="new 操作符具体干了什么？"></a>new 操作符具体干了什么？</h2><blockquote><p>new 共经历了四个过程</p></blockquote><ol><li>首先创建了一个空对象</li><li>设置原型、将对象的原型设置为函数的prototype对象</li><li>让函数的 this 指向这个对象，执行构造函数的代码，为这个新对象添加属性</li><li>判断函数的返回值，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><p><strong>代码实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function objectFactory()&#123;</span><br><span class="line">    let newObject = null,</span><br><span class="line">    constructor = Array.prototype.shift.call(arguments),</span><br><span class="line">    result = null;</span><br><span class="line">    </span><br><span class="line">    //参数判断</span><br><span class="line">    if(typeof constructor !== &quot;function&quot;)&#123;</span><br><span class="line">        console.error(&quot;type error&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br><span class="line">    newObject = Object.create(constructor.prototype);</span><br><span class="line">    </span><br><span class="line">    //将this指向新建对象，并执行函数</span><br><span class="line">    result = constructor.apply(newObject,arguments);</span><br><span class="line">    </span><br><span class="line">    //判断返回对象</span><br><span class="line">    let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);</span><br><span class="line">    </span><br><span class="line">    //判断返回结果</span><br><span class="line">    return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用方法</span><br><span class="line">// objectFactory(构造函数,初始化参数)</span><br></pre></td></tr></table></figure><p><strong>参考文献</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">new 运算符</a></p><p><a href="https://segmentfault.com/a/1190000008576048" target="_blank" rel="noopener">new 操作符具体干了什么？</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垂直居中布局</title>
      <link href="/2020/04/01/2020-04-01-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80-md/"/>
      <url>/2020/04/01/2020-04-01-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80-md/</url>
      
        <content type="html"><![CDATA[<h3 id="margin-绝对定位"><a href="#margin-绝对定位" class="headerlink" title="margin+绝对定位"></a>margin+绝对定位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  margin: auto;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="绝度定位"><a href="#绝度定位" class="headerlink" title="绝度定位"></a>绝度定位</h3><blockquote><p>确定容器的宽高,设置div的负外边距</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">position:absolute;/*绝对定位*/</span><br><span class="line">width:500px;</span><br><span class="line">height:300px;</span><br><span class="line">top:50%;</span><br><span class="line">left:50%;</span><br><span class="line">margin:-150px -250px;/*外边距为自身宽高的一半*/</span><br><span class="line">background-color:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><blockquote><p>未知容器的宽高，利用<code>transform</code>属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  position: relative; /*相对定位或绝对定位均可*/</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">  background-color: pink; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h3><blockquote><p>利用flex布局实际使用时应考虑兼容性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center; /*垂直居中*/</span><br><span class="line">  justify-content: center; /*水平居中*/</span><br><span class="line">&#125;</span><br><span class="line">.container div &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background-color: pink; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="text-align和vertical-align"><a href="#text-align和vertical-align" class="headerlink" title="text-align和vertical-align"></a>text-align和vertical-align</h3><blockquote><p>利用text-align:center和vertical-align:middle属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">container &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  background: rgba(0, 0, 0, 0.5);</span><br><span class="line">  text-align: center;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">  overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container::after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  height: 100%;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 400px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  white-space: normal;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般常见的几种居中的方法有：</p><p>对于宽高固定的元素</p><p>（1）我们可以利用margin:0auto来实现元素的水平居中。</p><p>（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水<br>平和垂直方向上的居中。</p><p>（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素<br>的中心点到页面的中心。</p><p>（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素<br>的中心点到页面的中心。</p><p>（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对<br>齐，然后它的子元素也可以实现垂直和水平的居中。</p><p>对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒子模型</title>
      <link href="/2020/04/01/2020-04-01-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B-md/"/>
      <url>/2020/04/01/2020-04-01-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B-md/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS盒子模型简介"><a href="#CSS盒子模型简介" class="headerlink" title="CSS盒子模型简介"></a>CSS盒子模型简介</h2><blockquote><p>当我们对文档进行布局的时候，浏览器的渲染引擎会根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener"> CSS 基础框盒模型（CSS basic box model）</a>标准，将所有元素渲染成一个个矩形的盒子，且通过CSS决定盒子的大小、位置以及属性等属性。</p></blockquote><a id="more"></a><p><strong>每个盒子有四个部分组成</strong></p><ul><li>内容边界 Content edge</li><li>内边距边界 Padding Edge</li><li>框边界 Border Edge</li><li>外边框边界 Margin Edge</li></ul><p>MDN 官网图片<br><img src="/images/loading.png" data-original="https://mdn.mozillademos.org/files/8685/boxmodel-(3).png" ></p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><blockquote><p>CSS 中的 box-sizing 属性定义了 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent" target="_blank" rel="noopener">user agent</a> 应该如何计算一个元素的总宽度和总高度。</p></blockquote><h3 id="W3C标准盒模型（content-box）"><a href="#W3C标准盒模型（content-box）" class="headerlink" title="W3C标准盒模型（content-box）"></a>W3C标准盒模型（content-box）</h3><blockquote><p>默认值，标准盒子模型。 width 与 height 只包括内容的宽和高，不包括边框（border），内边距（padding），外边距（margin）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    background-color:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/10/25/9cb491d4bd5d326aeb16632280411283?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" ><h3 id="IE盒模型（border-box）"><a href="#IE盒模型（border-box）" class="headerlink" title="IE盒模型（border-box）"></a>IE盒模型（border-box）</h3><blockquote><p>width 和 height 属性包括内容，内边距和边框，但<strong>不包括外边距(margin)</strong>。</p></blockquote><p><strong>尺寸计算公式</strong>：</p><p>width = border + padding + 内容的宽度</p><p>height = border + padding + 内容的高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    background-color:blue;</span><br><span class="line">    padding:20px;</span><br><span class="line">    border:10px solid orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/10/25/cfff88aff482f7dd89d60d7498695450?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" ><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>我们在编写页面代码时应尽量使用标准的W3C模型(需在页面中声明DOCTYPE类型)，这样可以避免多个浏览器对同一页面的不兼容。因为若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型，FireFox等会将其解释为W3C盒子模型；若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</p></blockquote><p><strong>参考文献</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener">CSS 基础框盒模型介绍</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" target="_blank" rel="noopener">box-sizing</a></p><p><a href="https://juejin.im/post/59ef72f5f265da4320026f76" target="_blank" rel="noopener">CSS盒模型详解</a></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex</title>
      <link href="/2020/03/30/2020-03-30-vuex-md/"/>
      <url>/2020/03/30/2020-03-30-vuex-md/</url>
      
        <content type="html"><![CDATA[<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><blockquote><p>官网上介绍，Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><a id="more"></a><h3 id="状态管理模式"><a href="#状态管理模式" class="headerlink" title="状态管理模式"></a>状态管理模式</h3><blockquote><p>如果你熟悉vue.js开发，那么你一定对各组件之间传值的问题倍感头疼，而vuex就是用来解决各个组件之间共用值得传递问题</p></blockquote><p>– 1. 在你的项目中安装vuex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><p>– 2. 在src文件目录中新建store文件夹，再在这个文件夹下创建一个index.js文件并输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex from &apos;vuex&apos;;</span><br><span class="line">//使用vuex</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">//创建Vuex.Store实例保存到变量store中</span><br><span class="line">const store = new Vuex.Store();</span><br><span class="line"> </span><br><span class="line">export default store;       //导出store</span><br></pre></td></tr></table></figure><p>– 3. 在main.js文件中引用该对象,这样就可以在任何一个组件里面使用this.$store了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,//使用store</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vuex核心"><a href="#vuex核心" class="headerlink" title="vuex核心"></a>vuex核心</h2><blockquote><p>官网图片</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/9ba18300-7268-11ea-b94e-47f67ecf8268.jpg" ><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote><p>store相当于一个商店，不同的组件可以来商店来获取自己想要的商品，而state就相当于商店的货架，组件可以通多store.state.XXX获取需要的状态</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 每当 store.state.count变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。然而，这种模式导致组件依赖全局状态单例。Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：</p><p>– 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Counter = &#123;</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h4><blockquote><p>当组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。mapState辅助函数帮助我们生成计算属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 在单独构建的版本中辅助函数为 Vuex.mapState</span><br><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    // 箭头函数可使代码更简练</span><br><span class="line">    count: state =&gt; state.count,</span><br><span class="line"></span><br><span class="line">    // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count`</span><br><span class="line">    countAlias: &apos;count&apos;,</span><br><span class="line"></span><br><span class="line">    // 为了能够使用 `this` 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h4><blockquote><p>mapState函数返回的是一个对象。通常，我们可以在<strong>computed</strong>使用<strong><a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">对象展开运算符</a></strong>，将多个对象合并成一个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; </span><br><span class="line">    // ... </span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><blockquote><p>如果我们将state看做store的data属性，那么getter就可以被看做store的computed属性（getter的返回值根据他的依赖被缓存起来，当依赖改变时会被重新计算）。</p></blockquote><p>– getter 接受 state 作为其第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.getters.doneTodos // -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;]</span><br></pre></td></tr></table></figure><p>– Getter 也可以接受其他 getter 作为第二个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  // ...</span><br><span class="line">  doneTodosCount: (state, getters) =&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.getters.doneTodosCount // -&gt; 1</span><br></pre></td></tr></table></figure><h4 id="mapGetter辅助函数"><a href="#mapGetter辅助函数" class="headerlink" title="mapGetter辅助函数"></a>mapGetter辅助函数</h4><blockquote><p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">  // 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class="line">    ...mapGetters([&apos;doneTodosCount&apos;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><blockquote><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      // 变更状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>– 调用此函数,需要以相应的 type 调用 store.commit 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;)</span><br></pre></td></tr></table></figure><h4 id="载荷（Payload）"><a href="#载荷（Payload）" class="headerlink" title="载荷（Payload）"></a>载荷（Payload）</h4><p>– store&gt;store.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;, 10)</span><br></pre></td></tr></table></figure><blockquote><p>大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p></blockquote><p>– xxx.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;, &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h4><blockquote><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p></blockquote><p>– mutation-types.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const SOME_MUTATION = &apos;SOME_MUTATION&apos;</span><br></pre></td></tr></table></figure><p>– store.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import &#123; SOME_MUTATION &#125; from &apos;./mutation-types&apos;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      // mutate state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h4><blockquote><p>可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line"></span><br><span class="line">      // `mapMutations` 也支持载荷：</span><br><span class="line">      &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意一条重要的原则就是要记住 mutation 必须是同步函数,在 mutation 中混合异步调用会导致你的程序很难调试。</strong></p></blockquote><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote><p>Action 类似于 mutation，不同在于：</p></blockquote><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (&#123; commit &#125;) &#123;    //参数解构来简化代码</span><br><span class="line">        commit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h4><blockquote><p>Action 通过store.dispatch方法触发：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&apos;increment&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>action 内部可以执行异步操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      commit(&apos;increment&apos;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mapActions辅助函数"><a href="#mapActions辅助函数" class="headerlink" title="mapActions辅助函数"></a>mapActions辅助函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class="line"></span><br><span class="line">      // `mapActions` 也支持载荷：</span><br><span class="line">      &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vuex中mutation和action的详细区别"><a href="#vuex中mutation和action的详细区别" class="headerlink" title="vuex中mutation和action的详细区别"></a>vuex中mutation和action的详细区别</h4></li></ul><ol><li>流程顺序</li></ol><p>“相应视图—&gt;修改State”拆分成两部分，视图触发Action，Action再触发Mutation。</p><ol start="2"><li>角色定位</li></ol><p>基于流程顺序，二者扮演不同的角色。</p><pre><code>Mutation：专注于修改State，理论上是修改State的唯一途径。Action：业务代码、异步请求。</code></pre><ol start="3"><li>限制</li></ol><p>角色不同，二者有不同的限制。</p><pre><code>Mutation：必须同步执行。Action：可以异步，但不能直接操作State。</code></pre><blockquote><p>他两者之间不是功能的不同，而是编程思想的不同，按照官方规定书写代码高效、易维护、逻辑清晰</p></blockquote><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><blockquote><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure><p><strong>参考文献</strong></p><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex是什么</a></p><p><a href="https://segmentfault.com/a/1190000015782272" target="_blank" rel="noopener">VueJS中学习使用Vuex详解</a></p><p><a href="https://blog.csdn.net/weixin_38483133/article/details/89327362" target="_blank" rel="noopener">vuex中mutation和action的详细区别</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>湖工二手go项目笔记</title>
      <link href="/2020/03/29/2020-03-29-%E6%B9%96%E5%B7%A5%E4%BA%8C%E6%89%8Bgo%E9%A1%B9%E7%9B%AE-md/"/>
      <url>/2020/03/29/2020-03-29-%E6%B9%96%E5%B7%A5%E4%BA%8C%E6%89%8Bgo%E9%A1%B9%E7%9B%AE-md/</url>
      
        <content type="html"><![CDATA[<h2 id="项目成果展示"><a href="#项目成果展示" class="headerlink" title="项目成果展示"></a>项目成果展示</h2><blockquote><p>项目说明：该项目用于毕业设计，未经同意不得转载</p></blockquote><a id="more"></a><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/df805e70-7191-11ea-b94e-47f67ecf8268.png" ><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/e5f7f290-7191-11ea-9e8b-05a3242b26f2.png" ><h2 id="uni-app简介"><a href="#uni-app简介" class="headerlink" title="uni-app简介"></a>uni-app简介</h2><blockquote><p>uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台</p></blockquote><p><strong>uni-app的优势</strong></p><ul><li>开发者/案例数量多，跨端完善度高</li><li>平台能力不受限制<br>  在跨端的同时，通过条件编译+平台特有API调用，可以优雅的为某平台写个性化代码，调用专有能力而不影响其他平台</li><li>性能体验优秀<ul><li>体验更好的Hybrid框架，加载新页面速度更快</li><li>App端支持weex原生渲染，可支撑更流畅的用户体验</li><li>小程序端的性能优于市场其他框架</li></ul></li><li>周边生态丰富<ul><li>插件市场数千款插件</li><li>支持NPM、支持小程序组件和SDK、兼容mpvue组件和项目、兼容weex组件</li><li>微信生态的各种sdk可直接用于跨平台App</li></ul></li><li>学习成本低<br>  基于通用的前端技术栈，采用vue语法+微信小程序api，无额外学习成本</li><li>开发成本低<br>  不止开发成本，招聘、管理、测试各方面成本都大幅下降。</li></ul><p><strong>功能框架</strong></p><blockquote><p>uni-app在跨平台的过程中，不牺牲平台特色，可优雅的调用平台专有能力</p></blockquote><img src="/images/loading.png" data-original="https://img.cdn.aliyun.dcloud.net.cn/uni-app/doc/uni-app-frame-0310.png" ><p><strong>选用uni-app做小程序的理由</strong></p><ul><li>性能测试：微信原生开发手工优化&gt;uni-app&gt;微信原生开发未手工优化&gt;taro &gt; wepy &gt; mpvue</li></ul><img src="/images/loading.png" data-original="http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/test-frame-13.png" ><ul><li>微信那个IDE和专业编辑器相比实在不好用</li><li>vue生态里有太多周边工具，可以提高开发效率</li><li>原生开发对Node、预编译器、webpack支持不好，影响开发效率和工程构建流程</li></ul><p><strong>参考文献</strong><br>–<a href="https://uniapp.dcloud.io/README" target="_blank" rel="noopener">uni-app开发文档</a><br>–<a href="https://ask.dcloud.net.cn/article/35947" target="_blank" rel="noopener">小程序开发</a></p><h2 id="uniCloud简介"><a href="#uniCloud简介" class="headerlink" title="uniCloud简介"></a>uniCloud简介</h2><blockquote><p>uniCloud 是 DCloud 联合阿里云、腾讯云，为 uni-app 的开发者提供的基于 serverless 模式和 js 编程的云开发平台。uniCloud，在腾讯云、阿里云的 serverless 基础能力之上，实现了真正的跨端。让 uni-app 的开发者使用js开发一云多端的整套业务。并对云开发的功能扩展、开发体验做了很多强化，是下一代开发技术的典型代表。</p></blockquote><p><strong>开发和运行流程</strong></p><blockquote><p>开发过程，连接DCloud服务器；运行过程是手机端直连阿里云或腾讯云 serverless 环境，不通过DCloud服务器中转。</p></blockquote><ul><li>开发者在HBuilderX里为项目新建 uniCloud 云环境（可选择阿里云或腾讯云），在云函数目录下编写js代码，上传部署云函数到阿里云或腾讯云的 serverless 环境中。</li><li>前端代码通过<strong>uniCloud.callFunction()</strong>方法调用云函数。</li><li>云函数中可执行js运算、读写云化数据库（NoSQL）、读写存储和CDN、操作网络，给前端返回数据</li></ul><p><strong>云开发基础</strong></p><ul><li>云函数：在云端运行的js代码。运行在定制过的node环境中，有良好的性能和强大的功能。serverless环境无需自行加购服务器处理增容，云函数按量付费，不管多大的并发都扛得住</li><li>数据库：可在云函数中读写的、基于 NoSQL 的 JSON 数据库。这种数据库对于前端工程师更自然，不需要学习SQL、不需要理解关系型和设计主键。</li><li>存储和CDN：不管在前端还是云函数中，都可以操作存储和CDN。在uniCloud提供的安全机制下，可以实现应用前端直传CDN，避免服务器中转的耗时和带宽占用，且不会发生盗传。</li></ul><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/a6899f70-719e-11ea-8a36-ebb87efcf8c0.png" ><p><strong>参考文献</strong><br>–<a href="https://uniapp.dcloud.io/uniCloud/README?id=unicloud-%e7%9a%84%e4%bb%b7%e5%80%bc" target="_blank" rel="noopener">uniCloud帮助文档</a></p><h2 id="前端环境搭建"><a href="#前端环境搭建" class="headerlink" title="前端环境搭建"></a>前端环境搭建</h2><blockquote><p>该项目采用的是 uni-app 加 uniCloud 的开发模式，也就是前端通过云函数调取云数据库中提供的JSON接口，让代码没有耦合。开发之前需要下载<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">微信开发者工具</a>进行调试</p></blockquote><ol><li><p>创建带uniCloud的uni-app项目（目前只支持使用HBuilder X创建uniCloud项目）</p><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/5ae43f90-71a2-11ea-9e8b-05a3242b26f2.png" ></li><li><p>在 mainfest.json 微信小程序配置，微信小程序APPID（在微信开发者工具中申请获得），同时勾选 ES6转ES5 、 上传代码时样式自动补全 以及 上传代码时自动压缩。</p></li><li><p>在pages页面下创建目录index、community以及my文件夹同时分别在文件夹下创建同名vue文件、components组件文件夹。</p></li><li><p><a href="https://unicloud.dcloud.net.cn/login" target="_blank" rel="noopener">申请uniCloud</a>云开发账号（需要一天审核时间），审核通过即可创建uniCloud服务空间</p></li></ol><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/2f987000-71b5-11ea-b94e-47f67ecf8268.png" ><ol start="5"><li>创建完uniCloud服务空间，即可在项目中的 cloudfunctions目录中绑定uniCloud的服务空间</li></ol><h2 id="首页实现"><a href="#首页实现" class="headerlink" title="首页实现"></a>首页实现</h2><h3 id="搜索框-轮播图（search）组件"><a href="#搜索框-轮播图（search）组件" class="headerlink" title="搜索框+轮播图（search）组件"></a>搜索框+轮播图（search）组件</h3><p><strong>组件注册</strong></p><blockquote><p>创建 search.vue 并在 index.vue 中引入并注册 search组件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Search from &apos;./components/search&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    components:&#123; Search &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搜索框</strong></p><blockquote><p>这里的 input 要设置 disabled 属性禁止input的默认点击事件，为后期制作一个单独的搜索页做准备。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 搜索框 --&gt;</span><br><span class="line">&lt;view class=&quot;search&quot;&gt;</span><br><span class="line">&lt;view class=&quot;search-input&quot;&gt;</span><br><span class="line">&lt;img src=&quot;../../../static/tab/sousuo.svg&quot; mode=&quot;widthFix&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; placeholder=&quot;请输入文字&quot; disabled /&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p><strong>轮播组件</strong></p><blockquote><p>uni-app提供了swiper组件，这里列举几个常用的属性</p></blockquote><table><thead><tr><th align="left">属性名</th><th align="right">类型</th><th align="right">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">indicator-dots</td><td align="right">Boolean</td><td align="right">false</td><td align="center">是否显示面板指示点</td></tr><tr><td align="left">indicator-color</td><td align="right">Color</td><td align="right">rgba(0, 0, 0, .3)</td><td align="center">指示点颜色</td></tr><tr><td align="left">indicator-active-color</td><td align="right">Color</td><td align="right">#000000</td><td align="center">当前选中的指示点颜色</td></tr><tr><td align="left">autoplay</td><td align="right">Boolean</td><td align="right">false</td><td align="center">是否自动切换</td></tr><tr><td align="left">interval</td><td align="right">Number</td><td align="right">5000</td><td align="center">自动切换时间间隔</td></tr><tr><td align="left">duration</td><td align="right">Number</td><td align="right">500</td><td align="center">滑动动画时长</td></tr><tr><td align="left">circular</td><td align="right">Boolean</td><td align="right">false</td><td align="center">是否采用衔接滑动</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 轮播组件 --&gt;</span><br><span class="line">&lt;swiper</span><br><span class="line">:indicator-dots=&quot;true&quot;</span><br><span class="line">:autoplay=&quot;true&quot;</span><br><span class="line">:interval=&quot;3000&quot;</span><br><span class="line">:duration=&quot;1000&quot;</span><br><span class="line">:circular=&quot;true&quot;</span><br><span class="line">indicator-color=&quot;rgba(255,255,255)&quot;</span><br><span class="line">indicator-active-color=&quot;#00ff00&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;swiper-item v-for=&quot;(item,index) in banner&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">&lt;view class=&quot;swiper-item&quot; id=&quot;swiper-item&quot;&gt;</span><br><span class="line">&lt;img :src=&quot;item.image&quot; class=&quot;img-url&quot; mode=&quot;aspectFill&quot;&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/swiper-item&gt;</span><br><span class="line">&lt;/swiper&gt;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/liZhuTao/uniCloud/blob/master/pages/index/components/search.vue" target="_blank" rel="noopener">search组件完整代码</a></p><h3 id="轮播组件的数据上传到uniCloud"><a href="#轮播组件的数据上传到uniCloud" class="headerlink" title="轮播组件的数据上传到uniCloud"></a>轮播组件的数据上传到uniCloud</h3><p><strong>将数据上传至uniCloud云数据库</strong></p><blockquote><p>先将轮播的图片存储到云存储中,云存储会操作生成图片的地址</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/229c9200-71bf-11ea-b997-9918a5dda011.png" ><blockquote><p>创建banner集合，并上传数据（上传数据需要按照JSON的格式上传）</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/76d99f80-71be-11ea-8bd0-2998ac5bbf7e.png" ><h3 id="云函数操作数据库"><a href="#云函数操作数据库" class="headerlink" title="云函数操作数据库"></a>云函数操作数据库</h3><blockquote><p>uniCloud中不允许前端直接调用云数据库中的数据，必须通过云函数来调用并返回给前端，前端用<a href="https://uniapp.dcloud.io/uniCloud/cf-functions?id=%e5%ae%a2%e6%88%b7%e7%ab%af%e8%b0%83%e7%94%a8%e4%ba%91%e5%87%bd%e6%95%b0" target="_blank" rel="noopener">uniCloud.callFunction</a>调用云函数，并接收返回结果</p></blockquote><p><strong>创建云函数</strong></p><blockquote><p>右键cloudfunction文件夹，选择新建云函数getData</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">//获取数据库</span><br><span class="line">const db = uniCloud.database();</span><br><span class="line"></span><br><span class="line">exports.main = async (event, context) =&gt; &#123;</span><br><span class="line">  //event为客户端上传的参数(用户要以对象的形式上传数据)</span><br><span class="line">  let list = event.list                     //list为前端传来的要操作的集合名称</span><br><span class="line">  const banner = db.collection(list)// 获取集合的引用</span><br><span class="line">  const res = await banner.get()</span><br><span class="line">  //返回数据给客户端</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>创建完云函数后，右键getData文件夹，选择上传并运行 就可以将云函数上传并部署到uniCloud服务空间上（注意在IDE中运行，云函数可能会报错或者event返回空对象，先将项目运行到微信小程序上，再到<a href="https://unicloud.dcloud.net.cn/" target="_blank" rel="noopener">uniCloud</a>中找到对应的云函数，打开日志，在前端触发一下云函数，在看是否会报错或者event为空）</p></blockquote><p><strong>前端操作云函数</strong></p><blockquote><p>在项目根目录中创建 common公共组件目录，并在其中创建一个的公共组件cloudFun，用于获取与函数返回的数据库信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let getData = function(list) &#123;</span><br><span class="line">let mylist = list</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">uniCloud.callFunction(&#123;</span><br><span class="line">name: &apos;getData&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">&quot;list&quot;: mylist//前端通过data对象将数据传给云函数</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">resolve(res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">reject(err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; getData &#125;//将函数导出</span><br></pre></td></tr></table></figure><p><a href="https://github.com/liZhuTao/uniCloud/blob/master/common/cloudFun.js" target="_blank" rel="noopener">cloudFun源码</a></p><blockquote><p>在index.vue中的 created 生命周期中<strong>获取数据</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123;getData&#125; from &apos;../../common/cloudFun.js&apos;//操作数据库组件</span><br><span class="line">export default&#123;</span><br><span class="line">data()&#123;</span><br><span class="line">   return &#123; banner:[] &#125;</span><br><span class="line">&#125;</span><br><span class="line">created()&#123;</span><br><span class="line">    //请求数据</span><br><span class="line">    let banner = &quot;banner&quot;</span><br><span class="line">    getData(banner)</span><br><span class="line">    .then(res=&gt;&#123;</span><br><span class="line">        this.banner = res.result.data</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err=&gt;&#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将数据传给search组件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Search :banner=&quot;banner&quot;&gt;&lt;/Search&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在search中接收数据,就可以直接将数据遍历到轮播图</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">name:&apos;search&apos;,</span><br><span class="line">props:&#123;</span><br><span class="line">banner:Array</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分类导航（ticket）组件"><a href="#分类导航（ticket）组件" class="headerlink" title="分类导航（ticket）组件"></a>分类导航（ticket）组件</h3><blockquote><p>首先在根目录下创建一个<a href="https://github.com/liZhuTao/uniCloud/tree/master/static" target="_blank" rel="noopener">static</a>文件夹用于存储静态文件（同样也可以放在云存储中），在static文件夹下创建tab文件夹来存储首页需要的图片<br><strong>ticket.vue</strong><br>创建完成后再index.vue的components中注册才能使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;!-- 分类导航 --&gt;</span><br><span class="line">&lt;view class=&quot;sort&quot;&gt;</span><br><span class="line">&lt;view class=&quot;sort-item&quot; v-for=&quot;(item,index) in sortList&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">&lt;img :src=&quot;item.image&quot;&gt;</span><br><span class="line">&lt;text&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&apos;ticket&apos;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">sortList:[</span><br><span class="line">&#123;image:require(&quot;../../../static/tab/man.png&quot;),name:&quot;男装&quot;&#125;,</span><br><span class="line">&#123;image:require(&quot;../../../static/tab/weman.png&quot;),name:&quot;女装&quot;&#125;,</span><br><span class="line">&#123;image:require(&quot;../../../static/tab/book.png&quot;),name:&quot;书籍&quot;&#125;,</span><br><span class="line">&#123;image:require(&quot;../../../static/tab/life.png&quot;),name:&quot;生活&quot;&#125;,</span><br><span class="line">&#123;image:require(&quot;../../../static/tab/phone.png&quot;),name:&quot;电子&quot;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.sort&#123;</span><br><span class="line">display: flex;</span><br><span class="line">flex-direction: row;</span><br><span class="line">flex-wrap: nowrap;</span><br><span class="line">justify-content: space-between;</span><br><span class="line">align-items: center;</span><br><span class="line">margin: 30upx 30upx;</span><br><span class="line">&#125;</span><br><span class="line">.sort-item&#123;&#125;</span><br><span class="line">.sort-item img&#123;</span><br><span class="line">width: 90upx;</span><br><span class="line">height: 90upx;</span><br><span class="line">&#125;</span><br><span class="line">.sort text&#123;</span><br><span class="line">font-size: 30upx;</span><br><span class="line">display: block;</span><br><span class="line">margin-left: 15upx;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="小分类（classify）组件"><a href="#小分类（classify）组件" class="headerlink" title="小分类（classify）组件"></a>小分类（classify）组件</h3><blockquote><p>创建完成后再index.vue的components中注册才能使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view style=&quot;margin: 0 20upx;&quot;&gt;</span><br><span class="line">&lt;view class=&quot;notice&quot;&gt;</span><br><span class="line">&lt;view v-for=&quot;(item,index) in noticeList&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">&lt;text class=&quot;notice-title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;text class=&quot;notice-describe&quot;&gt;&#123;&#123;item.describe&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&apos;classify&apos;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">noticeList:[</span><br><span class="line">&#123;title:&quot;标题1&quot;,describe:&quot;描述1&quot;&#125;,</span><br><span class="line">&#123;title:&quot;标题2&quot;,describe:&quot;描述2&quot;&#125;,</span><br><span class="line">&#123;title:&quot;标题3&quot;,describe:&quot;描述3&quot;&#125;,</span><br><span class="line">&#123;title:&quot;标题4&quot;,describe:&quot;描述4&quot;&#125;,</span><br><span class="line">&#123;title:&quot;标题5&quot;,describe:&quot;描述5&quot;&#125;,</span><br><span class="line">&#123;title:&quot;标题6&quot;,describe:&quot;描述6&quot;&#125;,</span><br><span class="line">&#123;title:&quot;标题7&quot;,describe:&quot;描述7&quot;&#125;,</span><br><span class="line">&#123;title:&quot;标题8&quot;,describe:&quot;描述8&quot;&#125;,</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>–<a href="https://github.com/liZhuTao/uniCloud/blob/master/pages/index/components/classify.vue" target="_blank" rel="noopener">classify组件源码</a></p><h3 id="导航（content）组件"><a href="#导航（content）组件" class="headerlink" title="导航（content）组件"></a>导航（content）组件</h3><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/9e820e80-7238-11ea-b94e-47f67ecf8268.png">**布局**> [scroll-view](https://uniapp.dcloud.io/component/scroll-view?id=scroll-view)是uni-app中自带的滚动视图组件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;scroll-view scroll-x=&quot;true&quot; class=&quot;scroll&quot; scroll-with-animation=&quot;true&quot;&gt;</span><br><span class="line">&lt;view v-for=&quot;(item,index) in tab&quot; :key=&quot;index&quot; class=&quot;list-cont&quot; @click=&quot;clickTabs(index,item.nav)&quot;&gt;</span><br><span class="line">&lt;view :class=&quot;&#123;active: index== num&#125;&quot;&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text class=&quot;con-text-a&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text class=&quot;con-text-b&quot; :class=&quot;&#123;activeb: index== num&#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/scroll-view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>> click点击事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">name:&quot;content&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">num: 0,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">clickTabs(index,nav)&#123;</span><br><span class="line">this.num = index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="商品（article）组件"><a href="#商品（article）组件" class="headerlink" title="商品（article）组件"></a>商品（article）组件</h3><p><strong>布局</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view class=&quot;active&quot;&gt;</span><br><span class="line">&lt;view class=&quot;conteng&quot;&gt;</span><br><span class="line">&lt;block v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">&lt;view class=&quot;conteng-article&quot;&gt;</span><br><span class="line">&lt;view  class=&quot;conteng-img&quot;&gt;</span><br><span class="line">&lt;image :src=&quot;item.image&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;!-- 文字介绍 --&gt;</span><br><span class="line">&lt;view class=&quot;active-introduce&quot;&gt;</span><br><span class="line">&lt;view class=&quot;active-name&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;active-title&quot;&gt;&#123;&#123;item.list&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;active-label&quot;&gt;&#123;&#123;item.label&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;purchase&quot;&gt;</span><br><span class="line">&lt;text class=&quot;active-price&quot;&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;text class=&quot;active-purchase&quot;&gt;&#123;&#123;item.buy&#125;&#125;人想买&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt; </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="导航-商品获取数据"><a href="#导航-商品获取数据" class="headerlink" title="导航+商品获取数据"></a>导航+商品获取数据</h3><p><strong>上传数据</strong></p><blockquote><p>在<a href="https://unicloud.dcloud.net.cn/" target="_blank" rel="noopener">uniCloud</a>云数据库中创建tab和recommend集合并将导航栏信息和商品信息上传上去（详细操作请参照 5.2.轮播组件的数据上传到uniCloud ）</p></blockquote><p><strong>导航获取数据</strong></p><blockquote><p>导航通过 getData()获取相应数据（详细操作请参照 5.3.云函数操作数据库 ）</p></blockquote><p><strong>商品获取数据</strong></p><blockquote><ol><li>在cloudfunction中新建云函数getGoods，在getGoods下的index.js中编写以下代码</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">//获取数据库</span><br><span class="line">const db = uniCloud.database();</span><br><span class="line"></span><br><span class="line">exports.main = async (event, context) =&gt; &#123;</span><br><span class="line">  //event为客户端上传的参数</span><br><span class="line">  let list = event.list</span><br><span class="line">  let pageid = event.pageid</span><br><span class="line">  const banner = db.collection(list)// 获取集合的引用</span><br><span class="line">  .limit(6)  //开始拉取数据的数量</span><br><span class="line">  .skip(pageid*6)   //拉取数据的索引(每次下拉加载6条数据)</span><br><span class="line">  const res = await banner.get()</span><br><span class="line">  //返回数据给客户端</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>在common中的cloudFun中添加以下代码</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let getGoods = function(list,pageid) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">uniCloud.callFunction(&#123;</span><br><span class="line">name: &apos;getGoods&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">&quot;list&quot;: list,//list用于指定操作的集合名称</span><br><span class="line">&quot;pageid&quot;:pageid//pageid用于获取数据数量的标识</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">resolve(res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">reject(err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; getGoods &#125;//将函数导出</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>改写index.vue中created()生命周期函数中的代码，使用Promise.all同时获取轮播图、导航栏、商品信息</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">//请求数据</span><br><span class="line">let banner = &quot;banner&quot;</span><br><span class="line">let tab = &quot;tab&quot;</span><br><span class="line">let lising = &quot;recommend&quot;</span><br><span class="line">//基于promise.all 批量接受多个接口，同时得到多个数据</span><br><span class="line">Promise.all([getData(banner),getData(tab),getGoods(lising,this.pageid)])</span><br><span class="line">.then(res=&gt;&#123;</span><br><span class="line">this.banner = res[0].result.data//轮播数据</span><br><span class="line">this.tab = res[1].result.data//tab数据</span><br><span class="line">this.list = res[2].result.data//推荐数据</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err=&gt;&#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>组件接收数据</li></ol><p>– index.vue</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Content id=&quot;boxFixed&quot; :class=&quot;&#123;is_fixed:isFixed&#125;&quot; :tab=&quot;tab&quot;&gt;&lt;/Content&gt;</span><br><span class="line">&lt;view style=&quot;height: 140upx;&quot;&gt;&lt;/view&gt;//防止导航组件飘在商品组件上</span><br><span class="line">&lt;Article :list=&quot;list&quot; v-if=&quot;!loadinglist&quot;&gt;&lt;/Article&gt;</span><br></pre></td></tr></table></figure><p>– 组件中使用props接收数据，上面操作过这里不在过多赘述</p><h3 id="增加用户体验的自定义组件"><a href="#增加用户体验的自定义组件" class="headerlink" title="增加用户体验的自定义组件"></a>增加用户体验的自定义组件</h3><blockquote><p>首先在项目根目录下创建element文件夹用于存放自定义的组件</p></blockquote><ol><li><strong>tab切换的loading组件</strong><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/4350e4b0-724b-11ea-8bd0-2998ac5bbf7e.gif"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view class=&quot;loading&quot;&gt;</span><br><span class="line">&lt;view class=&quot;loader&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.loading&#123;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">padding: 20upx 0;</span><br><span class="line">&#125;</span><br><span class="line">.loader&#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">width: 40upx;</span><br><span class="line">height: 40upx;</span><br><span class="line">color: inherit;</span><br><span class="line">border: 7upx solid greenyellow;</span><br><span class="line">border-bottom-color: transparent;</span><br><span class="line">border-radius: 50%;</span><br><span class="line">animation: 1s loader linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">/* 360度旋转 */</span><br><span class="line">@keyframes loader&#123;</span><br><span class="line">0%&#123;</span><br><span class="line">transform: rotate(0deg);</span><br><span class="line">&#125;</span><br><span class="line">100%&#123;</span><br><span class="line">transform: rotate(360deg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><strong>没有数据时的提示</strong><blockquote><p>图片是从飞猪旅游的手机端复制过来的</p></blockquote></li></ol><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/29ec6d30-724d-11ea-8a36-ebb87efcf8c0.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view class=&quot;nonedata&quot;&gt;</span><br><span class="line">&lt;img src=&quot;../static/tab/noimage.png&quot; mode=&quot;widthFix&quot;&gt;</span><br><span class="line">&lt;text&gt;主人，这里什么都没有&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.nonedata&#123;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.nonedata img&#123;</span><br><span class="line">width: 200upx;</span><br><span class="line">height: 200upx;</span><br><span class="line">&#125;</span><br><span class="line">.nonedata text&#123;</span><br><span class="line">display: block;</span><br><span class="line">font-size: 30upx;</span><br><span class="line">color: rgb(153,153,153);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>进入小程序时loading加载</strong></li></ol><blockquote><p>页面还未完全获取数据时显示进入页面的loading加载</p></blockquote><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/ee8f2bf0-724d-11ea-b244-a9f5e5565f30.png" ><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view class=&quot;loadmin&quot;&gt;</span><br><span class="line">&lt;view class=&quot;home-load&quot;&gt;</span><br><span class="line">&lt;image src=&quot;../static/tab/homeload.svg&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.home-load&#123;</span><br><span class="line">display: flex;</span><br><span class="line">align-items: center;</span><br><span class="line">justify-content: center;</span><br><span class="line">width: 100%;</span><br><span class="line">height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.home-load image&#123;</span><br><span class="line">width: 200upx;</span><br><span class="line">height: 200upx;</span><br><span class="line">background: rgba(0,0,0,0.2);</span><br><span class="line">border-radius: 10upx;</span><br><span class="line">&#125;</span><br><span class="line">.loadmin&#123;</span><br><span class="line">position: fixed;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">z-index: 9999;</span><br><span class="line">overflow: hidden;</span><br><span class="line">background: rgba(242,243,244,0.6);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>全局引入自定义组件</strong></li></ol><blockquote><p>在项目根目录中的<a href="https://github.com/liZhuTao/uniCloud/blob/master/main.js" target="_blank" rel="noopener">main.js</a>中添加以下代码,就可以在项目中使用组件了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import App from &apos;./App&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">//引用tab切换的loading</span><br><span class="line">import loader from &apos;./element/loading.vue&apos;</span><br><span class="line">Vue.component(&apos;load-list&apos;,loader)</span><br><span class="line"></span><br><span class="line">//引入没有数据的提示</span><br><span class="line">import nonedata from &apos;./element/none.vue&apos;</span><br><span class="line">Vue.component(&apos;none-data&apos;,nonedata)</span><br><span class="line"></span><br><span class="line">//进入页面的loading加载</span><br><span class="line">import homeload from &apos;./element/homeload.vue&apos;</span><br><span class="line">Vue.component(&apos;home-load&apos;,homeload)</span><br><span class="line"></span><br><span class="line">App.mpType = &apos;app&apos;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    ...App</span><br><span class="line">&#125;)</span><br><span class="line">app.$mount()</span><br></pre></td></tr></table></figure><p>– index.vue的template，loadinglist、homeload、nonedata用于管理组件状态，为后面的vuex使用做准备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;load-list v-if=&quot;loadinglist&quot;&gt;&lt;/load-list&gt;</span><br><span class="line">&lt;Article :list=&quot;list&quot; v-if=&quot;!loadinglist&quot;&gt;&lt;/Article&gt;</span><br><span class="line">&lt;!-- 进入页面的loading加载 --&gt;</span><br><span class="line">&lt;home-load v-if=&quot;homeload&quot;&gt;&lt;/home-load&gt;</span><br><span class="line">&lt;!-- 没有数据的提示 --&gt;</span><br><span class="line">&lt;none-data v-if=&quot;nonedata&quot;&gt;&lt;/none-data&gt;</span><br></pre></td></tr></table></figure><h3 id="vuex状态管理"><a href="#vuex状态管理" class="headerlink" title="vuex状态管理"></a>vuex状态管理</h3><blockquote><p><a href="https://lizhutao.github.io/2020/03/30/2020-03-30-vuex-md/" target="_blank" rel="noopener">Vuex</a>是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><ol><li><p>首先在在pages中创建一个store文件夹，并在其中创建一个同名的js文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//导入vuex</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></li><li><p>在<code>store.js</code>创建中state</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//首页tab切换传输的值</span><br><span class="line">const alist=&#123;</span><br><span class="line">listing:[]</span><br><span class="line">&#125;</span><br><span class="line">//tab切换状态</span><br><span class="line">const load = &#123;</span><br><span class="line">loading:&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const navmin=&#123;</span><br><span class="line">loading:&apos;&apos;,</span><br><span class="line">naving:&apos;recomment&apos;,</span><br><span class="line">pageid:0,</span><br><span class="line">uniload:&apos;&apos;,</span><br><span class="line">nonedata:&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const state = &#123;</span><br><span class="line">alist,</span><br><span class="line">load,</span><br><span class="line">navmin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>store.js</code>创建中mutation</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">state,</span><br><span class="line">//同步操作</span><br><span class="line">mutations:&#123;</span><br><span class="line">listmuta(state,listdata)&#123;</span><br><span class="line">state.alist = &#123;</span><br><span class="line">listing:listdata</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">//tab切换的loading状态</span><br><span class="line">loadmuat(state,loading)&#123;</span><br><span class="line">state.load = &#123;</span><br><span class="line">loading:loading</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">//以对象传过来的参数</span><br><span class="line">navmuta(state,pullobj)&#123;</span><br><span class="line">state.navmin = &#123;</span><br><span class="line">loading:pullobj.loading,</span><br><span class="line">naving:pullobj.nav,</span><br><span class="line">pageid:pullobj.pageid,</span><br><span class="line">uniload:pullobj.uniload,</span><br><span class="line">nonedata:pullobj.nonedata</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">//tab切换没有数据的提示</span><br><span class="line">nonemuta(state,noneion)&#123;</span><br><span class="line">console.log(noneion)</span><br><span class="line">state.nonemin = &#123;</span><br><span class="line">nonedata:noneion</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在<code>index.vue</code>中的computed属性中使用<code>...mapState</code>取出vuex数据仓库中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">//取出vuex数据仓库的数据</span><br><span class="line">...mapState([&apos;alist&apos;,&apos;load&apos;,&apos;navmin&apos;,&apos;nonemin&apos;])</span><br><span class="line"></span><br><span class="line">//code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取到vuex数据仓库中的数据之后，将数据复制到对应的data数据中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//tab切换传值</span><br><span class="line">count()&#123;</span><br><span class="line">this.list = this.alist.listing</span><br><span class="line">&#125;,</span><br><span class="line">//tab切换时load的状态</span><br><span class="line">countload()&#123;</span><br><span class="line">this.loadinglist = this.load.loading</span><br><span class="line">&#125;,</span><br><span class="line">//以对象传值</span><br><span class="line">navdata()&#123;</span><br><span class="line">this.loadinglist = this.navmin.loading</span><br><span class="line">this.nav = this.navmin.naving</span><br><span class="line">this.pageid = this.navmin.pageid</span><br><span class="line">this.loadmore = this.navmin.uniload</span><br><span class="line">this.nonedata = this.navmin.nonedata</span><br><span class="line">&#125;,</span><br><span class="line">//当tab没有数据的状态</span><br><span class="line">noneted()&#123;</span><br><span class="line">this.nonedata = this.nonemin.nonedata</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将状态动态的绑定到组件上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;load-list v-if=&quot;loadinglist&quot;&gt;&lt;/load-list&gt;</span><br><span class="line">&lt;Article :list=&quot;list&quot; v-if=&quot;!loadinglist&quot;&gt;&lt;/Article&gt;</span><br><span class="line">&lt;!-- 进入页面的loading加载 --&gt;</span><br><span class="line">&lt;home-load v-if=&quot;homeload&quot;&gt;&lt;/home-load&gt;</span><br><span class="line">&lt;!-- 没有数据的提示 --&gt;</span><br><span class="line">&lt;none-data v-if=&quot;nonedata&quot;&gt;&lt;/none-data&gt;</span><br><span class="line">&lt;!-- 上拉加载组件 --&gt;</span><br><span class="line">&lt;view class=&quot;load-more&quot; v-if=&quot;loadmore&quot;&gt;</span><br><span class="line">&lt;uni-load-more :status=&quot;uniload&quot; color=&quot;#ffcc99&quot;&gt;&lt;/uni-load-more&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="社区页"><a href="#社区页" class="headerlink" title="社区页"></a>社区页</h2><p>社区页是大部分用户活动的重要场所，普通用户可以在社区中发布自己的商品或者动态，就避免了需要商家认证之后才可以上传商品，不过在社区之中的交易模式不通过平台，用户可以在选定商品之后，私下联系商家进行交易，这样设定有利于校园之间的文化交流。</p><p>社区页我们在设计的时候将它分为三个模块来进行开发，分别是是顶部的定位栏加上搜索栏，中间导航加上商品展示，以及底部的发布栏这三个组件。</p><p>在根目录中的pages文件夹中新建一个页面名为strategy它会默认在里面创建一个同名的vue文件。</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>我们在进入社区页之前要进行实时的定位，在定位完成之后就会展现出对应地区上的数据，当然这里我们也可以选择拒绝定位，这个时候默认定位会显示在湖南工程学院上，并将湖南工程学院中的数据加载出来。在这里我们使用的定位功能是腾讯地图开放平台。首先我们需要在浏览器中打开腾讯地图开放平台的官网（<a href="https://lbs.qq.com/），然后在开发文档中找到微信小程序JavaScript" target="_blank" rel="noopener">https://lbs.qq.com/），然后在开发文档中找到微信小程序JavaScript</a> SDK点击进入之后，我们需要按照以下步骤来在小程序中使用位置服务。</p><ol><li>申请开发者密钥（key）</li><li>开通webserviceAPI服务：控制台 -&gt; key管理 -&gt; 设置（使用该功能的key）-&gt; 勾选webserviceAPI -&gt; 保存 (小程序SDK需要用到webserviceAPI的部分服务，所以使用该功能的KEY需要具备相应的权限)</li><li>下载微信小程序JavaScriptSDK</li><li>安全域名设置，在“设置” -&gt; “开发设置”中设置request合法域名，添加<a href="https://apis.map.qq.com" target="_blank" rel="noopener">https://apis.map.qq.com</a></li><li>最后我们就可以根据文档使用腾讯位置服务了</li></ol><blockquote><p>首先我们需要将下载下来的微信小程序JavaScriptSDK复制到根目录下的common文件夹下，然后在strategy.vue中引入腾讯地图SDK核心类。这样我们就可以直接在前端中使用腾讯地图为我们提供的位置服务了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var QQMapWX = require(&apos;../../common/qqmap-wx-jssdk.js&apos;);</span><br><span class="line">var qqmapsdk;</span><br></pre></td></tr></table></figure><blockquote><p>再次之前我们需要在uni-app中配置一下获取位置信息的环境，可以在根目录下的pages.json配置文件的最后加上以下代码进行配置。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;permission&quot;: &#123;</span><br><span class="line">&quot;scope.userLocation&quot;: &#123;</span><br><span class="line">&quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在配置好环境之后，我们就可以对客户端中的定位组件进行代码编写以及样式布局了，首先我们需要在strategy文件夹下新建一个components文件夹来存放组件，并在里面新建address.vue组件，并编写代码，template模板以及样式布局的代码如下。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;view class=&quot;address&quot;&gt;</span><br><span class="line">&lt;view class=&quot;address-img&quot;&gt;</span><br><span class="line">&lt;image src=&quot;https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3628832208,3170804138&amp;fm=26&amp;gp=0.jpg&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;address-list&quot;&gt;</span><br><span class="line">&lt;view class=&quot;address-text&quot; @click=&quot;chooseCity()&quot;&gt;</span><br><span class="line">&lt;text class=&quot;words&quot;&gt;&#123;&#123;address&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;image src=&quot;../../../static/tab/jiantouxia.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;text class=&quot;words-eng&quot;&gt;welcome&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;!-- 搜索框 --&gt;</span><br><span class="line">&lt;view class=&quot;search&quot;&gt;</span><br><span class="line">&lt;view class=&quot;search-input&quot; @click=&quot;searchPage()&quot;&gt;</span><br><span class="line">&lt;img src=&quot;../../../static/tab/sousuo.svg&quot; mode=&quot;widthFix&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; placeholder=&quot;请输入文字&quot; disabled /&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;!-- 阴影 --&gt;</span><br><span class="line">&lt;view class=&quot;back&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.address-text &#123;display: flex; align-items: center;&#125;</span><br><span class="line">.address-text image &#123;width: 33upx;height: 33upx;padding-left: 30upx;&#125;</span><br><span class="line">.address &#123;position: relative;height: 400upx;&#125;</span><br><span class="line">.address-list &#123;position: absolute;left: 50upx;top: 100upx;z-index: 999;&#125;</span><br><span class="line">.address-img &#123;width: 100%;height: 400upx;&#125;</span><br><span class="line">.address-img image &#123;width: 750rpx !important; height: 400upx;&#125;</span><br><span class="line">.words &#123;font-size: 50upx;color: #ffffff;font-weight: bold;&#125;</span><br><span class="line">.words-eng &#123; font-size: 30upx; color: #ffffff;&#125;</span><br><span class="line">.back &#123;background: rgba(0, 51, 0, 0.3); position:  absolute; top: 0; left: 0; height: 400upx; width: 100%;&#125;</span><br><span class="line">/* 搜索 */</span><br><span class="line">.search&#123; position:  absolute ;left: 0upx; right: 0; bottom: 15upx; padding: 30upx 0;</span><br><span class="line">z-index: 999;&#125;</span><br><span class="line">.search-input&#123;height: 70upx;line-height: 70upx;width: 650upx;margin: 0 50upx;</span><br><span class="line">display: flex;border-radius: 50upx;flex-direction: row;background-color: #FFFFFF;&#125;</span><br><span class="line">.search-input img&#123;width: 40upx;height: 40upx;margin: auto 0 auto 20upx;&#125;</span><br><span class="line">.search-input input&#123;width: 100%;height: 70upx;line-height: 70upx;font-size: 30upx;</span><br><span class="line">color: #666666;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/d6c1fc50-95e8-11ea-9e8b-05a3242b26f2.jpg"><blockquote><p>当我们点击点定位的地址或者箭头的时候，会跳转到选择位置的页面，在这里我们给它绑定一个点击事件触发chooseCity()方法，实现当我们点击文字的时候会跳转到定位页面，来进行地址选择。在这里我们可以使用uni-app给我们提供的跳转页面的方法uni.navigateTo()来实现。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//选择城市</span><br><span class="line">chooseCity()&#123;</span><br><span class="line">uni.navigateTo(&#123;</span><br><span class="line">url:&apos;../city/city&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来我们就可以在pages文件夹下新建一个页面并命名为city,这样我们就可以在city下的同名vue文件中编写代码，对选择地区页面进行布局。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;!--搜索城市 --&gt;</span><br><span class="line">&lt;view class=&quot;margin-search&quot;&gt;</span><br><span class="line">&lt;view class=&quot;search-cont&quot;&gt;</span><br><span class="line">&lt;view class=&quot;city-search&quot;&gt;</span><br><span class="line">&lt;image src=&quot;../../static/tab/sousuo.svg&quot; mode=&quot;widthFix&quot; class=&quot;search-img&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot; placeholder=&quot;发现你感兴趣的目的地&quot; @focus=&quot;searchCity&quot; @input=&quot;searchInput&quot;/&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;search-code&quot; v-if=&quot;!citynone&quot; @click=&quot;canCal&quot;&gt;&lt;image src=&quot;../../static/tab/chaa.svg&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;!-- 点击搜索隐藏 --&gt;</span><br><span class="line">&lt;view v-if=&quot;citynone&quot;&gt;</span><br><span class="line">&lt;!-- 定位城市 --&gt;</span><br><span class="line">&lt;view class=&quot;city-view&quot;&gt;</span><br><span class="line">&lt;view class=&quot;city-text&quot;&gt;当前定位&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;posit-city&quot;&gt;</span><br><span class="line">&lt;image src=&quot;../../static/tab/gonglveb.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;text class=&quot;city-text&quot; @click=&quot;clickCity&quot;&gt;&#123;&#123;address&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;!-- 热门城市 --&gt;</span><br><span class="line">&lt;view class=&quot;hot-city&quot;&gt;热门搜索&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;menu-block&quot;&gt;</span><br><span class="line">&lt;block v-for=&quot;(item, index) in city&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">&lt;view @click=&quot;hotCity(item.name)&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;!-- 显示搜索的城市 --&gt;</span><br><span class="line">&lt;view class=&quot;results&quot; v-if=&quot;!citynone&quot;&gt;</span><br><span class="line">&lt;block v-for=&quot;(item, index) in citydata&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">&lt;view class=&quot;results-city&quot; @click=&quot;seekCity(item)&quot;&gt;</span><br><span class="line">&lt;image src=&quot;../../static/tab/gonglveb.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;text&gt;&#123;&#123; item &#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/92e32620-95e9-11ea-a30b-e311646dfaf2.jpg"><p>我们在编辑完布局之后，就可以对选择地区页进行业务逻辑的编写了，首先我们要在data()中返回定义的citynone、inputValue、address、citydata、keywoeds、pageroute以及city用来存储用户数据和一些共享的状态。然后就可以在methods中定义以下业务逻辑了。</p><blockquote><p>在触发搜索状态的时候，我们需要将当前定位，以及热门搜索等一系列布局给隐藏起来，这里我们使用citynone来做组件样式状态的管理。当我们点击搜索的时候，就将不需要的布局隐藏进入搜索状态。点击黑色的叉叉，关闭搜索状态，恢复隐藏的样式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">searchCity(e)&#123;</span><br><span class="line">console.log(e)</span><br><span class="line">this.citynone = false</span><br><span class="line">&#125;,</span><br><span class="line">canCal()&#123;</span><br><span class="line">this.citynone = true</span><br><span class="line">this.inputValue = &apos;&apos;</span><br><span class="line">this.citydata = &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 不管我们点击当前位置、热门搜索还是我们检索出来的地区，我们都要通过点击将数据记录下来，点击定位到城市名称就将数据存储到address中，到时候就可以将定位传值为社区页了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clickCity()&#123;</span><br><span class="line">let cityion = this.address</span><br><span class="line">this.backRoutes(cityion)</span><br><span class="line">&#125;,</span><br><span class="line">//取到热门景点</span><br><span class="line">hotCity(city)&#123;</span><br><span class="line">this.backRoutes(city)</span><br><span class="line">&#125;,</span><br><span class="line">//搜索城市</span><br><span class="line">seekCity(city)&#123;</span><br><span class="line">console.log(city)</span><br><span class="line">this.backRoutes(city)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>当我们选定定位地区的时候，点击之后就可以实现直接跳转回社区页，这样的话通过vuex来管理共享的地区数据，社区页就可以根据我们传过去的值来检索对应地区的数据呈现出来。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">backRoutes(cityion)&#123;</span><br><span class="line">//vuex传值</span><br><span class="line">if(this.pageroute == &apos;pages/travels/travels&apos;)&#123;</span><br><span class="line">//传给发表页面</span><br><span class="line">console.log(cityion)</span><br><span class="line">this.$store.commit(&apos;travemuta&apos;,cityion)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">//传给tab攻略页面</span><br><span class="line">console.log(cityion)</span><br><span class="line">this.$store.commit(&apos;citymuta&apos;,cityion)</span><br><span class="line">&#125;</span><br><span class="line">uni.navigateBack(&#123;</span><br><span class="line">delta:1</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>实时搜索城市的功能我们是借助的腾讯地图开放功能来实现的，JavaScript SDK会根据定位给我们返回定位的经纬度信息，我们需要处理这些信息来得到准企鹅的位置信息。在这里JavaScript SDK为我们提供了getSuggestion()方法来对地址进行逆解析操作，然后返回对应地址的信息。通过filter属性来限定我们解析出来的结果满足大学这个条件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">searchInput(e)&#123;</span><br><span class="line">qqmapsdk.getSuggestion(&#123;</span><br><span class="line">keyword:e.detail.value ,</span><br><span class="line">policy:1,</span><br><span class="line">// filter:&apos;category=大学&apos;,</span><br><span class="line">// region:&quot;湘潭市&quot;,</span><br><span class="line">success:(res)=&gt;&#123;</span><br><span class="line">let city = res.data</span><br><span class="line">this.citydata = city.map((item)=&gt;&#123;</span><br><span class="line">return item.title</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">fail:(err)=&gt;&#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/a699e1d0-95ea-11ea-b94e-47f67ecf8268.jpg">]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2020/03/29/2020-03-29-%E9%97%AD%E5%8C%85-md/"/>
      <url>/2020/03/29/2020-03-29-%E9%97%AD%E5%8C%85-md/</url>
      
        <content type="html"><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p>一般来说闭包就是能够读取其他函数内部变量的函数</p></blockquote><a id="more"></a><blockquote><p>从内存的角度来说函数执行形成不能被释放的私有栈内存，就是闭包</p></blockquote><blockquote><p>从机制的角度来说函数执行形成私有栈内存，保护私有作用域中的变量不与外界产生联系，这种保护机制就是闭包</p></blockquote><h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><ul><li><strong>保护（私有变量与外界没有必然联系）</strong></li><li><strong>保存（形成不销毁的栈内存，里面的私有变量就保存下来了）</strong></li></ul><h3 id="闭包作用域"><a href="#闭包作用域" class="headerlink" title="闭包作用域"></a>闭包作用域</h3><ol><li>创建函数<ul><li>开辟一个堆内存</li><li>把函数体中的代码以字符串的形式存储进去</li><li>把堆内存的地址赋值给函数名或变量名</li><li>函数在哪创建，那么它执行时的上级作用域就是谁</li></ul></li><li>函数执行<ul><li>形成一个全新的私有作用域、执行上下文、私有栈内存（执行一次形成一个，多个之间不会产生影响）</li><li>形参赋值&amp;变量提升</li><li>代码执行（把所属堆内存中的代码字符串拿出来一行一行执行）</li><li>遇到一个变量，首先看他是否为私有变量（形参和在私有作用域中声明的变量属于私有变量），私有变量就操作自己的变量即可，不是私有的则向上级作用域中查找，一直找到全局作用域为止=&gt;<strong>作用域链查找机制</strong></li><li>私有变量被私有栈内存保护起来了，所以与外界变量没有必然的联系，这就是闭包的保护机制<h3 id="堆栈内存释放问题（以webkit为例）"><a href="#堆栈内存释放问题（以webkit为例）" class="headerlink" title="堆栈内存释放问题（以webkit为例）"></a>堆栈内存释放问题（以webkit为例）</h3><h4 id="堆内存释放"><a href="#堆内存释放" class="headerlink" title="堆内存释放"></a>堆内存释放</h4><blockquote><p>创建一个引用类型值就会产生一个堆内存</p></blockquote></li></ul></li></ol><p>如果当前创建的堆内存不被占用，则会释放（浏览器会在会在空闲的时候查找每一个内存引用状况，不被占用的会被回收释放掉）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">  name:&apos;堆内存&apos;</span><br><span class="line">&#125;</span><br><span class="line">let oop=obj；</span><br><span class="line">//此时obj和oop都占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关联(null：空对象指针)</span><br><span class="line">obj=null;</span><br><span class="line">oop=null;</span><br></pre></td></tr></table></figure><h4 id="栈内存释放问题"><a href="#栈内存释放问题" class="headerlink" title="栈内存释放问题"></a>栈内存释放问题</h4><blockquote><p>栈内存形成的条件</p></blockquote><ul><li>运行浏览器时形成的全局作用域</li><li>手动执行函数形成的私有作用域</li><li>let和const形成的块级作用域</li></ul><blockquote><p>栈内存的销毁</p></blockquote><ul><li><p>全局栈内存：关闭的时候才会销毁（刷新页面时，销毁旧的栈内存，再生成新的栈内存）</p></li><li><p>私有栈内存：</p><blockquote><p>一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉（排除出现无限递归或死循环的情况）</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">fn()    //函数执行形成栈内存、执行完成栈内存被销毁</span><br></pre></td></tr></table></figure><blockquote><p>但是栈内存中的某些东西（如堆地址）被私有作用域以外的事物占用时，则当前栈内存不能立即被释放销毁（导致私有作用域外的私有变量等信息也保留下来了）</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let f = fn()    //f占用了fn执行时形成的栈内存中返回函数对应的堆，使得x执行形成的栈内存不能被释放</span><br></pre></td></tr></table></figure></li></ul><p>参考文献：</p><blockquote><p> –<a href="https://www.bilibili.com/video/BV1J4411B7Pa" target="_blank" rel="noopener">珠峰前端公开课</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码之extend拓展及JQ工具类方法</title>
      <link href="/2020/02/06/2020-02-06-jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89-md/"/>
      <url>/2020/02/06/2020-02-06-jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89-md/</url>
      
        <content type="html"><![CDATA[<h2 id="extend拓展"><a href="#extend拓展" class="headerlink" title="extend拓展"></a>extend拓展</h2><blockquote><p>jQuery.extend = jQuery.fn.extend = function(){ … };</p></blockquote><p>调用extend</p><blockquote><p>拓展到JQ对象上：一般是为了完善类库，提供更多的工具方法。</p></blockquote><ul><li>$.extend({});       </li><li>$.extend(true,{})</li></ul><a id="more"></a><blockquote><p>拓展到JQ原型上：一般是为了写插件，让JQ实例调用</p></blockquote><ul><li>$.fn.extend();      </li></ul><h3 id="规划传递的参数"><a href="#规划传递的参数" class="headerlink" title="规划传递的参数"></a>规划传递的参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.extend = function () &#123;</span><br><span class="line">        var options, name, src, copy, copyIsArray, clone,</span><br><span class="line">            target = arguments[0] || &#123;&#125;,</span><br><span class="line">            i = 1,</span><br><span class="line">            length = arguments.length,</span><br><span class="line">            deep = false;</span><br><span class="line"></span><br><span class="line">        // 如果第一个值传递的是布尔，让deep等于这个值，第二个值是我么需要扩展的对象</span><br><span class="line">        if (typeof target === &quot;boolean&quot;) &#123;</span><br><span class="line">            deep = target;</span><br><span class="line">            target = arguments[i] || &#123;&#125;;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 参数处理，当它不是对象也不是函数时，默认是对象</span><br><span class="line">        if (typeof target !== &quot;object&quot; &amp;&amp; !isFunction(target)) &#123;</span><br><span class="line">            target = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果只传递一个参数（除布尔值只有一个参数），则扩展jQuery本身</span><br><span class="line">        if (i === length) &#123;</span><br><span class="line">            target = this;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            // 如果传递的实参不为null</span><br><span class="line">            if ((options = arguments[i]) != null) &#123;</span><br><span class="line"></span><br><span class="line">                // 扩展基础对象</span><br><span class="line">                for (name in options) &#123;</span><br><span class="line">                    copy = options[name];</span><br><span class="line"></span><br><span class="line">                    // 防止对象原型污染以及死递归</span><br><span class="line">                    if (name === &quot;__proto__&quot; || target === copy) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 如果 深克隆 &amp;&amp; 属性值存在 &amp;&amp; 合并的是纯粹对象或数组，则递归</span><br><span class="line">                    if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) ||</span><br><span class="line">                            (copyIsArray = Array.isArray(copy)))) &#123;</span><br><span class="line">                        src = target[name];</span><br><span class="line"></span><br><span class="line">                        // copy是数组并且src也就是对象的属性不是数组，确保值得类型是准确的</span><br><span class="line">                        if (copyIsArray &amp;&amp; !Array.isArray(src)) &#123;</span><br><span class="line">                            clone = [];</span><br><span class="line">                        &#125; else if (!copyIsArray &amp;&amp; !jQuery.isPlainObject(src)) &#123;</span><br><span class="line">                            clone = &#123;&#125;;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            clone = src;</span><br><span class="line">                        &#125;</span><br><span class="line">                        copyIsArray = false;</span><br><span class="line"></span><br><span class="line">                        // 深克隆</span><br><span class="line">                        target[name] = jQuery.extend(deep, clone, copy);</span><br><span class="line"></span><br><span class="line">                        // 确保属性值存在</span><br><span class="line">                    &#125; else if (copy !== undefined) &#123;</span><br><span class="line">                        target[name] = copy;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回修改后的对象</span><br><span class="line">        return target;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中 1~13 行，处理的是<code>$.extend({})</code>和<code>$.extend(true,{})</code>，可以看出extend函数的第一个值是<code>[boolean]</code>可传可不传,第二个参数<code>对象或function</code>是必传,通过借鉴它的实现方式，我们可以通过以下代码实现第二个参数是必传值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 传递的值：数字、函数 或者 函数（数字不传递默认是0）</span><br><span class="line">function fn() &#123;</span><br><span class="line">    var x = 0,</span><br><span class="line">        y = arguments[0];</span><br><span class="line">    if (typeof y === &quot;number&quot;) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = arguments[1];</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">fn(0, function () &#123;&#125;);</span><br><span class="line">fn(function () &#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>selector 支持三种数据格式</p><ol><li>[string]<br> 选择器      $(‘.box’)<br> 创建元素    $(‘<div>…</div>‘)</li><li>[元素对象：JS原生对象]<br>  把原生JS对象转化为JQ对象（只有这样才能调取JQ中的方法）<pre><code>var box = document.getElementById(&quot;box&quot;);$(&apos;box&apos;)</code></pre>  把JQ对象转化为原生JS对象，直接基于索引获取即可，例如：$A[0]<pre><code>在项目中建议使用JQ中自带的get方法实现，因为它更完善，支持负数索引$A.get(0)eq方法也是根据索引集合中的某一项（也支持负数），只不过返回的结果不是原生JS而是JQ的实例</code></pre></li><li>[function]<br>  $(function(){})     等待页面中的DOM结构加载完毕再执行函数，等价于$(document).ready(function(){})</li></ol></li></ul><p>注意事项</p><blockquote><p>$(“.box”) === $(“.box”) =&gt;false 这是两个实例,引用地址不相同</p></blockquote><pre><code>所以操作的时候不要：    $(&quot;box&quot;).css();    $(&quot;box&quot;).attr();    $(&quot;box&quot;).click();正确的操作是：    let $box = $(&quot;box&quot;);    $box.css();    $box.attr();    $box.click();</code></pre><h2 id="jQuery工具类方法"><a href="#jQuery工具类方法" class="headerlink" title="jQuery工具类方法"></a>jQuery工具类方法</h2><h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><blockquote><p>上一篇文章中jQuery原型上的each是直接调用的工具的each方法，所以jQuery中只有一个each方法</p></blockquote><blockquote><p><code>each</code>遍历数组/类数组/对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">    each: function (obj, callback) &#123;</span><br><span class="line">        var length, i = 0;</span><br><span class="line">        if (isArrayLike(obj)) &#123;</span><br><span class="line">            // 数组或者类数组基于for循环完成</span><br><span class="line">            length = obj.length;</span><br><span class="line">            for (; i &lt; length; i++) &#123;</span><br><span class="line">                var item = obj[i];</span><br><span class="line">                var res = callback.call(item, i, item);</span><br><span class="line">                //在内置forEach的基础上可以控制循环结束：只要回调函数中返回false，循环就可以结束了</span><br><span class="line">                if (res === false) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果是对象，基于for in循环</span><br><span class="line">            for (i in obj) &#123;</span><br><span class="line">                if (callback.call(obj[i], i, obj[i]) === false) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>相当于重写了forEach循环，传递的参数顺序相反，同时解决了forEach循环不能跳出循环的缺点</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.each([10, 20, 30], function(i,item)&#123;</span><br><span class="line">    // this -&gt; 当前遍历这一项</span><br><span class="line">    // i当前遍历这一项的索引  item当前遍历这一项</span><br><span class="line">    if(item&gt;20) return false;</span><br><span class="line">&#125;);</span><br><span class="line">// $(...).each(function()&#123;...&#125;)  =&gt; $.each($(...),function(i,item)&#123;...&#125;)</span><br></pre></td></tr></table></figure><h3 id="makeArray-amp-inArray"><a href="#makeArray-amp-inArray" class="headerlink" title="makeArray &amp; inArray"></a>makeArray &amp; inArray</h3><blockquote><p><code>makeArray</code>函数用于将一个类似数组的对象转换为真正的数组对象</p></blockquote><blockquote><p><code>inArray</code>函数用于在数组中查找指定值，并返回它的索引值（如果没有找到，则返回-1）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">    makeArray: function (arr, results) &#123;</span><br><span class="line">    var ret = results || [];</span><br><span class="line"></span><br><span class="line">    if (arr != null) &#123;</span><br><span class="line">    if (isArrayLike(Object(arr))) &#123;</span><br><span class="line">    jQuery.merge(ret,</span><br><span class="line">    typeof arr === &quot;string&quot; ? [arr] : arr</span><br><span class="line">    );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    push.call(ret, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">    &#125;,</span><br><span class="line">    inArray: function (elem, arr, i) &#123;</span><br><span class="line">return arr == null ? -1 : indexOf.call(arr, elem, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="merge-amp-grep"><a href="#merge-amp-grep" class="headerlink" title="merge &amp; grep"></a>merge &amp; grep</h3><blockquote><p><code>merge</code>函数用于合并两个数组内容到第一个数组</p></blockquote><blockquote><p><code>grep</code>函数使用指定的函数过滤数组中的元素，并返回过滤后的数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">    merge: function (first, second) &#123;</span><br><span class="line">var len = +second.length,</span><br><span class="line">j = 0,</span><br><span class="line">i = first.length;</span><br><span class="line"></span><br><span class="line">for (; j &lt; len; j++) &#123;</span><br><span class="line">first[i++] = second[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first.length = i;</span><br><span class="line"></span><br><span class="line">return first;</span><br><span class="line">&#125;,</span><br><span class="line">    grep: function (elems, callback, invert) &#123;</span><br><span class="line">var callbackInverse,</span><br><span class="line">matches = [],</span><br><span class="line">i = 0,</span><br><span class="line">length = elems.length,</span><br><span class="line">callbackExpect = !invert;</span><br><span class="line"></span><br><span class="line">for (; i &lt; length; i++) &#123;</span><br><span class="line">callbackInverse = !callback(elems[i], i);</span><br><span class="line">if (callbackInverse !== callbackExpect) &#123;</span><br><span class="line">matches.push(elems[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return matches;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote><p><code>map</code>函数用于使用指定函数处理数组中的每个元素(或对象的每个属性)，并将处理结果封装为新的数组返回</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">    map: function (elems, callback, arg) &#123;</span><br><span class="line">var length, value,</span><br><span class="line">i = 0,</span><br><span class="line">ret = [];</span><br><span class="line"></span><br><span class="line">// Go through the array, translating each of the items to their new values</span><br><span class="line">if (isArrayLike(elems)) &#123;</span><br><span class="line">length = elems.length;</span><br><span class="line">for (; i &lt; length; i++) &#123;</span><br><span class="line">value = callback(elems[i], i, arg);</span><br><span class="line"></span><br><span class="line">if (value != null) &#123;</span><br><span class="line">ret.push(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Go through every key on the object,</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (i in elems) &#123;</span><br><span class="line">value = callback(elems[i], i, arg);</span><br><span class="line"></span><br><span class="line">if (value != null) &#123;</span><br><span class="line">ret.push(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Flatten any nested arrays</span><br><span class="line">return flat(ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="实现JQ集合的可迭代性"><a href="#实现JQ集合的可迭代性" class="headerlink" title="实现JQ集合的可迭代性"></a>实现JQ集合的可迭代性</h2><blockquote><p>只有变为可迭代的，才能基于for of循环来实现遍历</p></blockquote><p>for of 循环</p><ul><li>可以被迭代的数据结构（拥有这个属性的 Symbol.iterator），可以基于for of循环处理 </li><li>数组  Array.prototype[Symbol.iterator] = function values() { [native code] }</li><li>arguments   arguments[Symbol.iterator] = function values() { [native code] }</li><li>NodeList节点类数组集合</li><li>HTMLCollection元素集合</li><li>new Set()</li><li>new Map()</li><li>…</li><li>普通对象默认是不具备可迭代性的，因为它不具备 Symbol.iterator 这个属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    length: 2</span><br><span class="line">&#125;;</span><br><span class="line">for (let item of obj) &#123; //Uncaught TypeError: obj is not iterable</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    length: 2,</span><br><span class="line">    [Symbol.iterator]: Array.prototype[Symbol.iterator]</span><br><span class="line">&#125;;</span><br><span class="line">for (let item of obj) &#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以JQ中做了以下操作，将JQ集合变为可迭代的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(function(global,factory)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;)(typeof window !== &quot;undefined&quot; ? window : this, function(window,noGlobal)&#123;</span><br><span class="line">    var version = &quot;3.5.1&quot;,</span><br><span class="line">        jQuery = function (selector, context) &#123;</span><br><span class="line">            return new jQuery.fn.init(selector, context);</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">    if (typeof Symbol === &quot;function&quot;) &#123;</span><br><span class="line">        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">     if (typeof noGlobal === &quot;undefined&quot;) &#123;</span><br><span class="line">        window.jQuery = window.$ = jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码之选择器代理及JQ原型</title>
      <link href="/2020/02/04/2020-02-04-jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89-md/"/>
      <url>/2020/02/04/2020-02-04-jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89-md/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery核心"><a href="#jQuery核心" class="headerlink" title="jQuery核心"></a>jQuery核心</h2><blockquote><p>在上一篇文章中，我们知道jQuery函数是定义在B函数中的，也就是说主要的核心代码都是在自执行函数的回调函数中，上次我们讨论的是jQuery中的环境校验以及数据类型检测，这一章节开始介绍jQuery的一些核心代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(function(global,factory)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;)(typeof window !== &quot;undefined&quot; ? window : this, function(window,noGlobal)&#123;</span><br><span class="line">    /*</span><br><span class="line">     * jQuery核心源码</span><br><span class="line">     */</span><br><span class="line">    var version = &quot;3.5.1&quot;,</span><br><span class="line">        jQuery = function (selector, context) &#123;</span><br><span class="line">            return new jQuery.fn.init(selector, context);</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">     if (typeof noGlobal === &quot;undefined&quot;) &#123;</span><br><span class="line">        window.jQuery = window.$ = jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>$  === <code>jQuery</code> === <code>函数内部的jQuery</code></p></blockquote><blockquote><p>所谓的jQuery选择器就是将函数内部的jQuery函数执行,[selector]代表选择器，[context]上下文（默认是document）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$([selector],[context]);</span><br><span class="line">jQuery([selector],[context]);</span><br></pre></td></tr></table></figure><h3 id="转让使用权"><a href="#转让使用权" class="headerlink" title="转让使用权"></a>转让使用权</h3><blockquote><p>多库共存的情况下，为了防止冲突，可以转让$的使用权</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var _jQuery = window.jQuery,</span><br><span class="line">        _$ = window.$;          //将选择器备份</span><br><span class="line">    jQuery.noConflict = function (deep) &#123;       //基于noConflict函数转移$的使用权</span><br><span class="line">        if (window.$ === jQuery) &#123;</span><br><span class="line">            window.$ = _$;</span><br><span class="line">        &#125;</span><br><span class="line">        if (deep &amp;&amp; window.jQuery === jQuery) &#123;</span><br><span class="line">            window.jQuery = _jQuery;            </span><br><span class="line">        &#125;</span><br><span class="line">        return jQuery;      //将选择器返回，外面就可以自定义值来接收作为新的选择器</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>转让$使用权的思路：导入JQ的时候，首先它会记录之前$的使用情况，存储到<em>$中；并且让$归为JQ；当执行noConflict的时候，把$的使用权回归</em>$，返回JQ，外部变量j是JQ新的代言人；多版本jQuery，deep为true，也是同样转让的思路将jQuery的使用权也转让除去</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * &lt;script src=&apos;zepto.min.js&apos;&gt;   Zepto使用的也是$</span><br><span class="line"> *   $ -&gt; Zepto</span><br><span class="line"> * </span><br><span class="line"> * &lt;script src=&apos;jquery.min.js&apos;&gt;  jQuery使用的也是$</span><br><span class="line"> *   做了一些事情:</span><br><span class="line"> *      + var _$=window.$   _$-&gt;Zepto</span><br><span class="line"> *   $ -&gt; jQuery</span><br><span class="line"> * </span><br><span class="line"> * var j=$.noConflict() 转让了$使用权</span><br><span class="line"> *   做了一些事情：</span><br><span class="line"> *      + window.$ = _$</span><br><span class="line"> *      + return jQuery</span><br><span class="line"> *   $ -&gt; Zepto</span><br><span class="line"> *   j -&gt; jQuery</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="jQuery的本质"><a href="#jQuery的本质" class="headerlink" title="jQuery的本质"></a>jQuery的本质</h3><blockquote><p>jQuery的本质：jQuery既是一个普通函数、也是一个构造函数、也是一个普通的对象</p></blockquote><ul><li>jQuery.prototype「类」 供其实例调用的公共属性方法  $(…).xxx()</li><li>jQuery「对象」 这上面的方法是类库提供的工具类方法  $.xxx()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 这里为了方便我们观看，还是先用B来接收这个函数</span><br><span class="line">var B = function(window,noGlobal)&#123;</span><br><span class="line">    /*</span><br><span class="line">     * jQuery核心源码</span><br><span class="line">     */</span><br><span class="line">    var version = &quot;3.5.1&quot;,</span><br><span class="line">        jQuery = function (selector, context) &#123;</span><br><span class="line">            return new jQuery.fn.init(selector, context);</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">        constructor: jQuery,</span><br><span class="line">        jquery: version,</span><br><span class="line">        length:0,</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // $(...)执行是创造了init这类的一个实例，实例.__proto__===init.prototype===jQuery.prototype，所以也可以说$(...)创造出来的是jQuery类的一个实例 </span><br><span class="line">    //=&gt;“把jQuery当作普通函数执行，也可以创造它的一个实例「工厂模式」”</span><br><span class="line">    var init = jQuery.fn.init = function (selector, context, root) &#123; //... &#125;;</span><br><span class="line">    init.prototype = jQuery.fn;</span><br><span class="line">    </span><br><span class="line">     if (typeof noGlobal === &quot;undefined&quot;) &#123;</span><br><span class="line">        window.jQuery = window.$ = jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>init代理</strong><br><img src="/images/loading.png" data-original="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-blogimg/f7104210-0310-11eb-8a36-ebb87efcf8c0.png"></p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote><p>通过选择器$(…)执行创造了init这类的一个实例，也是jQuery的实例是一个类数组集合，返回值通过<code>jQuery.makeArray</code>方法转换成一个类数组</p></blockquote><blockquote><p>init函数的主要目的是判断传入值，根据传入的数据做不同的处理</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var rootjQuery = jQuery(document);</span><br><span class="line">var init = jQuery.fn.init = function (selector, context, root) &#123;</span><br><span class="line">        var match, elem;</span><br><span class="line">        // &quot;&quot;/null/undefined/false 直接返回他的空实例</span><br><span class="line">        if (!selector) return this;</span><br><span class="line">        </span><br><span class="line">        root = root || rootjQuery;      //root是$或者jQuery选择器</span><br><span class="line"></span><br><span class="line">        if (typeof selector === &quot;string&quot;) &#123;</span><br><span class="line">            // 字符串</span><br><span class="line">            //   + HTML结构字符串  创建一个DOM元素</span><br><span class="line">            //   + 选择器字符串  获取页面中符合条件的元素</span><br><span class="line">            if (selector[0] === &quot;&lt;&quot; &amp;&amp;</span><br><span class="line">                selector[selector.length - 1] === &quot;&gt;&quot; &amp;&amp;</span><br><span class="line">                selector.length &gt;= 3) &#123;</span><br><span class="line">                    //...</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //...</span><br><span class="line">                &#125; </span><br><span class="line">            //... 这里面的代码就比较复杂了</span><br><span class="line">            </span><br><span class="line">        &#125; else if (selector.nodeType) &#123;</span><br><span class="line">            // 原生DOM元素对象(JS内置方法获取的)：把DOM对象变为了一个类数组集合</span><br><span class="line">            this[0] = selector;</span><br><span class="line">            this.length = 1;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (isFunction(selector)) &#123;</span><br><span class="line">            // 函数 $(function()&#123;&#125;) &lt;==&gt; $(document).ready(function()&#123;&#125;)</span><br><span class="line">            // 等待页面中DOM结构加载完成(DOMContentLoaded)触发回调函数函数执行，触发点优先于window.onload(DOM结构及页面中所有资源都加载完才会触发执行)</span><br><span class="line">            return root.ready !== undefined ?</span><br><span class="line">                root.ready(selector) :</span><br><span class="line">                selector(jQuery);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 创造一个类数组集合</span><br><span class="line">        return jQuery.makeArray(selector, this);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>传入值为函数的时候不是获得元素，而是相当于事件绑定</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    // DOM结构加载完触发执行</span><br><span class="line">    // JQ不论是在HEAD还是BODY末尾导入，都可以获取到DOM元素</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * 真实项目中，我们会遇到JQ对象(JQ实例/类数组集合)和原生DOM对象相互切换的过程 </span><br><span class="line"> *   + JQ对象不能用原生内置的属性方法</span><br><span class="line"> *   + 原生DOM对象也不能用JQ原型上的方法</span><br><span class="line"> * </span><br><span class="line"> * 原生DOM-&gt;JQ对象</span><br><span class="line"> *   + $(原生DOM)</span><br><span class="line"> * </span><br><span class="line"> * JQ对象-&gt;原生DOM</span><br><span class="line"> *   + JQ对象[索引]</span><br><span class="line"> *   + JQ对象.get([索引])  上述两个都是获取原生DOM对象的</span><br><span class="line"> *   + JQ对象.eq([索引])   获取的结果还是JQ对象(类数组集合/JQ新的实例)，里面存储一项：索引对应的</span><br><span class="line"> */</span><br><span class="line">let body = document.body;</span><br><span class="line">console.dir(body);</span><br><span class="line">let $body = $(body);</span><br><span class="line">console.log($body);</span><br></pre></td></tr></table></figure><h2 id="jQuery的原型"><a href="#jQuery的原型" class="headerlink" title="jQuery的原型"></a>jQuery的原型</h2><h3 id="get-amp-eq"><a href="#get-amp-eq" class="headerlink" title="get &amp; eq"></a>get &amp; eq</h3><blockquote><p><code>get</code>把JQ类数组集合变为数组集合(Array的实例),支持负数索引</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    constructor: jQuery,</span><br><span class="line">    jquery: version,</span><br><span class="line">    length:0,</span><br><span class="line">    </span><br><span class="line">    get: function (num) &#123;</span><br><span class="line">        // 把JQ类数组集合变为数组集合(Array的实例)</span><br><span class="line">        if (num == null) &#123;</span><br><span class="line">            return Array.prototype.slice.call(this);</span><br><span class="line">        &#125;</span><br><span class="line">        // 支持负数索引</span><br><span class="line">        return num &lt; 0 ? this[num + this.length] : this[num];</span><br><span class="line">    &#125;,</span><br><span class="line">    eq: function (i) &#123;</span><br><span class="line">        var len = this.length,</span><br><span class="line">            j = +i + (i &lt; 0 ? len : 0);</span><br><span class="line">        return this.pushStack(j &gt;= 0 &amp;&amp; j &lt; len ? [this[j]] : []);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pushStack"><a href="#pushStack" class="headerlink" title="pushStack"></a>pushStack</h3><blockquote><p>传递一个数组，把其变为JQ实例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    constructor: jQuery,</span><br><span class="line">    jquery: version,</span><br><span class="line">    length:0,</span><br><span class="line">    </span><br><span class="line">    pushStack: function (elems) &#123;</span><br><span class="line">        // this.constructor()：jQuery()，空集合(JQ实例)</span><br><span class="line">        // 合并后的结果，既是一个JQ实例(集合)，也包含你传递进来的这些项的信息</span><br><span class="line">        var ret = jQuery.merge(this.constructor(), elems);</span><br><span class="line">        ret.prevObject = this;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-amp-even-amp-odd"><a href="#map-amp-even-amp-odd" class="headerlink" title="map &amp; even &amp; odd"></a>map &amp; even &amp; odd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    map: function (callback) &#123;</span><br><span class="line">return this.pushStack(jQuery.map(this, function (elem, i) &#123;</span><br><span class="line">return callback.call(elem, i, elem);</span><br><span class="line">&#125;));</span><br><span class="line">&#125;,</span><br><span class="line">even: function () &#123;</span><br><span class="line">return this.pushStack(jQuery.grep(this, function (_elem, i) &#123;</span><br><span class="line">return (i + 1) % 2;</span><br><span class="line">&#125;));</span><br><span class="line">&#125;,</span><br><span class="line">odd: function () &#123;</span><br><span class="line">return this.pushStack(jQuery.grep(this, function (_elem, i) &#123;</span><br><span class="line">return i % 2;</span><br><span class="line">&#125;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="each-amp-sort-amp-splice-amp-slice"><a href="#each-amp-sort-amp-splice-amp-slice" class="headerlink" title="each &amp; sort &amp; splice &amp; slice"></a>each &amp; sort &amp; splice &amp; slice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    each: function (callback) &#123;</span><br><span class="line">return jQuery.each(this, callback);</span><br><span class="line">&#125;,</span><br><span class="line">sort: [].sort,</span><br><span class="line">splice: [].splice,</span><br><span class="line">slice: function () &#123;</span><br><span class="line">return this.pushStack(slice.apply(this, arguments));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    toArray: function () &#123;</span><br><span class="line">return slice.call(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="first-amp-last"><a href="#first-amp-last" class="headerlink" title="first &amp; last"></a>first &amp; last</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    first: function () &#123;</span><br><span class="line">return this.eq(0);</span><br><span class="line">&#125;,</span><br><span class="line">last: function () &#123;</span><br><span class="line">return this.eq(-1);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery源码之环境校验及数据类型检测</title>
      <link href="/2020/02/03/2020-2-3-jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89-md/"/>
      <url>/2020/02/03/2020-2-3-jQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89-md/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery库"><a href="#jQuery库" class="headerlink" title="jQuery库"></a>jQuery库</h2><blockquote><p>jQuery作为前端划时代的类库，虽然现在市场上应用的已经不多了，但是他的一些思想还是非常值得学习和借鉴的</p></blockquote><h2 id="jQuery环境校验"><a href="#jQuery环境校验" class="headerlink" title="jQuery环境校验"></a>jQuery环境校验</h2><h3 id="自执行函数的参数传递"><a href="#自执行函数的参数传递" class="headerlink" title="自执行函数的参数传递"></a>自执行函数的参数传递</h3><blockquote><p>打开jQuery的源码，从开头到末尾，最外层的结构就是下面的代码</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(global,factory)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;)(typeof window !== &quot;undefined&quot; ? window : this, function(window,noGlobal)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>如果上面这种代码形式你看到不是很明白，不妨将参数抽离出来，之后的结构就非常的明显了，就是一个立即执行函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var A = typeof window !== &quot;undefined&quot; ? window : this;</span><br><span class="line">// 利用暂时性死区，检测window是否被声明</span><br><span class="line">// + JS在浏览器环境下执行：存在window (浏览器会创建window变量来接收全局对象global的值)</span><br><span class="line">// + JS在node环境下执行：不存在window (全局对象是global)</span><br><span class="line">// -&gt; 所以这行代码是用来检测执行环境实在浏览器中还是node中</span><br><span class="line"></span><br><span class="line">var B = function(window,noGlobal)&#123; //... &#125;</span><br><span class="line">// 回调函数：将函数作为参数传递给自执行函数</span><br><span class="line"></span><br><span class="line">(function(global,factory)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;)(A,B)</span><br></pre></td></tr></table></figure><ul><li>暂时性死区：一个未被声明的变量在typeof检测的时候不会报错，只是返回“undefined”</li></ul><h3 id="自执行函数中的环境判断"><a href="#自执行函数中的环境判断" class="headerlink" title="自执行函数中的环境判断"></a>自执行函数中的环境判断</h3><blockquote><p>将自执行函数展开，会看到以下代码，这部分的代码主要是区分函数的执行环境是window还是node</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(function (global, factory) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    // global:  根据 A 的返回值传入  window / global</span><br><span class="line">    // factory: 传入的 B 回调函数</span><br><span class="line"></span><br><span class="line">    // 验证是否支持CommonJS/ES6Module规范（支持这个规范的是Node.js）</span><br><span class="line">    if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) &#123;</span><br><span class="line">        // 代码是运行在node环境下的（或者是基于webpack打包运行的项目）</span><br><span class="line">        module.exports = global.document ?</span><br><span class="line">            factory(global, true) :</span><br><span class="line">            function (w) &#123;</span><br><span class="line">                if (!w.document) &#123;</span><br><span class="line">                    throw new Error(&quot;jQuery requires a window with a document&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return factory(w);</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 运行在浏览器window或者webview(相当于浏览器)中</span><br><span class="line">        // =&gt; B(window)</span><br><span class="line">        factory(global);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(A, B);</span><br></pre></td></tr></table></figure><blockquote><p>根据上述的代码，在环境判断之后会执行<code>factory函数</code>也就是我们抽离出来的<code>B函数</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var B = function(window,noGlobal)&#123; //... &#125;</span><br><span class="line">// 如果是在浏览器环境中执行的JS代码：-&gt; factory(global)</span><br><span class="line">// + window : window</span><br><span class="line">// + noGlobal : undefined</span><br><span class="line"></span><br><span class="line">// 如果是NODE下执行:-&gt; factory(global, true)</span><br><span class="line">// + window : global</span><br><span class="line">// + noGlobal : true</span><br></pre></td></tr></table></figure><blockquote><p>看到这里很多小伙伴应该明白了，我们要研究的jquery源码都是定义在B函数中的，而B函数就是用来存储jquery所需变量的一个闭包，前面的一大堆操作知识为了区分执行环境</p></blockquote><h3 id="全局暴露函数"><a href="#全局暴露函数" class="headerlink" title="全局暴露函数"></a>全局暴露函数</h3><blockquote><p>将B函数（传给自执行函数的回调函数）展开，看到前面直接var了一个jQuery，然后先不要管其他代码，直接拉到B函数的最底部</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var B = function (window, noGlobal) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    </span><br><span class="line">    var jQuery = function (selector, context) &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    // B 函数的最底部</span><br><span class="line">    if (typeof noGlobal === &quot;undefined&quot;) &#123;</span><br><span class="line">        // 浏览器环境下:暴露给全局的两个变量，值都是私有的jQuery</span><br><span class="line">        // + jQuery</span><br><span class="line">        // + $</span><br><span class="line">        window.jQuery = window.$ = jQuery;  //浏览器环境下暴露全局</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return jQuery;  // node环境将return的jQuery下通过模块导出</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = window.$ = jQuery;</span><br></pre></td></tr></table></figure><blockquote><p>将jQuery通过给window添加属性的方式，来将jQuery函数暴露给全局，这样我们就可以在全局环境中是用jQuery了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$();</span><br><span class="line">jQuery();</span><br></pre></td></tr></table></figure><h2 id="B函数详解（闭包）"><a href="#B函数详解（闭包）" class="headerlink" title="B函数详解（闭包）"></a>B函数详解（闭包）</h2><blockquote><p>通过前面的分析，我们知道jQuery的所有代码都是定义在B函数中的，B函数是一个为jQuery存储变量的闭包，所以jQuery中使用的公共变量和工具方法都会定义在这个闭包中</p></blockquote><h3 id="jQuery中的数据类型检测"><a href="#jQuery中的数据类型检测" class="headerlink" title="jQuery中的数据类型检测"></a>jQuery中的数据类型检测</h3><blockquote><p>jQuery作为一个大型类库，会遇到非常多的数据处理，而数据类型检测是这一切的前提，所以在B函数中定义了数据类型检测以及数据转换的公用方法</p></blockquote><h4 id="直接调用各类原型上的方法"><a href="#直接调用各类原型上的方法" class="headerlink" title="直接调用各类原型上的方法"></a>直接调用各类原型上的方法</h4><blockquote><p>这里定义的方法会出现在后面讲解的源码中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var class2type = &#123;&#125;;</span><br><span class="line">var toString = class2type.toString;         //Object.prototype.toString</span><br><span class="line">var hasOwn = class2type.hasOwnProperty;     //Object.prototype.hasOwnProperty</span><br><span class="line">var fnToString = hasOwn.toString;           //Function.prototype.toString</span><br><span class="line">var ObjectFunctionString = fnToString.call(Object); //&quot;function Object() &#123; [native code] &#125;&quot; 借用Function的toString将Object函数的代码打印出来</span><br><span class="line">var getProto = Object.getPrototypeOf;       //获取对象原型链__proto__指向的原型</span><br></pre></td></tr></table></figure><h4 id="toType"><a href="#toType" class="headerlink" title="toType"></a>toType</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(&quot;Boolean Number String Function Array Data RegExp Object Error Symbol&quot;.split(&quot; &quot;),</span><br><span class="line">    function(_i,name)&#123;</span><br><span class="line">        class2type[&quot;[object &quot; + name + &quot;]&quot;] = name.toLowerCase();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">function toType(obj) &#123;</span><br><span class="line">    // null/undefiend</span><br><span class="line">    if (obj == null) &#123;</span><br><span class="line">        return obj + &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 基本数据类型检测基于typeof</span><br><span class="line">    // 引用数据类型检测基于Object.prototype.toString.call</span><br><span class="line">    return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?</span><br><span class="line">        class2type[toString.call(obj)] || &quot;object&quot; :</span><br><span class="line">        typeof obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>建立数据类型检测的映射表 [object Xxxx] : xxxx，后期在数据类型检测的时候就可以通过属性名来获取类型的属性值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 上面的的jQuery.each(...)就相当于，下面的代码</span><br><span class="line">var typeAry = [&quot;Boolean&quot;,&quot;Number&quot;,&quot;String&quot;,&quot;Function&quot;,&quot;Array&quot;,&quot;Date&quot;,&quot;RegExp&quot;,&quot;Object&quot;,&quot;Error&quot;,&quot;Symbol&quot;];</span><br><span class="line">typeAry.forEach(name =&gt; &#123;</span><br><span class="line">    class2type[`[object $&#123;name&#125;]`] = name..toLowerCase();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 如果觉得映射表不全，可以添加BigInt、GeneratorFunction...</span><br></pre></td></tr></table></figure><blockquote><p>为什么要建立映射表？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let n = new Number(10);</span><br><span class="line">typtof n;       //=&gt;object</span><br><span class="line"></span><br><span class="line">// 直接使用typyof来检测的时候对于通过构造函数new出来的实例时，结果是object</span><br><span class="line">// 建立映射表的好处是只要你是object我就到映射表中通过toString的值找对应属性打印出来</span><br><span class="line">// 并且可以可以自定义类型，比如Date对象，你可以控制它的结果是object或者date，让检测结果更加灵活</span><br></pre></td></tr></table></figure><h4 id="isFunction-amp-isWindow"><a href="#isFunction-amp-isWindow" class="headerlink" title="isFunction &amp; isWindow"></a>isFunction &amp; isWindow</h4><blockquote><p><code>isFunction</code>检测函数是否为一个函数，主要是为了处理兼容，防止异常情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var isFunction = function isFunction(obj) &#123;</span><br><span class="line">    // i.e., `typeof document.createElement( &quot;object&quot; ) === &quot;function&quot;`  处理ie下检查创建的&lt;object&gt;标签结果是function</span><br><span class="line">    return typeof obj === &quot;function&quot; &amp;&amp; typeof obj.nodeType !== &quot;number&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>isWindow</code>检测是否为window对象（window中有window属性，指向的是window本身）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var isWindow = function isWindow(obj) &#123;</span><br><span class="line">    // window.window===window</span><br><span class="line">    return obj != null &amp;&amp; obj === obj.window;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="isArrayLike"><a href="#isArrayLike" class="headerlink" title="isArrayLike"></a>isArrayLike</h4><blockquote><p>检测是否为数组或类数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function isArrayLike(obj) &#123;</span><br><span class="line">    // length:对象的length属性值或者是false</span><br><span class="line">    // type:获取检测值的数据类型</span><br><span class="line">    var length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,</span><br><span class="line">        type = toType(obj);</span><br><span class="line"></span><br><span class="line">    // 函数和window一定不是数据或者类数组（但是他们确实有length属性）</span><br><span class="line">    if (isFunction(obj) || isWindow(obj)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // type === &quot;array&quot;：数组</span><br><span class="line">    // length === 0：我们认为其是一空的类数组集合</span><br><span class="line">    // (length - 1) in obj：对于非空集合，我们认为只要最大索引在对象中，则证明索引是逐级递增的（不准确）</span><br><span class="line">    return type === &quot;array&quot; || length === 0 ||</span><br><span class="line">        typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>jquery中检查类数组的方法虽然有些缺陷，但这还是我目前最好的检测类数组的方法了</p></blockquote><h4 id="基于extend拓展到jQuery上的检测方法"><a href="#基于extend拓展到jQuery上的检测方法" class="headerlink" title="基于extend拓展到jQuery上的检测方法"></a>基于extend拓展到jQuery上的检测方法</h4><blockquote><p>简单说以下jQuery的extend方法，它是用来向JQ中拓展方法的，这里介绍的几个方法都是拓展到jQuery上作为工具方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.extend = function()&#123;</span><br><span class="line">    //......</span><br><span class="line">&#125;;</span><br><span class="line">//调用extend</span><br><span class="line">$.extend(&#123;&#125;);       //拓展到JQ对象上：一般是为了完善类库，提供更多的工具方法。</span><br><span class="line">$.extend(true,&#123;&#125;)</span><br><span class="line"></span><br><span class="line">$.fn.extend();      //拓展到JQ原型上：一般是为了写插件，让JQ实例调用</span><br></pre></td></tr></table></figure><h5 id="isEmptyObject"><a href="#isEmptyObject" class="headerlink" title="isEmptyObject"></a>isEmptyObject</h5><blockquote><p>验证是否为空对象：主要是看当前对象中是否存在私有属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function isEmptyObject(obj) &#123;</span><br><span class="line">    var name;</span><br><span class="line">    for (name in obj) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是他这样写，有点问题，如果我们在原型上自定义的属性或者方法也会被枚举，所以这里最好价格判断</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function isEmptyObject(obj) &#123;</span><br><span class="line">    var name;</span><br><span class="line">    for (name in obj) &#123;</span><br><span class="line">        if (!obj.hasOwnProperty(name)) break;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="isPlainObject"><a href="#isPlainObject" class="headerlink" title="isPlainObject"></a>isPlainObject</h5><blockquote><p>是否为纯粹对象，纯粹对象即直属于Object的实例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function isPlainObject(obj) &#123;</span><br><span class="line">    var proto, Ctor;</span><br><span class="line"></span><br><span class="line">    // 基于toString.call返回结果不是[object Object]则一定不是纯粹的对象</span><br><span class="line">    if (!obj || toString.call(obj) !== &quot;[object Object]&quot;) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取当前对象所属类的原型</span><br><span class="line">    proto = getProto(obj);</span><br><span class="line"></span><br><span class="line">    // Object.create(null)：创建一个空对象，但是没有__proto__</span><br><span class="line">    if (!proto) return true;</span><br><span class="line"></span><br><span class="line">    // Ctor：获取当前对象所属类的constructor</span><br><span class="line">    // 纯粹对象的特点：直属类的原型一定是Object.prototype（DOM元素对象/自定义的实例对象...都不是）</span><br><span class="line">    Ctor = hasOwn.call(proto, &quot;constructor&quot;) &amp;&amp; proto.constructor;</span><br><span class="line">    return typeof Ctor === &quot;function&quot; &amp;&amp; fnToString.call(Ctor) === ObjectFunctionString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2020/01/31/2020-1-31-git-md/"/>
      <url>/2020/01/31/2020-1-31-git-md/</url>
      
        <content type="html"><![CDATA[<h3 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h3><blockquote><p>git是一款开源的分布式版本控制系统，能够有效、高速的处理从小到大的项目版本管理。</p></blockquote><a id="more"></a><p>市面上常见的版本控制器有两种：</p><ul><li>分布式的 Git</li><li>集中式的 SVN</li></ul><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><h4 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h4><p>创建仓库</p><pre><code>1.进入需要创建代码仓库的文件夹      cd [文件路径]2.初始化代码仓库                    git init3.远程拉去仓库到本地                git clone</code></pre><p>添加文件到仓库</p><pre><code>1.添加文件到暂存区    + 添加单个文件到暂存区          git add [文件名]    + 添加所用文件到暂存区          git add ./-A2.把暂存区文件提交到历史区    + git commit -m&apos;描述信息&apos;    + 建议使用  git commit 再填写 git message3.查看工作区状态    + git status4.对比工作区变化    + git diff</code></pre><p>仓库配置</p><pre><code>1.配置全局用户名和邮箱    + git config --global user.name &quot;[name]&quot;    + git config --global user,email &quot;[email address]&quot;2.配置当前仓库用户名和密码    + git config user.name &quot;[name]&quot;    + git config user.email &quot;[email address]&quot;</code></pre><p>将本地仓库信息提交到远程仓库</p><pre><code>1.建立本地仓库与远程仓库的连接    + 查看建立连接      git remote -v    + 建立连接          git remote add origin [仓库地址]    + 删除连接          git remote rm origin 2.先拉取在提交    + 拉取              git pull origin master    + 提交              git push origin master</code></pre><p>克隆远程仓库</p><pre><code>git clone [本地仓库] [别名（可省略）]1.初始化本地仓库2.关联远程仓库3.默认内容拉取到本地</code></pre><h4 id="代码版本"><a href="#代码版本" class="headerlink" title="代码版本"></a>代码版本</h4><pre><code>1.查看历史版本信息    + git log                       提交详情    + git log --pretty=oneline      提交简介2.回退版本提交    + git reset --hard HEAD         回退到当前最新提交    + git reset --hard HEAD^        回退到上次提交    + git reset --hard HEAD~n       回退到上n次提交    + git reset --hard commitid     回退到某次提交3.重返未来版本    + git reflog    查看历史提交以及被回退的提交（该记录有时限，且只在本地）    + git reset --herd commitid     回到未来版本4.撤销修改    + 文件去撤销文件（没有提交到暂存区/没有git add）撤销修改    git checkout [文件名]    + 暂存区撤销文件        -将暂存区文件撤销到工作区   git reset HEAD 文件不带--hard        -撤销修改                   git checkout [文件名]5.删除文件    + 从版本库中删除文件（修改后需要提交）  git rm [文件名]    + 恢复删除      参考撤销修改    + 从版本库中删除文件，本地不删除        git rm --cached [文件名]</code></pre><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>创建和合并分支</p><pre><code>1.创建分支    - 仅创建        git branch [分支名]    - 创建并切换    git checkout -b [分支名]2.切换分支          git checkout [分支名]3.合并分支        - 合并某分支到当前分支       git merge        - git rebase   无特殊需求不建议使用4.删除分支    - 删除本地未合并分支    git branch -D    - 删除温蒂已合并分支    git branch -d    - 删除远程分支          git push origin -d                            git push [远程仓库名] -d [分支名]5.查看分支    - 查看当前分支          git branch    - 查看所有分支信息      git branch -a6.合并分支，解决分支冲突    - 将要合并的分支更新到最新    - 切换到主分支    - 合并分支    - 解决合并时的conflict    - 提交到版本库    - 合并成功    - 查看分支状态  git log --graph                    git log --graph --pretty=oneline --abbrey-commit7.开发完成需要提交PR/MR</code></pre><p>暂存修改</p><pre><code>1.暂存工作现场      git stash2.恢复工作现场    - 恢复          git stash apply    - 删除          git stash drop    - 恢复+删除     git stash pop</code></pre><p>多人协作</p><pre><code>1.查看远程库信息    - 详细      git remote -v    - 不详细    git remote2.更新推出远程库    - 更新远程库信息                git fetch    - 将远程库最新更新到本地库       git pull    - 将本地修改推送到远程库         git push                                   git push origin [分支名]3.本地分支与远程分支交互    - 使用远程分支A创建本地分支     git checkout -b origin/A    - 将本地分支与远程分支关联      git branch --set-upstream A origin/A</code></pre><h4 id="代码版本tag"><a href="#代码版本tag" class="headerlink" title="代码版本tag"></a>代码版本tag</h4><pre><code>1.查看tag    - 本地tag       git tag    - 远程tag       git tag -r2.操作tag    - 添加tag               + 给当前版本添加tag     git tag [标签名]        + 给历史版本添加tag     git tag [标签名] commitid    - 删除tag        + 删除本地标签          git tag -d [标签名]        + 删除远程标签          git push origin -d    - 推送到远端仓库            git push origin [标签名]        + 推送所有未提交tag     git push origin --tags    - 更新到本地        git pull origin --tagstag与branch的操作基本一致，因为tag就是一个仅可读的branch</code></pre><blockquote><p>可以使用 git help 查看常用的命令，使用 git help -a 可以查看所有的git命令</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS实现冒泡、插入、快速排序</title>
      <link href="/2019/12/06/2019-12-6-%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-md/"/>
      <url>/2019/12/06/2019-12-6-%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-md/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubble(ary)&#123;</span><br><span class="line">    let temp = null;</span><br><span class="line">    for(let i = 0; i &lt; ary.length-1; i++)&#123;</span><br><span class="line">        for(let j = 0; j &lt; ary.length-1-i; j++)&#123;</span><br><span class="line">            if(ary[j] &gt; ary[j+1])&#123;</span><br><span class="line">                temp = ary[j];</span><br><span class="line">                ary[j] = ary[j+1];</span><br><span class="line">                ary[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function insert(ary)&#123;</span><br><span class="line">    let newAry = [];</span><br><span class="line">    newAry.push(ary[0]);</span><br><span class="line">    for(let i = 1; i &lt; ary.length; i++)&#123;</span><br><span class="line">        let A = ary[i];</span><br><span class="line">        for(let j =newAry.length-1; j &gt;=0; j--)&#123;</span><br><span class="line">            let B = newAry[j];</span><br><span class="line">            if(A&gt;B)&#123;</span><br><span class="line">                newAry.splice(j+1,0,A);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j===0)&#123;</span><br><span class="line">                newAry.unshift(A);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newAry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function quick(ary)&#123;</span><br><span class="line">    if(ary.length&lt;=1)&#123;</span><br><span class="line">        return ary;</span><br><span class="line">    &#125;</span><br><span class="line">    let middleIndex = Math.floor(ary.length/2);</span><br><span class="line">    let middleValue = ary.splice(middleIndex,1)[0];</span><br><span class="line">    let aryLeft = [];</span><br><span class="line">    let aryRight = [];</span><br><span class="line">    for(let i = 0;i&lt;ary.length;i++)&#123;</span><br><span class="line">        let item = ary[i];</span><br><span class="line">        item &lt; middleValue ? aryLeft.push(item):aryRight.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    return quick(aryLeft).concat(middleValue,quick(aryRight));</span><br><span class="line">&#125;</span><br><span class="line">var ary = [1,25,23,2,61,22,35,99];</span><br><span class="line">console.log(ary);</span><br><span class="line">var result = quick(ary);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>formatTime</title>
      <link href="/2019/11/28/2019-11-28-formatTime-md/"/>
      <url>/2019/11/28/2019-11-28-formatTime-md/</url>
      
        <content type="html"><![CDATA[<h2 id="格式化时间字符串"><a href="#格式化时间字符串" class="headerlink" title="格式化时间字符串"></a>格式化时间字符串</h2><a id="more"></a><h3 id="实现一个不足两位补零函数"><a href="#实现一个不足两位补零函数" class="headerlink" title="实现一个不足两位补零函数"></a>实现一个不足两位补零函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let addZero = val =&gt; &#123;</span><br><span class="line">val = Number(val);</span><br><span class="line">return val &lt; 10 ? &apos;0&apos; + val : val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法一：基于String方法实现"><a href="#方法一：基于String方法实现" class="headerlink" title="方法一：基于String方法实现"></a>方法一：基于String方法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let time = &apos;2019-11-28 12:0:0&apos;;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> *formatTime:格式化时间字符串</span><br><span class="line"> *  @params:time</span><br><span class="line"> *      未处理的时间字符串</span><br><span class="line"> *  @return:result</span><br><span class="line"> *      格式化处理的时间字符串</span><br><span class="line"> */</span><br><span class="line">function formatTime(time) &#123;</span><br><span class="line">//1.获取年月日等信息</span><br><span class="line">let ary = time.split(&apos; &apos;),</span><br><span class="line">aryLeft = ary[0].split(&apos;-&apos;),</span><br><span class="line">aryRight = ary[1].split(&apos;:&apos;);</span><br><span class="line">ary = aryLeft.concat(aryRight);</span><br><span class="line">//2.拼接字符串格式</span><br><span class="line">let result = ary[0] + &apos;年&apos; + addZero(ary[1]) + &apos;月&apos; + addZero(ary[2]) + &apos;日&apos;;</span><br><span class="line">result += &apos; &apos; + addZero(ary[3]) + &apos;:&apos; + addZero(ary[4]) + &apos;:&apos; + addZero(ary[5]);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">let newTime = formatTime(time);</span><br></pre></td></tr></table></figure><blockquote><p>容错性不好，当未处理的日期传入不完整时，会报错</p></blockquote><h3 id="方法二-基于时间对象处理"><a href="#方法二-基于时间对象处理" class="headerlink" title="方法二:基于时间对象处理"></a>方法二:基于时间对象处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function formatTime(time) &#123;</span><br><span class="line">//1.把时间字符串转化为标准日期对象</span><br><span class="line">time = time.replace(/-/g, &apos;/&apos;);</span><br><span class="line">time = new Date(time);</span><br><span class="line">//基于日期对象分别获取时间信息</span><br><span class="line">let year = time.getFullYear(),</span><br><span class="line">month = addZero(time.getMonth() + 1),</span><br><span class="line">day = addZero(time.getDate()),</span><br><span class="line">hours = addZero(time.getHours()),</span><br><span class="line">minutes = addZero(time.getMinutes()),</span><br><span class="line">second = addZero(time.getSeconds());</span><br><span class="line">//格式化字符串</span><br><span class="line">return year+&apos;年&apos;+month+&apos;月&apos;+day+&apos;日&apos;+&apos; &apos;+hours+&apos;:&apos;+minutes+&apos;:&apos;+second;</span><br><span class="line">&#125;</span><br><span class="line">let newTime = formatTime(time);</span><br></pre></td></tr></table></figure><blockquote><p>容错性好，但是输出格式固定</p></blockquote><h3 id="方法三：公用时间字符串处理"><a href="#方法三：公用时间字符串处理" class="headerlink" title="方法三：公用时间字符串处理"></a>方法三：公用时间字符串处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.formatTime = function formatTime(template) &#123;</span><br><span class="line">//初始化模板</span><br><span class="line">typeof template === &apos;undefined&apos; ? template = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;:&#123;4&#125;:&#123;5&#125;&quot; : null;</span><br><span class="line">//this:要处理的字符串</span><br><span class="line">//获取日期字符串中的数字信息</span><br><span class="line">let matchAry = this.match(/\d+/g);</span><br><span class="line">//模板和数据的渲染</span><br><span class="line">template = template.replace(/\&#123;(\d+)\&#125;/g, (x, y) =&gt; &#123;</span><br><span class="line">let val = matchAry[y] || &apos;00&apos;;</span><br><span class="line">val.length &lt; 2 ? val = &apos;0&apos; + val : null;</span><br><span class="line">return val;</span><br><span class="line">&#125;);</span><br><span class="line">return template;</span><br><span class="line">&#125;</span><br><span class="line">console.log(time.formatTime());</span><br></pre></td></tr></table></figure><blockquote><p>基于模板和数据的渲染，能够按理想格式输出</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装queryURLParams函数</title>
      <link href="/2019/11/26/2019-11-26-queryURLParams-md/"/>
      <url>/2019/11/26/2019-11-26-queryURLParams-md/</url>
      
        <content type="html"><![CDATA[<h2 id="封装queryURLParams函数"><a href="#封装queryURLParams函数" class="headerlink" title="封装queryURLParams函数"></a>封装queryURLParams函数</h2><a id="more"></a><h3 id="方法一：基于数组的方法"><a href="#方法一：基于数组的方法" class="headerlink" title="方法一：基于数组的方法"></a>方法一：基于数组的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let url = &apos;http://www.lizhutao.github.io/index.html?id=1&amp;name=lzt&amp;age=20#box&apos;;</span><br><span class="line"></span><br><span class="line">function queryURLParams(url) &#123;</span><br><span class="line">//1.获取？后面的信息</span><br><span class="line">let askIn = url.indexOf(&apos;?&apos;),</span><br><span class="line">wellIn = url.lastIndexOf(&apos;#&apos;),</span><br><span class="line">askText = &apos;&apos;,</span><br><span class="line">wellText = &apos;&apos;;</span><br><span class="line">//#号不存在</span><br><span class="line">wellIn === -1 ? wellText = url.length : null;</span><br><span class="line">//?号存在</span><br><span class="line">askIn !== -1 ? askText = url.substring(askIn + 1, wellIn) : null;</span><br><span class="line">wellText = url.substring(wellIn + 1);</span><br><span class="line"></span><br><span class="line">//2.获取每一部分的信息</span><br><span class="line">let result = &#123;&#125;;</span><br><span class="line">//获取 HASH 值</span><br><span class="line">wellText !== &apos;&apos; ? result[&apos;HASH&apos;] = wellText : null;</span><br><span class="line">if (askText !== &apos;&apos;) &#123;</span><br><span class="line">let ary = askText.split(&apos;&amp;&apos;);</span><br><span class="line">ary.forEach(item =&gt; &#123;</span><br><span class="line">let itemAry = item.split(&apos;=&apos;);</span><br><span class="line">result[itemAry[0]] = itemAry[1];</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let paramObj = queryURLParams(url);</span><br><span class="line">console.log(paramObj);</span><br></pre></td></tr></table></figure><h3 id="方法二：基于正则表达式实现"><a href="#方法二：基于正则表达式实现" class="headerlink" title="方法二：基于正则表达式实现"></a>方法二：基于正则表达式实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let url = &apos;http://www.lizhutao.github.io/index.html?id=1&amp;name=lzt&amp;age=20#box&apos;;</span><br><span class="line"></span><br><span class="line">function queryURLParams(url) &#123;</span><br><span class="line">let result = &#123;&#125;,</span><br><span class="line">reg1 = /([^?#&amp;=]+)=([^?#&amp;=]+)/g,</span><br><span class="line">reg2 = /#([^?#&amp;=]+)/g;</span><br><span class="line">url.replace(reg1, (n, x, y) =&gt; result[x] = y);</span><br><span class="line">url.replace(reg2, (n, x ) =&gt; result[&apos;HASH&apos;] = x);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let paramObj = queryURLParams(url);</span><br><span class="line">console.log(paramObj);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重</title>
      <link href="/2019/11/26/2019-11-26-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D-md/"/>
      <url>/2019/11/26/2019-11-26-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D-md/</url>
      
        <content type="html"><![CDATA[<h2 id="数组去重的方法"><a href="#数组去重的方法" class="headerlink" title="数组去重的方法"></a>数组去重的方法</h2><a id="more"></a><h3 id="方法一：创建新数组"><a href="#方法一：创建新数组" class="headerlink" title="方法一：创建新数组"></a>方法一：创建新数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let newAry = [];</span><br><span class="line">for (let i = 0; i &lt; ary.length; i++)&#123;</span><br><span class="line">let item = ary[i];</span><br><span class="line">if(newAry.includes(item))&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">newAry.push(item);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary,newAry);</span><br><span class="line"></span><br><span class="line">//代码优化</span><br><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let newAry = [];</span><br><span class="line">ary.forEach(item=&gt;&#123;</span><br><span class="line">if(newAry.includes(item))return;</span><br><span class="line">newAry.push(item);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(ary,newAry);</span><br></pre></td></tr></table></figure><h3 id="方法二：嵌套for循环操作原有数组"><a href="#方法二：嵌套for循环操作原有数组" class="headerlink" title="方法二：嵌套for循环操作原有数组"></a>方法二：嵌套for循环操作原有数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">for (let i = 0; i &lt; ary.length; i++) &#123;</span><br><span class="line">let item = ary[i];</span><br><span class="line">for (let j = i + 1; j &lt; ary.length; j++) &#123;</span><br><span class="line">let item2 = ary[j];</span><br><span class="line">if (item === item2)&#123;</span><br><span class="line">ary.splice(j,1);  //数组塌陷</span><br><span class="line">j--;          //解决数组塌陷问题</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary);  =&gt;//[1, 2, 3]</span><br></pre></td></tr></table></figure><blockquote><p> 数组的splice方法在操作数组的时候会导致数组塌陷问题</p></blockquote><h3 id="方法三：新建对象比较"><a href="#方法三：新建对象比较" class="headerlink" title="方法三：新建对象比较"></a>方法三：新建对象比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">for (let i = 0; i &lt; ary.length; i++) &#123;</span><br><span class="line">let item = ary[i];</span><br><span class="line">if (obj[item] === item) &#123;   //或  obj[item] !== undefined</span><br><span class="line">ary.splice(i, 1);</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">obj[item] = item;</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary);</span><br></pre></td></tr></table></figure><blockquote><p>操作数据大时，性能不好</p></blockquote><h3 id="方法四-遇到重复项将最后一项赋值给当前项，并删除最后一项"><a href="#方法四-遇到重复项将最后一项赋值给当前项，并删除最后一项" class="headerlink" title="方法四:遇到重复项将最后一项赋值给当前项，并删除最后一项"></a>方法四:遇到重复项将最后一项赋值给当前项，并删除最后一项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">for (let i = 0; i &lt; ary.length; i++) &#123;</span><br><span class="line">let item = ary[i];</span><br><span class="line">if (obj[item] !== undefined) &#123;  //obj中有这一项</span><br><span class="line">ary[i] == ary[ary.length-1];</span><br><span class="line">ary.length--;</span><br><span class="line">i--;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">obj[item] = item;</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary);</span><br></pre></td></tr></table></figure><blockquote><p>操作数据比较大的时候，性能比较好；</p></blockquote><h3 id="方法五：ES6数据结构–set-方法"><a href="#方法五：ES6数据结构–set-方法" class="headerlink" title="方法五：ES6数据结构–set()方法"></a>方法五：ES6数据结构–set()方法</h3><blockquote><p>ES6新增的一种新的数据结构，类似于数组，但成员是唯一的且无序的，没有重复值。Set本身是一种构造函数，用来生成Set数据结构。Set对象允许你存储任何类型的唯一值，无论是原始值还是对象引用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];</span><br><span class="line">let ary1 = [...new Set(ary)];  //使用剩余参数转数组</span><br><span class="line">console.log(ary1);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
